<?xml version="1.0" encoding="utf-8" ?>
<Workflow>
  <Scheduler>
    <Task Name="AudioDownload">
      <Condition Type="Values">
        <Hour>6</Hour>
        <Minute>0</Minute>
        <Second>0</Second>
      </Condition>
      <Commands>
        <If>
          <When>
            <Condition Name="AudioAuthTokenExistsSqlQueryCondition" />
          </When>
          <Then>
            <Command Name="AudioDownloadCommand" />
          </Then>
        </If>
      </Commands>
      <ExecutionStrategy>ExecuteLastMissed</ExecutionStrategy>
    </Task>

    <Task Name="FsspStatusCheck">
      <Condition Type="Values">
        <Minute>/2</Minute>
      </Condition>
      <Commands>
        <If>
          <When>
            <Condition Name="ModuleFsspAvailableSqlQueryCondition" />
          </When>
          <Then>
            <Command Name="FsspCheckingStatusCommand" />
          </Then>
        </If>
      </Commands>
      <ExecutionStrategy>Restart</ExecutionStrategy>
    </Task>

    <Task Name="FsspAutoCheck">
      <Condition Type="Query">
        <Text>
          SELECT
            extract(hour FROM fssp_auto_check_time) AS "Hour",
            extract(minute FROM fssp_auto_check_time) AS "Minute",
            0 AS "Second"
          FROM
            collect.settings
          ORDER BY settings_id
          LIMIT 1;
        </Text>
      </Condition>
      <Commands>
        <If>
          <When>
            <And>
              <Condition Name="ModuleFsspAvailableSqlQueryCondition" />
              <Condition Name="FsspAutoCheckIsOnSqlQueryCondition" />
            </And>
          </When>
          <Then>
            <Command Name="FsspAutoCheckingCommand" />
          </Then>
        </If>
      </Commands>
      <ExecutionStrategy>ExecuteLastMissed</ExecutionStrategy>
    </Task>

    <Task Name="Autotask">
      <Condition Type="Query">
        <Text>
          SELECT
            '/' || COALESCE(autotask_auto_check_minutes_interval, 5) AS "Minute"
          FROM
            collect.settings
          ORDER BY settings_id
          LIMIT 1;
        </Text>
      </Condition>
      <Commands>
        <If>
          <When>
            <And>
              <Condition Name="ModuleAutotaskAvailableSqlQueryCondition" />
              <Condition Name="AutotaskAutoCheckIsOnSqlQueryCondition" />
            </And>
          </When>
          <Then>
            <Command Name="AutotaskCommand" />
          </Then>
        </If>
      </Commands>
      <ExecutionStrategy>ExecuteLastMissed</ExecutionStrategy>
    </Task>

    <Task Name="EmailMailing">
      <Condition Type="Values">
        <Minute>/10</Minute>
      </Condition>
      <Commands>
        <Command Name="SendEmailMailingCommand" />
      </Commands>
      <ExecutionStrategy>ExecuteLastMissed</ExecutionStrategy>
    </Task>

    <Task Name="PochtaRuChecking">
      <Condition Type="Values">
        <Hour>0</Hour>
        <Minute>1</Minute>
      </Condition>
      <Commands>
        <If>
          <When>
            <Condition Name="PochtaRuRefreshAllowedSqlQueryCondition" />
          </When>
          <Then>
            <Command Name="PochtaRuRefreshCommand" />
          </Then>
        </If>
      </Commands>
    </Task>

    <Task Name="BkiNeedForExportChecking">
      <Condition Type="Values">
        <Day>/1</Day>
      </Condition>
      <Commands>
        <If>
          <When>
            <Condition Name="ModuleNbkiAvailableSqlQueryCondition" />
          </When>
          <Then>
            <Command Name="BkiNeedForExportSqlQueryCommand">
              <Parameter Name="BkiType">nbki</Parameter>
            </Command>
          </Then>
        </If>
        <If>
          <When>
            <Condition Name="ModuleEquifaxAvailableSqlQueryCondition" />
          </When>
          <Then>
            <Command Name="BkiNeedForExportSqlQueryCommand">
              <Parameter Name="BkiType">equifax</Parameter>
            </Command>
          </Then>
        </If>
        <If>
          <When>
            <Condition Name="ModuleOkbAvailableSqlQueryCondition" />
          </When>
          <Then>
            <Command Name="BkiNeedForExportSqlQueryCommand">
              <Parameter Name="BkiType">okb</Parameter>
            </Command>
          </Then>
        </If>
      </Commands>
    </Task>

    <Task Name="SMSMailingRefreshStatus">
      <Condition Type="Values">
        <Minute>/30</Minute>
      </Condition>
      <Commands>
        <If>
          <When>
            <Condition Name="SMSModuleIsOnSqlQueryCondition" />
          </When>
          <Then>
            <Command Name="SMSGetStatusByTaskCommand" />
          </Then>
        </If>
      </Commands>
      <ExecutionStrategy>Restart</ExecutionStrategy>
    </Task>

    <Task Name="HappyBirthdaySMSMailing">
      <Condition Type="Query">
        <Text>
          SELECT
            extract(hour FROM auto_send_bday_sms_time) AS "Hour",
            extract(minute FROM auto_send_bday_sms_time) AS "Minute",
            0 AS "Second"
          FROM collect.settings;
      </Text>
      </Condition>
      <Commands>
        <If>
          <When>
            <And>
              <Condition Name="SMSModuleIsOnSqlQueryCondition" />
              <Condition Name="AutoSendBirthdaySMSSqlQueryCondition" />
            </And>
          </When>
          <Then>
            <If>
              <When>
                <Condition Name="ClientBirthdayTodayExistsCondition" />
              </When>
              <Then>
                <Command Name="SMSMailingBirthdayInsertSqlQueryCommand" />
                <If>
                  <When>
                    <Condition Name="SMSMailingBirthdayIdIsNotNullCondition" />
                  </When>
                  <Then>
                    <Command Name="SMSClientSendCommand">
                      <Parameter Name="MessageMailingId">
                        <Command Name="SMSMailingBirthdayInsertSqlQueryCommand" GetScalar="True" />
                      </Parameter>
                    </Command>
                  </Then>
                </If>
              </Then>
            </If>
          </Then>
        </If>
      </Commands>
      <ExecutionStrategy>ExecuteLastMissed</ExecutionStrategy>
    </Task>
  </Scheduler>

  <Conditions>
    <Condition Name="AudioAuthTokenExistsSqlQueryCondition" Type="SqlQueryCondition">
      <Text>
        SELECT
          audio_auth_token IS NOT NULL
        FROM
          collect.settings
        ORDER BY settings_id LIMIT 1;
      </Text>
    </Condition>

    <Condition Name="ModuleFsspAvailableSqlQueryCondition" Type="SqlQueryCondition">
      <Text>
        SELECT
          COALESCE(module_fssp_available, false)
        FROM
          collect.settings
        ORDER BY settings_id LIMIT 1;
      </Text>
    </Condition>

    <Condition Name="FsspAutoCheckIsOnSqlQueryCondition" Type="SqlQueryCondition">
      <Text>
        SELECT
          COALESCE(fssp_auto_checking, false)
        FROM
          collect.settings
        ORDER BY settings_id LIMIT 1;
      </Text>
    </Condition>

    <Condition Name="ModuleAutotaskAvailableSqlQueryCondition" Type="SqlQueryCondition">
      <Text>
        SELECT
          COALESCE(module_autotask_available, false)
        FROM
          collect.settings
        ORDER BY settings_id LIMIT 1;
      </Text>
    </Condition>

    <Condition Name="AutotaskAutoCheckIsOnSqlQueryCondition" Type="SqlQueryCondition">
      <Text>
        SELECT
          COALESCE(autotask_auto_checking, false)
        FROM
          collect.settings
        ORDER BY settings_id LIMIT 1;
      </Text>
    </Condition>

    <Condition Name="PochtaRuRefreshAllowedSqlQueryCondition" Type="SqlQueryCondition">
      <Text>
        SELECT
          EXTRACT(DOW FROM now())::smallint = ANY(module_pochtaru_days_of_week)
        FROM
          collect.settings;
      </Text>
    </Condition>

    <!-- BKI -->
    <Condition Name="ModuleNbkiAvailableSqlQueryCondition" Type="SqlQueryCondition">
      <Text>
        SELECT
          COALESCE(module_nbki_available, false)
        FROM
          collect.settings;
      </Text>
    </Condition>

    <Condition Name="ModuleEquifaxAvailableSqlQueryCondition" Type="SqlQueryCondition">
      <Text>
        SELECT
          COALESCE(module_okb_available, false)
        FROM
          collect.settings;
      </Text>
    </Condition>

    <Condition Name="ModuleOkbAvailableSqlQueryCondition" Type="SqlQueryCondition">
      <Text>
        SELECT
          COALESCE(module_equifax_available, false)
        FROM
          collect.settings;
      </Text>
    </Condition>

    <Condition Name="SMSModuleIsOnSqlQueryCondition" Type="SqlQueryCondition">
      <Text>
        SELECT sms_module_is_on AND NOT hide_sms_module FROM collect.settings;
      </Text>
    </Condition>

    <Condition Name="AutoSendBirthdaySMSSqlQueryCondition" Type="SqlQueryCondition">
      <Text>
        SELECT auto_send_bday_sms FROM collect.settings;
      </Text>
    </Condition>

    <Condition Name="ClientBirthdayTodayExistsCondition" Type="SqlQueryCondition">
      <Text>
        SELECT EXISTS(SELECT * FROM collect.client_birthday_today_view);
      </Text>
    </Condition>

    <Condition Name="SMSMailingBirthdayIdIsNotNullCondition" Type="IsNotNullCondition">
      <Items>
        <Item>
          <Command Name="SMSMailingBirthdayInsertSqlQueryCommand" GetScalar="True" />
        </Item>
      </Items>
      <DataType Type="IntegerDataType" />
    </Condition>
  </Conditions>

  <Commands>
    <Command Name="AudioDownloadCommand" Type="AudioDownloadCommand" Assembly="CollectEngine">
      <SettingsSqlQuery>
        SELECT
          COALESCE(audio_last_record_id,-1) AS "LastRecordId",
          audio_url as "Url",
          audio_auth_token as "Key",
          audio_list_api as "GetListApi",
          audio_operator as "Operator",
          audio_file_api as "GetFileApi",
          COALESCE(audio_correction,0) as "Correction",
          COALESCE(audio_last_date, '2000-01-01'::date) AS "LastDateLoading"
        FROM
          collect.settings
        ORDER BY settings_id LIMIT 1;
      </SettingsSqlQuery>
      <CheckForExistsSqlQuery>
        SELECT
          EXISTS (
            SELECT
              temp_audio_file_id
            FROM
              collect.temp_audio_file
            WHERE
              record_id = {CalldId}
          ) AS "Value";
      </CheckForExistsSqlQuery>
      <LastDateLoadingSetSqlQuery>
        UPDATE
          collect.settings
        SET
          audio_last_date = now()::timestamp;
      </LastDateLoadingSetSqlQuery>
      <InsertSqlQuery>
        INSERT INTO collect.temp_audio_file(
          file_id,
          client_phone_number,
          user_phone_number,
          call_time,
          record_id,
          call_direction,
          call_duration)
        SELECT
          (SELECT file_id FROM public.file WHERE guid = {Guid}),
          {PhoneNumber},
          {UserPhoneNumber},
          ({CallTime}||'+'||{TimeZone})::timestamp,
          {RecordId},
          ({CallDirection} = 'INB'),
          ({CallDuration}/1000)::integer;

        UPDATE
          collect.settings
        SET
          audio_last_record_id = {RecordId};
      </InsertSqlQuery>
    </Command>

    <!-- Ручная проверка в фссп -->
    <Command Name="FsspCheckingCommand" Type="FSSPCheckingCommand" Assembly="CollectEngine">
      <DataSqlQuery>
        <Text>
          WITH client_data AS (
            SELECT
              DISTINCT ON (CP.client_id)
              CP.client_id AS "DebtorId",
              CP.second_name AS "Name",
              CP.first_name AS "Surname",
              CP.third_name AS "MiddleName",
              to_char(CP.birth_date, 'dd.MM.yyyy') AS "BirthDate",
              AR.fssp_num AS "Region",
              1 AS "FsspType",
              NULL::character varying AS "ExecutiveNumber"
            FROM
              collect.loan_client LC
              LEFT JOIN collect.client_person CP USING(client_id)
              LEFT JOIN collect.address_region AR USING(address_region_id)
            WHERE
              {CheckType} = 'client' AND
              LC.loan_id = {LoanId} AND
              CP.first_name IS NOT NULL AND
              CP.second_name IS NOT NULL AND
              CP.third_name IS NOT NULL AND
              CP.birth_date IS NOT NULL AND
              AR.fssp_num IS NOT NULL
            ORDER BY CP.client_id
          )
          SELECT
            *
          FROM
            client_data

          UNION ALL

          SELECT
            LC.client_id AS "DebtorId",
            NULL AS "Name",
            NULL AS "Surname",
            NULL AS "MiddleName",
            NULL AS "BirthDate",
            NULL AS "Region",
            3 AS "FsspType",
            LCE.number AS "ExecutiveNumber"
          FROM
            collect.loan_client LC
            LEFT JOIN collect.loan_client_collection LCC USING(loan_client_id)
            LEFT JOIN collect.loan_client_executive LCE USING(loan_client_collection_id)
          WHERE
            {CheckType} = 'executive' AND
            LC.loan_id = {LoanId} AND
            COALESCE(trim(LCE.number), '') != '';
        </Text>
      </DataSqlQuery>
      <SaveDataSqlQuery>
        <Text>
          INSERT INTO collect.fssp_checking_task(
            task,
            "group",
            debtor_id,
            user_id,
            urgent,
            executive_process)
          VALUES (
            {Task},
            {Group},
            {DebtorId}::bigint[],
            {FsspUserId},
            {Urgent},
            {ExecProduction}::text[]);

          UPDATE
            collect.client
          SET
            fssp_last_check_date = now()::timestamp
          WHERE
            client_id = ANY({DebtorId}::bigint[]);
        </Text>
      </SaveDataSqlQuery>
      <SettingsSqlQuery>
        <Text>
          SELECT
            module_fssp_available AS "ModuleFsspAvailable",
            fssp_token AS "FsspToken",
            fssp_max_group_size AS "FsspMaxGroupSize"
          FROM
            collect.settings
          ORDER BY settings_id LIMIT 1;
        </Text>
      </SettingsSqlQuery>
    </Command>

    <!-- Автоматическая проверка в фссп -->
    <Command Name="FsspAutoCheckingCommand" Type="FSSPAutoCheckingCommand" Assembly="CollectEngine">
      <DataSqlQuery>
        <Text>
          WITH settings AS (
            SELECT
              fssp_auto_check_days_interval
            FROM
              collect.settings
            ORDER BY settings_id
            LIMIT 1
          )
          SELECT
            CP.client_id AS "DebtorId",
            CP.second_name AS "Name",
            CP.first_name AS "Surname",
            CP.third_name AS "MiddleName",
            to_char(CP.birth_date, 'dd.MM.yyyy') AS "BirthDate",
            AR.fssp_num AS "Region",
            1 AS "FsspType",
            NULL::character varying AS "ExecutiveNumber"
          FROM
            collect.client C
            LEFT JOIN collect.client_person CP USING(client_id)
            LEFT JOIN collect.address_region AR USING(address_region_id)
            LEFT JOIN settings ST ON true
          WHERE
            NOT C.deleted AND
            CP.first_name IS NOT NULL AND
            CP.second_name IS NOT NULL AND
            CP.third_name IS NOT NULL AND
            CP.birth_date IS NOT NULL AND
            AR.fssp_num IS NOT NULL AND
            date_part('day', now()::timestamp - COALESCE(C.fssp_last_check_date, '01.01.2000'::timestamp))::integer >= ST.fssp_auto_check_days_interval
          ORDER BY CP.client_id;
        </Text>
      </DataSqlQuery>
      <SaveDataSqlQuery>
        <Text>
          INSERT INTO collect.fssp_checking_task(
            task,
            "group",
            debtor_id,
            user_id,
            urgent,
            executive_process)
          SELECT
            {Task},
            {Group},
            {DebtorId}::bigint[],
            COALESCE({FsspUserId}::smallint, UI.user_id),
            {Urgent},
            {ExecProduction}::text[]
          FROM
            collect.user_info UI
          WHERE
            user_name = '$workflow_engine$';

          UPDATE
            collect.client
          SET
            fssp_last_check_date = now()::timestamp
          WHERE
            client_id = ANY({DebtorId}::bigint[]);
        </Text>
      </SaveDataSqlQuery>
      <SettingsSqlQuery>
        <Text>
          SELECT
            fssp_auto_checking AS "FsspAutoChecking",
            fssp_token AS "FsspToken",
            fssp_max_group_size AS "FsspMaxGroupSize"
          FROM
            collect.settings
          ORDER BY settings_id LIMIT 1;
        </Text>
      </SettingsSqlQuery>
      <IsAllReadySqlQuery>
        SELECT
          NOT EXISTS (
            SELECT
              1
            FROM
              collect.fssp_checking_task
            WHERE
              NOT ready
          ) AS "IsAllReady";
      </IsAllReadySqlQuery>
    </Command>

    <!-- Обновление информации по таскам ФССП-->
    <Command Name="FsspCheckingStatusCommand" Type="FSSPCheckingStatusCommand" Assembly="CollectEngine">
      <FSSPCheckingTaskSelectSqlQuery>
        SELECT
          FCT.task AS "Task",
          FCT.ready AS "Ready",
          FCT."group" AS "Group",
          FCT.date_start AS "DateStart",
          COALESCE(FCT.user_id, UI.user_id) AS "UserId",
          FCT.debtor_id AS "DebtorId"
        FROM
          collect.fssp_checking_task FCT
          LEFT JOIN collect.user_info UI ON UI.user_name = '$workflow_engine$'
        WHERE
          NOT ready
        ORDER BY urgent DESC, date_start
        LIMIT 5;
      </FSSPCheckingTaskSelectSqlQuery>
      <FSSPCheckingTaskUpdateSqlQuery>
        UPDATE
          collect.fssp_checking_task
        SET
          ready = {Ready},
          status = {Status},
          user_check = {UserCheck},
          check_date = now()::timestamp,
          error = NULL
        WHERE
          task = {Task};
      </FSSPCheckingTaskUpdateSqlQuery>
      <OnErrorSqlQuery>
        UPDATE
          collect.fssp_checking_task
        SET
          status = {Status},
          ready = {Ready},
          error = {Error},
          user_check = false,
          check_date = now()::timestamp
        WHERE
          task = {Task};
      </OnErrorSqlQuery>
      <FSSPCheckingInsertSqlQuery>
        WITH client_titles AS (
          SELECT
            DISTINCT client_title
          FROM
            unnest({Name}::character varying[]) AS client_title
        ), client_person_info AS (
          SELECT
            DISTINCT ON (CT.client_title)
            CP.client_id,
            CT.client_title
          FROM
            collect.client_person CP
            JOIN client_titles CT ON collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) ilike '%' || CT.client_title || '%'
          ORDER BY CT.client_title, CP.client_id
        )
        INSERT INTO collect.fssp_checking(
          client_id,
          check_date,
          client_title,
          executive,
          details,
          subject,
          debt_rest_sum,
          department,
          bailiff,
          executive_end,
          user_id)
        SELECT
          COALESCE(CPI.client_id, T.client_id),
          now()::timestamp,
          client_title,
          executive,
          details,
          subject,
          trim(substring(subject, '\d*\.?\d*\sруб'), ' руб')::numeric,
          department,
          replace(bailiff, <![CDATA['<br>']]>, E'\r\n'),
          executive_end,
          user_id
        FROM
          unnest(
            {DebtorId}::integer[],
            {Name}::character varying[],
            {ExeProduction}::character varying[],
            {Details}::character varying[],
            {Subject}::character varying[],
            {Department}::character varying[],
            {Bailiff}::character varying[],
            {IPEnd}::character varying[],
            {FsspUserId}::integer[]
          ) AS T (
            client_id,
            client_title,
            executive,
            details,
            subject,
            department,
            bailiff,
            executive_end,
            user_id
          )
          LEFT JOIN client_person_info CPI USING(client_title)
        WHERE
          NOT EXISTS(
            SELECT
              1
            FROM
              collect.fssp_checking FC
            WHERE
              FC.client_title = T.client_title AND
              FC.executive = T.executive AND
              FC.details = T.details AND
              FC.subject = T.subject AND
              FC.department = T.department AND
              FC.bailiff = replace(T.bailiff, <![CDATA['<br>']]>, E'\r\n') AND
              FC.executive_end = T.executive_end
          );
      </FSSPCheckingInsertSqlQuery>
      <SettingsSqlQuery>
        SELECT
          fssp_token AS "FsspToken"
        FROM
          collect.settings
        ORDER BY settings_id LIMIT 1;
      </SettingsSqlQuery>
    </Command>

    <Command Name="AutotaskCommand" Type="AutotaskCommand" Assembly="CollectEngine">
      <FiltersSqlQuery>
        SELECT
          autotask_filter_id AS "AutotaskFilterId",
          title AS "Title",
          task_type_id AS "TaskTypeId",
          deadline AS "Deadline",
          deadline_type AS "DeadlineType",
          user_id AS "ResponsibleUserId",
          description AS "Description",
          filter AS "Filter"
        FROM
          collect.autotask_filter AF
          LEFT JOIN (
            SELECT
              autotask_filter_id,
              array_agg(user_id) AS user_id
            FROM
              collect.autotask_filter_responsible_user
            GROUP BY
              autotask_filter_id
          ) UI USING(autotask_filter_id)
        WHERE
          NOT archive AND
          (
            deadline_type AND
            deadline::date >= now()::date OR
            NOT deadline_type
          )
      </FiltersSqlQuery>
      <FieldsSqlQuery>
        SELECT
          column_name AS "ColumnName",
          title AS "Title",
          type AS "Type"
        FROM
          collect.autotask_field;
      </FieldsSqlQuery>
      <FilteredSqlQuery>
        WITH loan_client_payment_info AS (
          SELECT
            loan_client_id,
            MAX(date) AS last_payment_date,
            SUM(sum) AS total_payment_sum
          FROM
            collect.loan_client_payment
          GROUP BY
            loan_client_id
        ), filtered_query AS (
          SELECT
            LC.loan_id,
            LC.client_id,

            -- Даты
            LCS.court_date AS "SuccessionCourtDate",
            LCPI.last_payment_date AS "PaymentLoanClientLastDate",
            LCE.start_date AS "ExecutiveStartDate",
            LC.repayment_date AS "RepaymentDate",
            CB.sale_property_date AS "BankruptSalePropertyDate",
            LCE.end_date AS "ExecutiveEndDate",
            LCE.send_date AS "ExecutiveSendDate",
            CASE 
              WHEN NOT LP.direction
              THEN LP.date
            END AS "PostOutDate",
            CASE 
              WHEN LP.direction
              THEN LP.date
            END AS "PostInDate",

            -- Строки
            CPP.phone_number AS "ClientPhone",
            CP.email AS "ClientEmail",
            S.title AS "LoanClientStatus",
            CB.description AS "BankruptDescription",
            LCC.case_number AS "CollectionCaseNumber",
            LCE.number AS "ExecutiveNumber",
            LCE.end_reason AS "ExecutiveEndReason",
            LP.post_number AS "PostNumber",
            F.name AS "PostFileName",

            -- Числа
            COALESCE(LCPI.total_payment_sum, 0) AS "PaymentLoanClientTotal",
            CASE
              WHEN LC.repayment_date IS NULL
              THEN COALESCE(LC.debt_base, 0) + COALESCE(LC.debt_percent, 0) + COALESCE(LC.debt_penalty, 0) + COALESCE(LC.debt_tax, 0)
              ELSE COALESCE(LC.repayment_sum, 0)
            END AS "LoanClientDebtTotal",
            CASE
              WHEN LC.repayment_date IS NULL
              THEN GREATEST(COALESCE(LC.debt_base, 0) + COALESCE(LC.debt_percent, 0) + COALESCE(LC.debt_penalty, 0) + COALESCE(LC.debt_tax, 0) - COALESCE(LCPI.total_payment_sum, 0), 0)
              ELSE GREATEST(COALESCE(LC.repayment_sum, 0) - COALESCE(LCPI.total_payment_sum, 0), 0)
            END AS "LoanClientDebtTotalRest"
          FROM
            collect.loan L
            LEFT JOIN collect.loan_client LC USING(loan_id)
            LEFT JOIN collect.loan_client_collection LCC USING(loan_client_id)
            LEFT JOIN collect.loan_client_succession LCS USING(loan_client_id)
            LEFT JOIN collect.loan_client_executive LCE USING(loan_client_collection_id)
            LEFT JOIN collect.client_bankrupt_last(ARRAY[NULL]::bigint[]) USING(client_id)
            LEFT JOIN collect.client_bankrupt CB USING(client_bankrupt_id)
            LEFT JOIN collect.loan_post LP USING(loan_client_id)
            LEFT JOIN collect.loan_post_file LPF USING(loan_post_id)
            LEFT JOIN public.file F USING(file_id)
            LEFT JOIN collect.status S USING(status_id)
            LEFT JOIN loan_client_payment_info LCPI USING(loan_client_id)
            LEFT JOIN collect.client_person CP USING(client_id)
            LEFT JOIN collect.client_phone CPP USING(client_id)
            LEFT JOIN collect.client C USING(client_id)
          WHERE
            NOT L.archive AND
            NOT L.deleted AND
            NOT C.archive AND
            NOT C.deleted
        ), grouped_filtered_data AS (
          SELECT
            loan_id,
            client_id
          FROM
            filtered_query FQ
          WHERE
            <![CDATA[<WherePartOfQuery>]]> --подставляется в кастомке
          GROUP BY loan_id, client_id
          ORDER BY loan_id, client_id
        )
        SELECT
          array_agg(loan_id) AS "LoanId",
          array_agg(client_id) AS "ClientId"
        FROM
          grouped_filtered_data;
      </FilteredSqlQuery>
      <CheckExistsTaskSqlQuery>
        WITH task_loan AS (
          SELECT
            T.task_id,
            TL.task_loan_id,
            LC.loan_id,
            LC.client_id
          FROM (
            SELECT
              unnest({LoanIds}::bigint[]) AS loan_id,
              unnest({ClientIds}::bigint[]) AS client_id
            ) LC
            LEFT JOIN collect.task T ON (autotask_filter_id = {AutotaskFilterId})
            LEFT JOIN collect.task_loan TL ON (LC.loan_id = TL.loan_id AND LC.client_id = TL.client_id AND T.task_id = TL.task_id)
        )
        SELECT
          T.task_id AS "TaskId",
          T.execution_date AS "ExecutionDate",
          T.close_date AS "CloseDate",
          T.task_status_id AS "TaskStatusId",
          T.description AS "Description",
          array_agg(TL.task_loan_id) AS "TaskLoanId",
          array_agg(TL.client_id) AS "ClientId",
          array_agg(TL.loan_id) AS "LoanId"
        FROM
          collect.task T
          LEFT JOIN task_loan TL USING(task_id)
        WHERE
          T.autotask_filter_id = {AutotaskFilterId}
        GROUP BY
          T.task_id;
      </CheckExistsTaskSqlQuery>
      <DeleteNotActualTaskLoanSqlQuery>
        SELECT
          collect.autotask_delete_not_actual({AutotaskFilterId}::bigint, {LoanIds}::bigint[], {ClientIds}::bigint[]);
      </DeleteNotActualTaskLoanSqlQuery>
      <DeleteNotActualTaskSqlQuery>
        DELETE FROM
          collect.task_loan
        WHERE
          task_id = (SELECT task_id FROM collect.task WHERE autotask_filter_id = {AutotaskFilterId});

        DELETE FROM
          collect.task_comment
        WHERE
          task_id = (SELECT task_id FROM collect.task WHERE autotask_filter_id = {AutotaskFilterId});

        DELETE FROM
          collect.task_responsible_user
        WHERE
          task_id = (SELECT task_id FROM collect.task WHERE autotask_filter_id = {AutotaskFilterId});

        DELETE FROM
          collect.task
        WHERE
          task_id = (SELECT task_id FROM collect.task WHERE autotask_filter_id = {AutotaskFilterId});
      </DeleteNotActualTaskSqlQuery>
      <InsertTasksSqlQuery>
         -- из кастомки при выполнении без установки параметров падает ошибка, так как при вызове значения данного параметра возвращается пустая строка
         -- временно пока не поправят баг в платформе
        SELECT
          set_config('ws.user_id', (UI.user_id)::character varying, false)
        FROM
          collect.user_info UI
        WHERE
          user_name = 'СИСТЕМА';
        SELECT set_config('ws.server_time_zone', ('UTC')::varchar, false);

        SELECT
          collect.task_save({Model}::json, UI.user_id)
        FROM
          collect.user_info UI
        WHERE
          user_name = 'СИСТЕМА';
      </InsertTasksSqlQuery>
      <SetActaullyStatusSqlQuery>
        WITH loan_count_by_task AS (
          SELECT
            T.task_id,
            count(TL.task_loan_id) AS task_loan_count
          FROM
            collect.task T
            LEFT JOIN collect.task_loan TL USING (task_id)
          WHERE
            T.autotask_filter_id IS NOT NULL
          GROUP BY
            T.task_id
        )
        UPDATE
          collect.task T
        SET
          execution_date = CASE
            WHEN LCT.task_loan_count = 0 THEN now()::timestamp
            WHEN LCT.task_loan_count > 0 THEN null::timestamp
          END,
          task_status_id = CASE
            WHEN LCT.task_loan_count = 0 THEN TS_E.task_status_id
            WHEN LCT.task_loan_count > 0 THEN TS_IW.task_status_id
          END
        FROM
          loan_count_by_task LCT
          LEFT JOIN collect.task_status TS_E ON (TS_E.name = 'executed')
          LEFT JOIN collect.task_status TS_IW ON (TS_IW.name = 'in_work')
        WHERE
          LCT.task_id = T.task_id;
      </SetActaullyStatusSqlQuery>
      <ResponsibleUsersSqlQuery>
        WITH loan_client_by_filter AS (
          SELECT
            unnest({LoanIds}) AS loan_id,
            unnest({ClientIds}) AS client_id
        ), autotask_filter AS (
          SELECT
            UI.user_id AS autotask_filter_user_ids,
            responsible_for_loan,
            lead_specialist_responsible_for_loan
          FROM
            collect.autotask_filter
            LEFT JOIN (
              SELECT
                autotask_filter_id,
                array_agg(user_id) AS user_id
              FROM
                collect.autotask_filter_responsible_user
              GROUP BY
                autotask_filter_id
            ) UI USING(autotask_filter_id)
          WHERE
            autotask_filter_id = {AutotaskFilterId}
        ), responsible_user_for_loan AS (
          SELECT
            user_id
          FROM
            loan_client_by_filter LCBF
            JOIN collect.loan_client LC ON(LCBF.loan_id = LC.loan_id AND LCBF.client_id = LC.client_id)
            JOIN autotask_filter ON true
          WHERE
            autotask_filter.responsible_for_loan OR
            autotask_filter.lead_specialist_responsible_for_loan
        ), lead_specialist_responsible_for_loan AS (
          SELECT
            parent_user_id AS user_id
          FROM
            collect.user_user
            JOIN responsible_user_for_loan RUFL ON (RUFL.user_id = child_user_id)
            JOIN autotask_filter ON true
          WHERE
            autotask_filter.lead_specialist_responsible_for_loan
        )

        SELECT
          array_agg(user_id) AS "ResponsibleUserId"
        FROM
          (
            SELECT
              unnest(autotask_filter_user_ids) AS user_id
            FROM
              autotask_filter

            UNION

            SELECT
              user_id
            FROM
              responsible_user_for_loan
              JOIN autotask_filter ON true
            WHERE
              autotask_filter.responsible_for_loan

            UNION

            SELECT
              user_id
            FROM
              lead_specialist_responsible_for_loan
          ) T;
      </ResponsibleUsersSqlQuery>
    </Command>

    <!--Отправление сообщений через Email-->
    <Command Name="SendEmailMailingCommand" Type="SendEmailMailingCommand" Assembly="CollectEngine">
      <SelectMailingSqlQuery>
        WITH _settings AS (
          SELECT
            module_email_enabled,
            module_email_available
          FROM
            collect.settings
          LIMIT 1
        ), _mailing_data AS (
          SELECT
            LCME.loan_client_mailing_email_id,
            LCME.loan_client_id,
            ME.subject,
            LCME.mailing_email_id,
            LCME.email_client,
            U.user_full_name,
            author_id
          FROM
            collect.loan_client_mailing_email LCME
            LEFT JOIN collect.mailing_email ME USING (mailing_email_id)
            LEFT JOIN collect.mailing M USING (mailing_id)
            LEFT JOIN collect.user_info U ON M.author_id = U.user_id
            CROSS JOIN _settings S
          WHERE
            LCME.sent ISNULL AND
            U.list_email AND
            S.module_email_enabled AND S.module_email_available AND
            now()::timestamp>=COALESCE(M.send_date, now()::timestamp) AND
            NOT M.download_date ISNULL
        ), _path_files AS (
          SELECT
            ME.mailing_email_id,
            array_agg(replace(path, '\\','\')) AS files
          FROM
            collect.mailing_email ME
            JOIN (SELECT DISTINCT mailing_email_id FROM collect.loan_client_mailing_email) D USING (mailing_email_id)
            JOIN (SELECT mailing_id, mailing_email_id, file_id, template_id FROM collect.mailing_email_file LEFT JOIN collect.mailing_email USING (mailing_email_id) ) MEF ON 
              ME.mailing_email_id = MEF.mailing_email_id OR (ME.mailing_id = MEF.mailing_id AND template_id ISNULL)					
            LEFT JOIN public.file USING (file_id)
          WHERE
            ME.mailing_email_id IN (SELECT DISTINCT mailing_email_id FROM _mailing_data)
          GROUP BY ME.mailing_email_id
        ), _loan_client_titles AS (
          SELECT
            loan_client_id,
            'Дело №'||credit_number||', должник - '|| collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS loan_client_title
          FROM
            collect.loan_client
            LEFT JOIN collect.loan USING (loan_id)
            LEFT JOIN collect.client_person CP USING (client_id)
          WHERE
            loan_client_id IN (SELECT DISTINCT loan_client_id FROM _mailing_data)
        ), _message AS (
          SELECT
            message,
            loan_client_mailing_email_id
          FROM
            collect.get_message_with_replaced_variables((SELECT array_agg(loan_client_mailing_email_id)::bigint[] FROM _mailing_data)::bigint[])
        )
        SELECT
          UES.smtp_server_address AS "AuthorSmtpServerAddress",
          UES.smtp_server_port AS "AuthorSmtpServerPort",
          UES.email_sender AS "AuthorEmailAddress",
          UES.email_password AS "AuthorEmailPassword",
          UES.email_sender_name AS "AuthorName",
          UES.email_signature AS "Signature",
          MD.subject AS "Subject",
          M.message AS "Text",
          null AS "InlineFiles",
          F.files AS "Files",
          MD.loan_client_mailing_email_id AS "Id",
          MD.email_client AS "Email",
          MD.user_full_name AS "AuthorIDWord",
          LCT.loan_client_title AS "IDWord"
        FROM
          _mailing_data MD
          LEFT JOIN _path_files F USING (mailing_email_id)
          LEFT JOIN _loan_client_titles LCT USING (loan_client_id)
          LEFT JOIN collect.user_email_settings UES ON UES.user_id = author_id
          LEFT JOIN _message M USING (loan_client_mailing_email_id);
      </SelectMailingSqlQuery>
      <UpdateMailingSqlQuery>
        WITH send_tbl_result AS (
          SELECT
            unnest({SentResultList}::boolean[]) AS is_sent,
            unnest({IdList}::bigint[]) AS loan_client_mailing_email_id
        ), sender_info AS (
          SELECT
            DISTINCT mailing_email_id,
            UES.email_sender
          FROM
            send_tbl_result
            LEFT JOIN collect.loan_client_mailing_email USING (loan_client_mailing_email_id)
            LEFT JOIN collect.mailing_email USING (mailing_email_id)
            LEFT JOIN collect.mailing USING (mailing_id)
            LEFT JOIN collect.user_email_settings UES ON user_id = author_id
          WHERE
            is_sent
        )

        UPDATE
          collect.mailing_email ME
        SET
          email_sender = SI.email_sender
        FROM
          sender_info SI
        WHERE
          SI.mailing_email_id = ME.mailing_email_id;

        WITH send_tbl_result AS (
          SELECT
            unnest({SentResultList}::boolean[]) AS is_sent,
            unnest({IdList}::bigint[]) AS loan_client_mailing_email_id,
            unnest({MessageTextList}::varchar[]) AS text
        )
        UPDATE
          collect.loan_client_mailing_email LCME
        SET
          sent = is_sent,
          message_text = CASE WHEN is_sent THEN text ELSE NULL END
        FROM
          send_tbl_result STR
        WHERE
          STR.loan_client_mailing_email_id = LCME.loan_client_mailing_email_id;

        WITH send_tbl_result AS (
          SELECT
            unnest({SentResultList}::boolean[]) AS is_sent,
            unnest({IdList}::bigint[]) AS loan_client_mailing_email_id),
        send_with_mailing_tbl_result AS (
          SELECT
            bool_or(is_sent) AS some_sent,
            mailing_id
          FROM
            send_tbl_result
            LEFT JOIN collect.loan_client_mailing_email USING (loan_client_mailing_email_id)
            LEFT JOIN collect.mailing_email USING (mailing_email_id)
          GROUP BY mailing_id)

        UPDATE
          collect.mailing M
        SET
          send_date = now()::timestamp
        FROM
          send_with_mailing_tbl_result R
        WHERE
          M.mailing_id = R.mailing_id AND
          R.some_sent;
      </UpdateMailingSqlQuery>
      <ErrorReturnModeIsOn>False</ErrorReturnModeIsOn>
    </Command>

    <Command Name="SendEmailMailingNowCommand" Type="SendEmailMailingCommand" Assembly="CollectEngine">
      <SelectMailingSqlQuery>
        WITH _settings AS (
          SELECT
            module_email_enabled,
            module_email_available
          FROM
            collect.settings
          LIMIT 1
        ), _mailing_data AS (
          SELECT
            LCME.loan_client_mailing_email_id,
            LCME.loan_client_id,
            ME.subject,
            LCME.mailing_email_id,
            LCME.email_client,
            U.user_full_name,
            author_id
          FROM
            collect.loan_client_mailing_email LCME
            LEFT JOIN collect.mailing_email ME USING (mailing_email_id)
            LEFT JOIN collect.mailing M USING (mailing_id)
            LEFT JOIN collect.user_info U ON M.author_id = U.user_id
            CROSS JOIN _settings S
          WHERE
            U.list_email AND
            S.module_email_enabled AND S.module_email_available AND
            M.send_date ISNULL AND
            COALESCE(ME.mailing_email_id = ANY({MailingEmailIds}::bigint[]), ME.mailing_id = ANY({MailingIds}::bigint[]))
        ), _path_files AS (
          SELECT
            ME.mailing_email_id,
            array_agg(replace(path, '\\','\')) AS files
          FROM
            collect.mailing_email ME
            JOIN (SELECT DISTINCT mailing_email_id FROM collect.loan_client_mailing_email) D USING (mailing_email_id)
            JOIN (SELECT mailing_id, mailing_email_id, file_id, template_id FROM collect.mailing_email_file LEFT JOIN collect.mailing_email USING (mailing_email_id) ) MEF ON 
              ME.mailing_email_id = MEF.mailing_email_id OR (ME.mailing_id = MEF.mailing_id AND template_id ISNULL)					
            LEFT JOIN public.file USING (file_id)
          WHERE
            ME.mailing_email_id IN (SELECT DISTINCT mailing_email_id FROM _mailing_data)
          GROUP BY ME.mailing_email_id
        ), _loan_client_titles AS (
          SELECT
            loan_client_id,
            'Дело №'||credit_number||', должник - '||
              collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS loan_client_title
          FROM
            collect.loan_client
            LEFT JOIN collect.loan USING (loan_id)
            LEFT JOIN collect.client_person CP USING (client_id)
          WHERE
            loan_client_id IN (SELECT DISTINCT loan_client_id FROM _mailing_data)
        ), _message AS (
          SELECT
            message,
            loan_client_mailing_email_id
          FROM
            collect.get_message_with_replaced_variables((SELECT array_agg(loan_client_mailing_email_id)::bigint[] FROM _mailing_data)::bigint[])
        )
        SELECT
          UES.smtp_server_address AS "AuthorSmtpServerAddress",
          UES.smtp_server_port AS "AuthorSmtpServerPort",
          UES.email_sender AS "AuthorEmailAddress",
          UES.email_password AS "AuthorEmailPassword",
          UES.email_sender_name AS "AuthorName",
          UES.email_signature AS "Signature",
          MD.subject AS "Subject",
          M.message AS "Text",
          null AS "InlineFiles",
          F.files AS "Files",
          MD.loan_client_mailing_email_id AS "Id",
          MD.email_client AS "Email",
          MD.user_full_name AS "AuthorIDWord",
          LCT.loan_client_title AS "IDWord"
        FROM
          _mailing_data MD
          LEFT JOIN _path_files F USING (mailing_email_id)
          LEFT JOIN _loan_client_titles LCT USING (loan_client_id)
          LEFT JOIN collect.user_email_settings UES ON UES.user_id = author_id
          LEFT JOIN _message M USING (loan_client_mailing_email_id);
      </SelectMailingSqlQuery>
      <UpdateMailingSqlQuery>
        WITH send_tbl_result AS (
          SELECT
            unnest({SentResultList}::boolean[]) AS is_sent,
            unnest({IdList}::bigint[]) AS loan_client_mailing_email_id
        ), sender_info AS (
          SELECT
            DISTINCT mailing_email_id,
            UES.email_sender
          FROM
            send_tbl_result
            LEFT JOIN collect.loan_client_mailing_email USING (loan_client_mailing_email_id)
            LEFT JOIN collect.mailing_email USING (mailing_email_id)
            LEFT JOIN collect.mailing USING (mailing_id)
            LEFT JOIN collect.user_email_settings UES ON user_id = {UserId}
          WHERE
            is_sent
        )

        UPDATE
          collect.mailing_email ME
        SET
          email_sender = SI.email_sender
        FROM
          sender_info SI
        WHERE
          SI.mailing_email_id = ME.mailing_email_id;

        WITH send_tbl_result AS (
          SELECT
            unnest({SentResultList}::boolean[]) AS is_sent,
            unnest({IdList}::bigint[]) AS loan_client_mailing_email_id,
            unnest({MessageTextList}::varchar[]) AS text
        )

        UPDATE
          collect.loan_client_mailing_email LCME
        SET
          sent = is_sent,
          message_text = CASE WHEN is_sent THEN text ELSE NULL END
        FROM
          send_tbl_result STR
        WHERE
          STR.loan_client_mailing_email_id = LCME.loan_client_mailing_email_id;

        WITH send_tbl_result AS (
          SELECT
            unnest({SentResultList}::boolean[]) AS is_sent,
            unnest({IdList}::bigint[]) AS loan_client_mailing_email_id),
        send_with_mailing_tbl_result AS (
          SELECT
            bool_or(is_sent) AS some_sent,
            mailing_id
          FROM
            send_tbl_result
            LEFT JOIN collect.loan_client_mailing_email USING (loan_client_mailing_email_id)
            LEFT JOIN collect.mailing_email USING (mailing_email_id)
          GROUP BY mailing_id)

        UPDATE
          collect.mailing M
        SET
          send_date = now()::timestamp
        FROM
          send_with_mailing_tbl_result R
        WHERE
          M.mailing_id = R.mailing_id AND
          R.some_sent;
      </UpdateMailingSqlQuery>
      <ErrorReturnModeIsOn>True</ErrorReturnModeIsOn>
    </Command>

    <!-- PochtaRU -->
    <Command Name="PochtaRuRefreshCommand" Type="PochtaRuApiCallCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallRefreshSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuDataNormalizeAddressCommand" Type="PochtaRuApiCallCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallHistoryNormalizeAddressesForOrdersSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuDataCalculateRateCommand" Type="PochtaRuApiCallCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallHistoryCalculateRateForOrdersSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuOrderCreateCommand" Type="PochtaRuApiCallCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallCreateOrderSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuOrderEditCommand" Type="PochtaRuApiCallCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallEditOrderSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuOrderSearchByIdCommand" Type="PochtaRuApiCallCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallOrderSearchByIdSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuOrderSearchByBarcodeCommand" Type="PochtaRuApiCallCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallOrderSearchByBarcodeSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuBatchCheckOrdersCommand" Type="PochtaRuApiCallCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallBatchCheckOrdersSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuBatchCheckAllCommand" Type="PochtaRuApiCallCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallBatchCheckAllSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuOrderDeleteCommand" Type="PochtaRuApiCallCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallOrderDeleteSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuBatchCreateCommand" Type="PochtaRuApiCallCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallBatchCreateSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuBatchUpdateSendingDateCommand" Type="PochtaRuApiCallCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallBatchUpdateSendingDateSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuOrderMoveToBatchCommand" Type="PochtaRuApiCallRepeatingCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallOrderMoveToBatchSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
      <ApiCallHistorySubsequentSelectSqlQuery Name="PochtaRuApiCallHistorySubsequentSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuOrderMoveBackToBacklogCommand" Type="PochtaRuApiCallRepeatingCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallOrderMoveBackToBacklogSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
      <ApiCallHistorySubsequentSelectSqlQuery Name="PochtaRuApiCallHistorySubsequentSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuBatchArchiveCommand" Type="PochtaRuApiCallCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallBatchArchiveSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuBatchArchiveRevertCommand" Type="PochtaRuApiCallCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallBatchArchiveRevertSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuBatchDownloadDocumentsCommand" Type="PochtaRuDownloadFileCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallBatchDownloadDocumentsSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuOrderBacklogDownloadDocumentsCommand" Type="PochtaRuDownloadFileCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallOrderBacklogDownloadDocumentsSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <Command Name="PochtaRuBatchDocumentsCheckInCommand" Type="PochtaRuApiCallCommand" Assembly="PochtaRuAPI">
      <SettingsSelectSqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery" />
      <ApiCallHistoryInsertSqlQuery Name="PochtaRuApiCallBatchDocumentsCheckInSelectSqlQuery" />
      <ApiCallHistorySelectSqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery" />
      <ApiCallHistoryUpdateSqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery" />
      <ApiCallHistoryAfterUpdateSqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery" />
      <ErrorMessageSelectSqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery" />
    </Command>

    <!-- BKI -->
    <Command Name="BkiNeedForExportSqlQueryCommand" Type="SqlQueryCommand">
      <SqlQuery>
        <Text>
          WITH unclosed_loan_client AS (
            SELECT loan_client_id
            FROM collect.loan_client
              JOIN collect.status USING (status_id)
            WHERE NOT is_finish_status AND NOT is_sold_status
          ), last_export_date AS (
            SELECT
              loan_client_id,
              MAX(export_date) AS date
            FROM 
              unclosed_loan_client
              JOIN collect.bki_export_detail BED USING (loan_client_id)
              JOIN collect.bki_export USING (bki_export_id)
              JOIN collect.bki_type BT USING (bki_type_id)
            WHERE BT.name = {BkiType} AND BED.is_accepted
            GROUP BY loan_client_id
          )
          UPDATE collect.loan_client LC
          SET 
            is_nbki_exported = CASE WHEN {BkiType} = 'nbki' THEN false ELSE LC.is_nbki_exported END,
            is_equifax_exported = CASE WHEN {BkiType} = 'equifax' THEN false ELSE LC.is_equifax_exported END,
            is_okb_exported = CASE WHEN {BkiType} = 'okb' THEN false ELSE LC.is_okb_exported END
          FROM last_export_date LED
          WHERE 
            LED.loan_client_id = LC.loan_client_id AND 
            (NOW()::date - LED.date::date) > 30;
        </Text>
      </SqlQuery>
    </Command>

    <!-- Проверка в debex -->
    <Command Name="DebexCheckingCommand" Type="DebexCheckingCommand" Assembly="CollectEngine">
      <DataSqlQuery>
        <Text>
          SELECT
            C.client_id AS "ClientId",
            first_name AS "Surname",
            second_name AS "FirstName",
            third_name AS "Patronymic",
            to_char(birth_date, 'dd.MM.yyyy') AS "BirthDate",
            GAS.address_string AS "Address",
            {CheckType} AS "CheckType"
          FROM
            collect.client C
            LEFT JOIN collect.client_person USING(client_id)
            LEFT JOIN collect.client_address CA USING(client_id)
            LEFT JOIN collect.address_type AT USING(address_type_id)
            LEFT JOIN collect.get_address_string(CA.address_id) GAS USING(address_id)
          WHERE
            C.client_id = ANY({ClientIds}::bigint[]) AND
            AT.title = 'Регистрация';
        </Text>
      </DataSqlQuery>
      <DataSaveSqlQuery>
        SELECT collect.debex_checking_result_save({ClientId}::bigint, {CheckType}::character varying, {Model}::json, {DebexUserId}::smallint);
      </DataSaveSqlQuery>
      <SettingsSqlQuery>
        <Text>
          SELECT
            module_debex_token AS "DebexToken",
            module_debex_jurisdiction_available AND module_debex_jurisdiction_enabled AND debex_jurisdiction_check AS "ModuleDebexJurisdictionPermission",
            module_debex_fssp_available AND module_debex_fssp_enabled AND debex_fssp_check AS "ModuleDebexFsspPermission",
            module_debex_bankrupt_available AND module_debex_bankrupt_enabled AND debex_bankrupt_check AS "ModuleDebexBankruptPermission"
          FROM
            collect.user_info
            LEFT JOIN collect.settings ON true
          WHERE
            user_id = {UserId};
        </Text>
      </SettingsSqlQuery>
    </Command>
    <!--============================================================-->
    <!--====================SMS CENTRE ENGINE=======================-->
    <!--============================================================-->
    <Command Name="SMSGetBalanceCommand" Type="GetBalanceCommand" Assembly="SMSCenterEngine">
      <NormalizePhones Type="None" />
      <UserSqlQuery>
        <Text>
          SELECT user_name AS "UserName"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </UserSqlQuery>
      <PasswordSqlQuery>
        <Text>
          SELECT password AS "Password"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </PasswordSqlQuery>
    </Command>

    <Command Name="SMSTryGetBalanceCommand" Type="GetBalanceCommand" Assembly="SMSCenterEngine">
      <NormalizePhones Type="None" />
      <UserSqlQuery>
        <Text>
          SELECT {SMSUserName} AS "UserName";
        </Text>
      </UserSqlQuery>
      <PasswordSqlQuery>
        <Text>
          SELECT {SMSPassword} AS "Password";
        </Text>
      </PasswordSqlQuery>
    </Command>

    <Command Name="SMSGetStatusCommand" Type="GetStatusCommand" Assembly="SMSCenterEngine">
      <NormalizePhones Type="None" />
      <UserSqlQuery>
        <Text>
          SELECT user_name AS "UserName"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </UserSqlQuery>
      <PasswordSqlQuery>
        <Text>
          SELECT password AS "Password"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </PasswordSqlQuery>
      <Background Value="True" />
      <PhonesSqlQuery>
        <Text>
          SELECT
            SMM.sms_mailing_message_id AS "Id",
            SMM.phone AS "Phone",
            SMM.message_id AS "MessageId"
          FROM collect.sms_mailing_message SMM
          WHERE
            message_mailing_id = ANY ({MessageMailingIds}::int[]) AND
            sms_status_id IN (-2, -1 , 0);
        </Text>
      </PhonesSqlQuery>
      <PostSqlQuery>
        <Text>
          UPDATE collect.sms_mailing_message
          SET sms_status_id = {SMSStatusId}
          WHERE sms_mailing_message_id = {Id};
        </Text>
      </PostSqlQuery>
    </Command>

    <Command Name="SMSGetStatusByTaskCommand" Type="GetStatusCommand" Assembly="SMSCenterEngine">
      <NormalizePhones Type="None" />
      <UserSqlQuery>
        <Text>
          SELECT user_name AS "UserName"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </UserSqlQuery>
      <PasswordSqlQuery>
        <Text>
          SELECT password AS "Password"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </PasswordSqlQuery>
      <Background Value="True" />
      <PhonesSqlQuery>
        <Text>
          SELECT
            SMM.sms_mailing_message_id AS "Id",
            SMM.phone AS "Phone",
            SMM.message_id AS "MessageId"
          FROM collect.sms_mailing_message SMM
          WHERE sms_status_id IN (-2, -1 , 0)
          LIMIT 10;
        </Text>
      </PhonesSqlQuery>
      <PostSqlQuery>
        <Text>
          UPDATE collect.sms_mailing_message
          SET sms_status_id = {SMSStatusId}
          WHERE sms_mailing_message_id = {Id};
        </Text>
      </PostSqlQuery>
    </Command>

    <Command Name="SMSTemplateGetCostCommand" Type="GetCostCommand" Assembly="SMSCenterEngine">
      <NormalizePhones Type="None" />
      <UserSqlQuery>
        <Text>
          SELECT user_name AS "UserName"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </UserSqlQuery>
      <PasswordSqlQuery>
        <Text>
          SELECT password AS "Password"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </PasswordSqlQuery>
      <Approximately Value="True" />
      <PhonesSqlQuery>
        <Text>
          SELECT
            NULL AS "Id",
            first_name || COALESCE(' ' || second_name, '') || COALESCE(' ' || third_name, '') AS "Title",
            CPh.phone_number AS "Phone"
          FROM 
            collect.client_person CP
            JOIN collect.client_phone CPh USING(client_id)
          WHERE is_main
          ORDER BY "Title" ASC
          LIMIT 1;
        </Text>
      </PhonesSqlQuery>
      <Variables>
        <Variable Name="Title" Value="[Должник]" />
      </Variables>
      <CommonTextSqlQuery>
        <Text>
          SELECT {MessageTemplateText} AS "Text";
        </Text>
      </CommonTextSqlQuery>
    </Command>

    <Command Name="SMSClientGetCostCommand" Type="GetCostCommand" Assembly="SMSCenterEngine">
      <NormalizePhones Type="None" />
      <UserSqlQuery>
        <Text>
          SELECT user_name AS "UserName"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </UserSqlQuery>
      <PasswordSqlQuery>
        <Text>
          SELECT password AS "Password"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </PasswordSqlQuery>
      <Approximately Value="True" />
      <PhonesSqlQuery>
        <Text>
          SELECT
            NULL AS "Id",
            {ClientTitle} AS "Title",
            to_char(CP.birth_date, 'dd.MM.yyyy') AS "Birthday",
            {Phone} AS "Phone",
            CP.email AS "Email"
          FROM 
            collect.client_person CP
          WHERE CP.client_id = {ClientId};
        </Text>
      </PhonesSqlQuery>
      <Variables>
        <Variable Name="Title" Value="[Должник]" />
        <Variable Name="Birthday" Value="[ДатаРождения]" />
      </Variables>
      <CommonTextSqlQuery>
        <Text>
          SELECT {MessageTemplateText} AS "Text";
        </Text>
      </CommonTextSqlQuery>
    </Command>

    <Command Name="SMSClientSendCommand" Type="SendCommand" Assembly="SMSCenterEngine">
      <NormalizePhones Type="None" />
      <UserSqlQuery>
        <Text>
          SELECT user_name AS "UserName"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </UserSqlQuery>
      <PasswordSqlQuery>
        <Text>
          SELECT password AS "Password"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </PasswordSqlQuery>
      <Background Value="True" />
      <PhonesSqlQuery>
        <Text>
          SELECT
            SMM.sms_mailing_message_id AS "Id",
            SMM.phone AS "Phone",
            SMM.client_title AS "Title",
            to_char(CP.birth_date, 'dd.MM.yyyy') AS "Birthday",
            CP.email AS "Email"
          FROM
            collect.sms_mailing_message SMM
            JOIN collect.client_person CP USING(client_id)
          WHERE SMM.message_mailing_id = {MessageMailingId};
        </Text>
      </PhonesSqlQuery>
      <Variables>
        <Variable Name="Title" Value="[Должник]" />
        <Variable Name="Birthday" Value="[ДатаРождения]" />
      </Variables>
      <CommonTextSqlQuery>
        <Text>
          SELECT message_template_text AS "Text"
          FROM collect.message_mailing
          WHERE message_mailing_id = {MessageMailingId};
        </Text>
      </CommonTextSqlQuery>
      <PostSqlQuery>
        <Text>
          UPDATE collect.message_mailing
          SET
            date_sending = GREATEST(date_sending, NOW()),
            date_sending_to_server = NOW()
          WHERE message_mailing_id = {MessageMailingId};
          
          UPDATE collect.sms_mailing_message
          SET
            message_id = {MessageId},
            message_text = {Text},
            cost = {Cost},
            sms_status_id = -2
          WHERE sms_mailing_message_id = {Id};
        </Text>
      </PostSqlQuery>
      <UpdateStatusSqlQuery>
        <Text>
          UPDATE collect.sms_mailing_message
          SET sms_status_id = {SMSStatusId}::smallint
          WHERE sms_mailing_message_id = {Id};
        </Text>
      </UpdateStatusSqlQuery>
    </Command>

    <Command Name="SMSLoanClientGetCostCommand" Type="GetCostCommand" Assembly="SMSCenterEngine">
      <NormalizePhones Type="None" />
      <UserSqlQuery>
        <Text>
          SELECT user_name AS "UserName"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </UserSqlQuery>
      <PasswordSqlQuery>
        <Text>
          SELECT password AS "Password"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </PasswordSqlQuery>
      <Approximately Value="True" />
      <PhonesSqlQuery>
        <Text>
          SELECT
            NULL AS "Id",
            {Phone} AS "Phone",
            {ClientTitle} AS "Title",
            {CreditNumber} AS "CreditNumber",
            {CreditDateStart} AS "CreditDateStart",
            {CreditDateEnd} AS "CreditDateEnd";
        </Text>
      </PhonesSqlQuery>
      <Variables>
        <Variable Name="Title" Value="[Должник]" />
        <Variable Name="CreditNumber" Value="[НомерКД]" />
        <Variable Name="CreditDateStart" Value="[ДатаКД]" />
        <Variable Name="CreditDateEnd" Value="[ДатаОкончанияКД]" />
      </Variables>
      <CommonTextSqlQuery>
        <Text>
          SELECT {MessageTemplateText} AS "Text";
        </Text>
      </CommonTextSqlQuery>
    </Command>

    <Command Name="SMSLoanClientSendCommand" Type="SendCommand" Assembly="SMSCenterEngine">
      <NormalizePhones Type="None" />
      <UserSqlQuery>
        <Text>
          SELECT user_name AS "UserName"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </UserSqlQuery>
      <PasswordSqlQuery>
        <Text>
          SELECT password AS "Password"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </PasswordSqlQuery>
      <PhonesSqlQuery>
        <Text>
          SELECT
            SMM.sms_mailing_message_id AS "Id",
            SMM.phone AS "Phone",
            SMM.client_title AS "Title",
            {CreditNumber} AS "CreditNumber",
            {CreditDateStart} AS "CreditDateStart",
            {CreditDateEnd} AS "CreditDateEnd"
          FROM collect.sms_mailing_message SMM
          WHERE message_mailing_id = {MessageMailingId};
        </Text>
      </PhonesSqlQuery>
      <Background Value="True" />
      <Variables>
        <Variable Name="Title" Value="[Должник]" />
        <Variable Name="CreditNumber" Value="[НомерКД]" />
        <Variable Name="CreditDateStart" Value="[ДатаКД]" />
        <Variable Name="CreditDateEnd" Value="[ДатаОкончанияКД]" />
      </Variables>
      <CommonTextSqlQuery>
        <Text>
          SELECT message_template_text AS "Text"
          FROM collect.message_mailing
          WHERE message_mailing_id = {MessageMailingId};
        </Text>
      </CommonTextSqlQuery>
      <PostSqlQuery>
        <Text>
          UPDATE collect.message_mailing
          SET
            date_sending = GREATEST(date_sending, NOW()),
            date_sending_to_server = NOW()
          WHERE message_mailing_id = {MessageMailingId};
          
          UPDATE collect.sms_mailing_message
          SET
            message_id = {MessageId},
            message_text = {Text},
            cost = {Cost},
            sms_status_id = -2
          WHERE sms_mailing_message_id = {Id};
        </Text>
      </PostSqlQuery>
      <UpdateStatusSqlQuery>
        <Text>
          UPDATE collect.sms_mailing_message
          SET sms_status_id = {SMSStatusId}
          WHERE sms_mailing_message_id = {Id};
        </Text>
      </UpdateStatusSqlQuery>
    </Command>

    

    <Command Name="SMSMailingGetCostCommand" Type="GetCostCommand" Assembly="SMSCenterEngine">
      <NormalizePhones Type="None" />
      <UserSqlQuery>
        <Text>
          SELECT user_name AS "UserName"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </UserSqlQuery>
      <PasswordSqlQuery>
        <Text>
          SELECT password AS "Password"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </PasswordSqlQuery>
      <Approximately Value="True" />
      <PhonesSqlQuery>
        <Text>
          SELECT
            ROW_NUMBER() OVER() AS "Id",
            phone AS "Phone",
            client_title AS "Title"
          FROM (SELECT UNNEST({ClientTitles}::varchar[]) as client_title, UNNEST({Phones}::varchar[]) as phone) as t
        </Text>
      </PhonesSqlQuery>
      <Variables>
        <Variable Name="Title" Value="[Должник]" />
      </Variables>
      <CommonTextSqlQuery>
        <Text>
          SELECT {MessageTemplateText} AS "Text";
        </Text>
      </CommonTextSqlQuery>
    </Command>

    <Command Name="SMSMailingSendCommand" Type="SendCommand" Assembly="SMSCenterEngine">
      <NormalizePhones Type="None" />
      <UserSqlQuery>
        <Text>
          SELECT user_name AS "UserName"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </UserSqlQuery>
      <PasswordSqlQuery>
        <Text>
          SELECT password AS "Password"
          FROM collect.sms_settings
          WHERE name = 'SMSCenter';
        </Text>
      </PasswordSqlQuery>
      <Background Value="True" />
      <PhonesSqlQuery>
        <Text>
          SELECT
            SMM.sms_mailing_message_id AS "Id",
            SMM.phone AS "Phone",
            SMM.client_title AS "Title",
            SM.date_sending - Interval '{ServerTimeZoneOffset}h' AS "DateSending"
          FROM
            collect.message_mailing SM
            JOIN collect.sms_mailing_message SMM USING(message_mailing_id)
          WHERE message_mailing_id = {MessageMailingId};
        </Text>
      </PhonesSqlQuery>
      <Variables>
        <Variable Name="Title" Value="[Должник]" />
      </Variables>
      <CommonTextSqlQuery>
        <Text>
          SELECT message_template_text AS "Text"
          FROM collect.message_mailing
          WHERE message_mailing_id = {MessageMailingId};
        </Text>
      </CommonTextSqlQuery>
      <PostSqlQuery>
        <Text>
          UPDATE collect.message_mailing
          SET
            date_sending = GREATEST(date_sending, NOW()),
            date_sending_to_server = NOW()
          WHERE message_mailing_id = {MessageMailingId};
          
          UPDATE collect.sms_mailing_message
          SET
            message_id = {MessageId},
            message_text = {Text},
            cost = {Cost},
            sms_status_id = -2
          WHERE sms_mailing_message_id = {Id};
        </Text>
      </PostSqlQuery>
      <UpdateStatusSqlQuery>
        <Text>
          UPDATE collect.sms_mailing_message
          SET sms_status_id = {SMSStatusId}
          WHERE sms_mailing_message_id = {Id};
        </Text>
      </UpdateStatusSqlQuery>
    </Command>

    <Command Name="SMSMailingBirthdayInsertSqlQueryCommand" Type="SqlQueryCommand">
      <SqlQuery>
        <Text>
          INSERT INTO collect.message_mailing(message_template_id, message_template_text, author_id, special)
          SELECT
            message_template_id,
            text,
            (SELECT user_id FROM collect.user_info WHERE public_user_id = 1),
            False
          FROM collect.message_template
          WHERE name = 'birthday'
          RETURNING message_mailing_id AS "MessageMailingId";

          INSERT INTO collect.sms_mailing_message(message_mailing_id, client_id, client_title, phone, sms_status_id)
          SELECT CURRVAL('collect.message_mailing_id_seq'), client_id, title, contact_phone, -3
          FROM collect.client_birthday_today_view;
        </Text>
      </SqlQuery>
    </Command>

    <Command Name="HappyBirthdaySMSMailingSchedulerConditionRefreshCommand" Type="SchedulerConditionRefreshCommand">
      <Task Name="HappyBirthdaySMSMailing" />
    </Command>
  </Commands>

  <SqlQueries>
    <!--============================================================-->
    <!--===ЧАСОВЫЕ ПОЯСА============================================-->
    <!--============================================================-->
    <SqlQuery Name="TimeZoneInfoSelectSqlQuery">
      <Text>
        SELECT
          time_zone_info_id AS "TimeZoneInfoId",
          title AS "Title",
          by_default AS "ByDefault"
        FROM
          public.time_zone_info;
      </Text>
    </SqlQuery>

    <SqlQuery Name="UserTimeZoneInfoSelectSqlQuery">
      <Text>
        SELECT
          time_zone_info_id AS "TimeZoneInfoId"
        FROM
          public.user
        WHERE
          user_id = {PublicUserId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="UserSettingsUpdateSqlQuery">
      <Text>
        UPDATE
          public.user
        SET
          time_zone_info_id = {TimeZoneInfoId}
        WHERE
          user_id = {PublicUserId};
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===LOAD MODE================================================-->
    <!--============================================================-->
    <SqlQuery Name="LoadModeSelectSqlQuery">
      <Text>
        SELECT
          load_mode_id AS "LoadModeId",
          title AS "Title",
          description AS "Description",
          selected AS "Selected"
        FROM
          public.load_mode;
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===О ПРОГРАММЕ==============================================-->
    <!--============================================================-->
    <SqlQuery Name="AboutSelectSqlQuery">
      <Text>
        SELECT
          update_date AS "UpdateDate",
          version AS "Version",
          version_date AS "VersionDate"
        FROM
          public.about
        ORDER BY about_id DESC LIMIT 1;
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===МОДУЛЬ ПОЧТЫ=============================================-->
    <!--============================================================-->

    <!-- api -->

    <SqlQuery Name="PochtaRuApiCallSettingsSelectSqlQuery">
      <Text>
        SELECT
          module_pochtaru_available AND module_pochtaru_enabled "ApiEnabled",
          module_pochtaru_user_token "UserToken",
          module_pochtaru_user_key "UserKey",
          'pochtaru_api_log' "LogName",
          'pochtaru_api_sql_log' "SqlLogName"
        FROM
          collect.settings;
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallHistorySelectSqlQuery">
      <Text>
        SELECT
          H.api_call_history_id AS "Id",
          H.url AS "Url",
          H.method AS "Method",
          H.request_data AS "RequestData",
          H.extension AS "Extension",
          H.filename AS "FileName"
        FROM
          pochtaru.api_call_history H
        WHERE
          H.api_call_history_id = ANY({ApiCallHistoryIds}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallHistoryUpdateSqlQuery">
      <Text>
        UPDATE
          pochtaru.api_call_history
        SET
          response_data = {ResponseData},
          success = {Success},
          error_code = {ErrorCode},
          error_message = {ErrorMessage},
          guid = {GUID}
        WHERE
          api_call_history_id = {Id};
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallHistoryAfterUpdateSqlQuery">
      <Text>
        --SELECT pochtaru.test_api_debug();
        SELECT pochtaru.api__on_call_executed({Id});
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallErrorMessageSelectSqlQuery">
      <Text>
        SELECT
          COUNT(*) > 0 AS "IsError",
          string_agg(COALESCE(H.error_message, ''), ',') AS "ErrorMessage"
        FROM
          pochtaru.api_call_history H
        WHERE
          H.api_call_history_id = ANY({ApiCallHistoryIds}::bigint[]) AND
          NOT success;
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallHistorySubsequentSelectSqlQuery">
      <Text>
        SELECT
          H.api_call_history_id AS "Id",
          H.url AS "Url",
          H.method AS "Method",
          H.request_data AS "RequestData",
          H.extension AS "Extension",
          H.filename AS "FileName"
        FROM
          pochtaru.api_call_history H
        WHERE
          H.origin_api_call_history_id = ANY({ApiCallHistoryIds}::bigint[]);
      </Text>
    </SqlQuery>

    <!-- call inserts -->
    <SqlQuery Name="PochtaRuApiCallRefreshSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__batch_check_orders((
            SELECT
              array_agg(batch_id)
            FROM
              collect.pochtaru_batch_view
            WHERE
              check_automatically
            )
          )

        UNION

        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__find_batches();
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallHistoryNormalizeAddressesForOrdersSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__normalize_addresses_for_orders({OrderIds}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallHistoryCalculateRateForOrdersSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__calculate_rate_for_orders({OrderIds}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallCreateOrderSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__order_create({OrderIds}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallEditOrderSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__edit_order({OrderId}::bigint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallOrderSearchByIdSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__find_order_by_id({OrderIds}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallOrderSearchByBarcodeSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__batch_find_orders_with_barcode({OrderIds}::bigint[]);        
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallBatchCheckOrdersSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__batch_check_orders({BatchIds}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallBatchCheckAllSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__find_batches();
    </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallOrderDeleteSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__orders_delete({OrderIds}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallBatchCreateSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__batch_create({OrderIds}::bigint[], {SendingDate}::date, {UseOnlineBalance}::boolean);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallBatchUpdateSendingDateSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__batch_update_sending_date({BatchId});
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallOrderMoveToBatchSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__batch_move_orders({BatchId}, {OrderIds}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallOrderMoveBackToBacklogSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__order_move_back_to_backlog({OrderIds}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallBatchDownloadDocumentsSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__download_batch_docs({BatchId}::bigint, {PrintType}::text, {PrintFormType}::text);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallOrderBacklogDownloadDocumentsSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__download_order_docs({OrderId}::bigint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallBatchDocumentsCheckInSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__batch_documents_check_in({BatchId}::bigint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallBatchArchiveSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__batch_archive({BatchIds}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuApiCallBatchArchiveRevertSelectSqlQuery">
      <Text>
        SELECT
          api_call_history_id AS "Id"
        FROM
          pochtaru.apicall__batch_archive_revert({BatchIds}::bigint[]);
      </Text>
    </SqlQuery>

    <!-- app -->

    <SqlQuery Name="PochtaRuOrderSelectSqlQuery">
      <Text>
        WITH orders AS (
          SELECT
            OV.order_id
          FROM
            collect.pochtaru_order_view OV
            JOIN pochtaru.order_view POV USING (order_id)
          WHERE
            loan_client_user_id = {UserId} OR
            collect.is_administrator({UserId}::smallint) AND
            ({Archived} IS NULL OR COALESCE(archived, false) = {Archived})
          ORDER BY order_num
        ), pagination AS (
          SELECT
            count(*) AS total_rows,
            COALESCE(CEIL(count(*)::numeric/GREATEST(COALESCE({RowsPerPage}, count(*))::numeric, 1)), 1) AS total_pages
          FROM
            orders
        ), selected_orders AS (
          SELECT
            row_number() over() AS row_number,
            pagination.total_rows,
            pagination.total_pages,
            order_id
          FROM
            orders
            JOIN pagination ON true
          LIMIT COALESCE({RowsPerPage}, (SELECT total_rows FROM pagination))
          OFFSET (GREATEST((LEAST((SELECT total_pages FROM pagination), COALESCE({CurrentPage}, 1)) - 1)::integer, 0)
            * COALESCE({RowsPerPage}, (SELECT total_rows FROM pagination)))
        )
        SELECT
          S.row_number AS "RowNumber",
          S.total_rows AS "TotalRows",
          S.total_pages AS "TotalPages",

          OV.order_id AS "OrderId",
          OV.loan_post_id AS "LoanPostId",
          OV.loan_client_id AS "LoanClientId",
          OV.loan_id AS "LoanId",
          POV.archived AS "Archived",
          POV.batch_id IS NOT NULL AS "InBatch",

          POV.address_from_id AS "AddressFromId",
          POV.address_to_id AS "AddressToId",

          POV.order_num AS "OrderNum",
          POV.barcode AS "Barcode",
          POV.barcode IS NOT NULL AS "HasBarcode",
          POV.raw_recipient_address AS "FullAddressTo",
          POV.recipient_name AS "RecipientName",

          POV.batch_name AS "BatchName",
          POV.batch_sending_date AS "BatchSendingDate",
          POV.arrival_date::timestamp without time zone AS "ArrivalDate"
        FROM
          selected_orders S
          JOIN collect.pochtaru_order_view OV USING (order_id)
          JOIN pochtaru.order_view POV USING (order_id)
        ORDER BY
          "OrderNum";
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuBatchSelectSqlQuery">
      <Text>
        WITH batches AS (
          SELECT
            DISTINCT batch_id
          FROM
            pochtaru.batch_view BV
            LEFT JOIN pochtaru.order_view POV USING (batch_id)
            LEFT JOIN collect.pochtaru_order_view OV USING (order_id)
          WHERE
            loan_client_user_id = {UserId} OR
            collect.is_administrator({UserId}::smallint) AND
            ({Archived} IS NULL OR COALESCE(BV.archived, false) = {Archived})
        ), pagination AS (
          SELECT
            count(*) AS total_rows,
            COALESCE(CEIL(count(*)::numeric/GREATEST(COALESCE({RowsPerPage}, count(*))::numeric, 1)), 1) AS total_pages
          FROM
            batches
        ), selected_batches AS (
          SELECT
            row_number() over() AS row_number,
            pagination.total_rows,
            pagination.total_pages,
            batch_id
          FROM
            batches
            JOIN pagination ON true
          LIMIT COALESCE({RowsPerPage}, (SELECT total_rows FROM pagination))
          OFFSET (GREATEST((LEAST((SELECT total_pages FROM pagination), COALESCE({CurrentPage}, 1)) - 1)::integer, 0)
            * COALESCE({RowsPerPage}, (SELECT total_rows FROM pagination)))
        )
        SELECT
          S.row_number AS "RowNumber",
          S.total_rows AS "TotalRows",
          S.total_pages AS "TotalPages",

          BV.batch_id AS "BatchId",
          BV.sending_date AS "SendingDate",
          BV.use_online_balance AS "UseOnlineBalance",
          BV.archived AS "Archived",

          BV.accepted_count AS "AcceptedCount",
          BV.batch_name AS "BatchName",
          BV.batch_status AS "BatchStatus",
          BV.batch_status_text AS "BatchStatusText",
          BV.batch_status_date AS "BatchStatusDate",
          BV.bk_hash AS "BkHash",
          BV.branch_name AS "BranchName",
          BV.delivery_count AS "DeliveryCount",
          BV.delivery_notice_payment_method AS "DeliveryNoticePaymentMethod",
          BV.delivery_notice_payment_method_text AS "DeliveryNoticePaymentMethodText",
          BV.document_download_status AS "DocumentDownloadStatus",
          BV.document_download_status_text AS "DocumentDownloadStatusText",
          BV.electronic_f103 AS "ElectronicF103",
          BV.group_name AS "GroupName",
          BV.list_number AS "ListNumber",
          BV.list_number_date AS "ListNumberDate",
          BV.mail_category AS "MailCategory",
          BV.mail_category_text AS "MailCategoryText",
          BV.mail_rank AS "MailRank",
          BV.mail_rank_text AS "MailRankText",
          BV.mail_type AS "MailType",
          BV.mail_type_text AS "MailTypeText",
          BV.notice_payment_method AS "NoticePaymentMethod",
          BV.notice_payment_method_text AS "NoticePaymentMethodText",
          BV.payment_method AS "PaymentMethod",
          BV.payment_method_text AS "PaymentMethodText",
          BV.postoffice_address AS "PostofficeAddress",
          BV.postoffice_code AS "PostofficeCode",
          BV.postoffice_name AS "PostofficeName",
          BV.pre_postal_preparation AS "PrePostalPreparation",
          BV.shipment_mass AS "ShipmentMass",
          BV.shipment_count AS "ShipmentCount",
          BV.shipping_notice_type AS "ShipmentNoticeType",
          BV.shipping_notice_type_text AS "ShipmentNoticeTypeText",
          BV.transport_type AS "TransportType",
          BV.transport_type_text AS "TransportTypeText"
        FROM
          selected_batches S
          JOIN pochtaru.batch_view BV USING (batch_id)
        ORDER BY
          "BatchId";
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuBatchSelectByIdSqlQuery">
      <Text>
        SELECT
          batch_id AS "BatchId",
          sending_date AS "SendingDate",
          use_online_balance AS "UseOnlineBalance",

          accepted_count AS "AcceptedCount",
          batch_name AS "BatchName",
          batch_status AS "BatchStatus",
          batch_status_text AS "BatchStatusText",
          batch_status_date AS "BatchStatusDate",
          bk_hash AS "BkHash",
          branch_name AS "BranchName",
          delivery_count AS "DeliveryCount",
          delivery_notice_payment_method AS "DeliveryNoticePaymentMethod",
          delivery_notice_payment_method_text AS "DeliveryNoticePaymentMethodText",
          document_download_status AS "DocumentDownloadStatus",
          document_download_status_text AS "DocumentDownloadStatusText",
          electronic_f103 AS "ElectronicF103",
          group_name AS "GroupName",
          list_number AS "ListNumber",
          list_number_date AS "ListNumberDate",
          mail_category AS "MailCategory",
          mail_category_text AS "MailCategoryText",
          mail_rank AS "MailRank",
          mail_rank_text AS "MailRankText",
          mail_type AS "MailType",
          mail_type_text AS "MailTypeText",
          notice_payment_method AS "NoticePaymentMethod",
          notice_payment_method_text AS "NoticePaymentMethodText",
          payment_method AS "PaymentMethod",
          payment_method_text AS "PaymentMethodText",
          postoffice_address AS "PostofficeAddress",
          postoffice_code AS "PostofficeCode",
          postoffice_name AS "PostofficeName",
          pre_postal_preparation AS "PrePostalPreparation",
          shipment_mass AS "ShipmentMass",
          shipment_count AS "ShipmentCount",
          shipping_notice_type AS "ShipmentNoticeType",
          shipping_notice_type_text AS "ShipmentNoticeTypeText",
          transport_type AS "TransportType",
          transport_type_text AS "TransportTypeText"
        FROM
          pochtaru.batch_view
        WHERE
          batch_id = {BatchId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuTypeSelectSqlQuery">
      <Text>
        WITH type AS (
          SELECT
            'ADDRESS_TYPE' AS group_id,
            datatype_address_type_id AS id,
            title
          FROM
            pochtaru.datatype_address_type

          UNION SELECT
            'ENTRIES_TYPE' AS group_id,
            datatype_base_entries_type_id AS id,
            title
          FROM
            pochtaru.datatype_base_entries_type

          UNION SELECT
            'ENVELOPE_TYPE' AS group_id,
            datatype_base_envelope_type_id AS id,
            title
          FROM
            pochtaru.datatype_base_envelope_type

          UNION SELECT
            'LAST_OPER_ATTR' AS group_id,
            datatype_base_last_oper_attr_id AS id,
            title
          FROM
            pochtaru.datatype_base_last_oper_attr

          UNION SELECT
            'LAST_OPER_TYPE' AS group_id,
            datatype_base_last_oper_type_id AS id,
            title
          FROM
            pochtaru.datatype_base_last_oper_type

          UNION SELECT
            'MAIL_CATEGORY' AS group_id,
            datatype_base_mail_category_id AS id,
            title
          FROM
            pochtaru.datatype_base_mail_category

          UNION SELECT
            'MAIL_RANK' AS group_id,
            datatype_base_mail_rank_id AS id,
            title
          FROM
            pochtaru.datatype_base_mail_rank

          UNION SELECT
            'MAIL_TYPE' AS group_id,
            datatype_base_mail_type_id AS id,
            title
          FROM
            pochtaru.datatype_base_mail_type

          UNION SELECT
            'NOTIFY_CATEGORY' AS group_id,
            datatype_base_notify_category_id AS id,
            title
          FROM
            pochtaru.datatype_base_notify_category

          UNION SELECT
            'POSTMARK' AS group_id,
            datatype_base_postmark_id AS id,
            title
          FROM
            pochtaru.datatype_base_postmark

          UNION SELECT
            'PRINT_TYPE' AS group_id,
            datatype_base_print_type_id AS id,
            title
          FROM
            pochtaru.datatype_base_print_type

          UNION SELECT
            'TRANSPORT_TYPE' AS group_id,
            datatype_base_transport_type_id AS id,
            title
          FROM
            pochtaru.datatype_base_transport_type

          UNION SELECT
            'BATCH_CATEGORY' AS group_id,
            datatype_batch_category_id AS id,
            title
          FROM
            pochtaru.datatype_batch_category

          UNION SELECT
            'BATCH_ERROR' AS group_id,
            datatype_batch_error_id AS id,
            title
          FROM
            pochtaru.datatype_batch_error

          UNION SELECT
            'BATCH_HYPER_LOCAL_STATUS' AS group_id,
            datatype_batch_hyper_local_status_id AS id,
            title
          FROM
            pochtaru.datatype_batch_hyper_local_status

          UNION SELECT
            'BATCH_STATUS' AS group_id,
            datatype_batch_status_id AS id,
            title
          FROM
            pochtaru.datatype_batch_status

          UNION SELECT
            'CLEAN_ADDRESS_QUALITY' AS group_id,
            datatype_clean_address_quality_id AS id,
            title
          FROM
            pochtaru.datatype_clean_address_quality

          UNION SELECT
            'CLEAN_ADDRESS_VALIDATION' AS group_id,
            datatype_clean_address_validation_id AS id,
            title
          FROM
            pochtaru.datatype_clean_address_validation

          UNION SELECT
            'CLEAN_FIO_PHONE_QUALITY' AS group_id,
            datatype_clean_fio_phone_quality_id AS id,
            title
          FROM
            pochtaru.datatype_clean_fio_phone_quality

          UNION SELECT
            'CLEAN_FIO_QUALITY' AS group_id,
            datatype_clean_fio_quality_id AS id,
            title
          FROM
            pochtaru.datatype_clean_fio_quality

          UNION SELECT
            'COUNTRIES' AS group_id,
            datatype_countries_id AS id,
            title
          FROM
            pochtaru.datatype_countries

          UNION SELECT
            'COURIER_ORDER_STATUS' AS group_id,
            datatype_courier_order_status_id AS id,
            title
          FROM
            pochtaru.datatype_courier_order_status

          UNION SELECT
            'CURRENCIES' AS group_id,
            datatype_currencies_id AS id,
            title
          FROM
            pochtaru.datatype_currencies

          UNION SELECT
            'DECLARATION_STATUS' AS group_id,
            datatype_declaration_status_id AS id,
            title
          FROM
            pochtaru.datatype_declaration_status

          UNION SELECT
            'DELIVERY_POINT_TYPE' AS group_id,
            datatype_delivery_point_type_id AS id,
            title
          FROM
            pochtaru.datatype_delivery_point_type

          UNION SELECT
            'DIMENSION_TYPE' AS group_id,
            datatype_dimension_type_id AS id,
            title
          FROM
            pochtaru.datatype_dimension_type

          UNION SELECT
            'DOCUMENT_DOWNLOAD_STATUS' AS group_id,
            datatype_document_download_status_id AS id,
            title
          FROM
            pochtaru.datatype_document_download_status

          UNION SELECT
            'ECOM_SERVICES' AS group_id,
            datatype_ecom_services_id AS id,
            title
          FROM
            pochtaru.datatype_ecom_services

          UNION SELECT
            'HYPER_LOCAL_STATUS' AS group_id,
            datatype_hyper_local_status_id AS id,
            title
          FROM
            pochtaru.datatype_hyper_local_status

          UNION SELECT
            'ORDER_VALIDATION_ERROR' AS group_id,
            datatype_order_validation_error_id AS id,
            title
          FROM
            pochtaru.datatype_order_validation_error

          UNION SELECT
            'PAYMENT_METHOD' AS group_id,
            datatype_payment_method_id AS id,
            title
          FROM
            pochtaru.datatype_payment_method

          UNION SELECT
            'PRODUCT' AS group_id,
            datatype_product_id AS id,
            title
          FROM
            pochtaru.datatype_product

          UNION SELECT
            'REMOVE_BACKLOG_ERROR' AS group_id,
            datatype_remove_backlog_error_id AS id,
            title
          FROM
            pochtaru.datatype_remove_backlog_error
        )
        SELECT
          id "Id",
          group_id  "GroupId",
          title "Title"
        FROM
          type;
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuOrderSelectByIdSqlQuery">
      <Text>
        SELECT
          order_id "OrderId",
          state AS "OrderState",
          id AS "Id",

          order_num "OrderNum",
          barcode "Barcode",

          sender_name "SenderName",
          raw_sender_address "SenderRawAddress",
          recipient_name "RecipientName",
          raw_recipient_address "RecipientRawAddress",

          address_from_quality_code_text "AddressFromQualityStatusText",
          address_from_validation_code_text "AddressFromValidationStatusText",
          address_from_quality_code_good "AddressFromQualityCheckSuccessfull",
          address_from_validation_code_good "AddressFromValidationCheckSuccessfull",
          address_to_quality_code_text "AddressToQualityStatusText",
          address_to_validation_code_text "AddressToValidationStatusText",
          address_to_quality_code_good "AddressToQualityCheckSuccessfull",
          address_to_validation_code_good "AddressToValidationCheckSuccessfull",

          address_type_from "AddressTypeFrom",
          area_from "AddressAreaFrom",
          building_from "AddressBuildingFrom",
          corpus_from "AddressCorpusFrom",
          hotel_from "AddressHotelFrom",
          house_from "AddressHouseFrom",
          index_from "AddressIndexFrom",
          letter_from "AddressLetterFrom",
          location_from "AddressLocationFrom",
          num_address_type_from "AddressNumAddressTypeFrom",
          office_from "AddressOfficeFrom",
          place_from "AddressPlaceFrom",
          region_from "AddressRegionFrom",
          room_from "AddressRoomFrom",
          slash_from "AddressSlashFrom",
          street_from "AddressStreetFrom",
          vladenie_from "AddressVladenieFrom",

          address_type_to "AddressTypeTo",
          area_to "AddressAreaTo",
          building_to "AddressBuildingTo",
          corpus_to "AddressCorpusTo",
          hotel_to "AddressHotelTo",
          house_to "AddressHouseTo",
          index_to "AddressIndexTo",
          letter_to "AddressLetterTo",
          location_to "AddressLocationTo",
          num_address_type_to "AddressNumAddressTypeTo",
          office_to "AddressOfficeTo",
          place_to "AddressPlaceTo",
          region_to "AddressRegionTo",
          room_to "AddressRoomTo",
          slash_to "AddressSlashTo",
          street_to "AddressStreetTo",
          vladenie_to "AddressVladenieTo",

          given_name "GivenName",
          surname "Surname",
          middle_name "MiddleName",
          mail_category "MailCategory",
          mail_category_text "MailCategoryText",
          mail_type "MailType",
          mail_type_text "MailTypeText",
          mass "Mass",

          add_to_mmo "AddToMMO",
          branch_name "BranchName",
          comment "Comment",
          completeness_checking "CompletenessChecking",
          compulsory_payment "CompulsoryPayment",
          courier "Courier",
          delivery_with_cod "DeliveryWithCod",
          dimension__height "DimensionHeight",
          dimension__width "DimensionWidth",
          dimension__length "DimensionLength",
          dimension_type "DimensionType",
          easy_return "EasyReturn",
          envelope_type "EnvelopeType",

          fragile "Fragile",
          group_name "GroupName",
          inner_num "InnerNum",
          insr_value "InsrValue",
          inventory "Inventory",
          no_return "NoReturn",
          notice_payment_method "NoticePaymentMethod",
          payment "Payment",
          payment_method "PaymentMethod",
          postoffice_code "PostofficeCode",
          pre_postal_preparation "PrePostalPreparation",

          prepaid_amount "PrepaidAmount",
          sender_comment "SenderComment",
          shelf_life_days "ShelfLifeDays",
          sms_notice_recipient "SMSNoticeRecipient",
          tel_address "TelAddress",
          tel_address_from "TelAddressFrom",
          transport_type "TransportType",
          vsd "VSD",
          with_documents "WithDocuments",
          with_electronic_notice "WithElectronicNotice",
          with_order_of_notice "WithOrderOfNotice",
          with_simple_notice "WithSimpleNotice",

          wo_mail_rank "WoMailRank"
        FROM
          collect.loan_post LP
          JOIN pochtaru.order_view_extended O ON O.order_id = LP.pochtaru_order_id
        WHERE
          loan_post_id = {LoanPostId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuOrderAddressSelectByIdSqlQuery">
      <Text>
        SELECT
          address_from_quality_code_text "AddressFromQualityStatusText",
          address_from_validation_code_text "AddressFromValidationStatusText",
          address_from_quality_code_good "AddressFromQualityCheckSuccessfull",
          address_from_validation_code_good "AddressFromValidationCheckSuccessfull",
          address_to_quality_code_text "AddressToQualityStatusText",
          address_to_validation_code_text "AddressToValidationStatusText",
          address_to_quality_code_good "AddressToQualityCheckSuccessfull",
          address_to_validation_code_good "AddressToValidationCheckSuccessfull",

          address_type_from "AddressTypeFrom",
          area_from "AddressAreaFrom",
          building_from "AddressBuildingFrom",
          corpus_from "AddressCorpusFrom",
          hotel_from "AddressHotelFrom",
          house_from "AddressHouseFrom",
          index_from "AddressIndexFrom",
          letter_from "AddressLetterFrom",
          location_from "AddressLocationFrom",
          num_address_type_from "AddressNumAddressTypeFrom",
          office_from "AddressOfficeFrom",
          place_from "AddressPlaceFrom",
          region_from "AddressRegionFrom",
          room_from "AddressRoomFrom",
          slash_from "AddressSlashFrom",
          street_from "AddressStreetFrom",
          vladenie_from "AddressVladenieFrom",

          address_type_to "AddressTypeTo",
          area_to "AddressAreaTo",
          building_to "AddressBuildingTo",
          corpus_to "AddressCorpusTo",
          hotel_to "AddressHotelTo",
          house_to "AddressHouseTo",
          index_to "AddressIndexTo",
          letter_to "AddressLetterTo",
          location_to "AddressLocationTo",
          num_address_type_to "AddressNumAddressTypeTo",
          office_to "AddressOfficeTo",
          place_to "AddressPlaceTo",
          region_to "AddressRegionTo",
          room_to "AddressRoomTo",
          slash_to "AddressSlashTo",
          street_to "AddressStreetTo",
          vladenie_to "AddressVladenieTo"
        FROM
          pochtaru.order_view_extended
        WHERE
          order_id = {OrderId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="OrderRateSelectByIdSqlQuery">
      <Text>
        SELECT
          order_calculated_rate AS "Rate"
        FROM
          pochtaru.order_view_extended
        WHERE
          order_id = {OrderId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuOrderErrorsSelectSqlQuery">
      <Text>
        SELECT
          pochtaru.get_error_message({OrderIds}::bigint[]) AS "Message";
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuOrderInsertSqlQuery">
      <Text>
        SELECT pochtaru.create_order({LoanPostId}::bigint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuOrderUpdateSqlQuery">
      <Text>
        UPDATE
          pochtaru.order
        SET
          raw_sender_address = {SenderRawAddress},
          raw_recipient_address = {RecipientRawAddress},

          add_to_mmo = {AddToMMO},
          branch_name = {BranchName},
          comment = {Comment},
          courier = {Courier},
          completeness_checking = {CompletenessChecking},
          compulsory_payment = {CompulsoryPayment},
          delivery_with_cod = {DeliveryWithCod},
          dimension__height = {DimensionHeight},
          dimension__length = {DimensionWidth},
          dimension__width = {DimensionLength},
          dimension_type = {DimensionType},
          easy_return = {EasyReturn},
          envelope_type = {EnvelopeType},
          fragile = {Fragile},
          given_name = {GivenName},
          group_name = {GroupName},
          inner_num = {InnerNum},
          insr_value = {InsrValue},
          inventory = {Inventory},
          mail_category = {MailCategory},
          --mail_direct = {MailDirect},
          mail_type = {MailType},
          mass = {Mass},
          middle_name = {MiddleName},
          no_return = {NoReturn},
          notice_payment_method = {NoticePaymentMethod},
          --order_num
          payment = {Payment},
          payment_method = {PaymentMethod},
          postoffice_code = {PostofficeCode},
          pre_postal_preparation = {PrePostalPreparation},
          prepaid_amount = {PrepaidAmount},
          --raw_address
          recipient_name = {RecipientName},
          sender_comment = {SenderComment},
          sender_name = {SenderName},
          shelf_life_days = {ShelfLifeDays},
          sms_notice_recipient = {SMSNoticeRecipient},
          surname = {Surname},
          tel_address = {TelAddress},
          tel_address_from = {TelAddressFrom},
          transport_type = {TransportType},
          vsd = {VSD},
          with_documents = {WithDocuments},
          with_electronic_notice = {WithElectronicNotice},
          with_order_of_notice = {WithOrderOfNotice},
          with_simple_notice = {WithSimpleNotice},
          wo_mail_rank = {WoMailRank}
        WHERE
          order_id = {OrderId};

        UPDATE
          pochtaru.order
        SET
          state='ADDED'
        WHERE
          order_id = {OrderId} AND
          state='NOT_ADDED';

        UPDATE
          pochtaru.address A
        SET
          state='ADDED'
        FROM
          pochtaru.order O
        WHERE
          O.order_id = {OrderId} AND
          (O.address_from_id = A.address_id OR O.address_to_id = A.address_id) AND
          A.state='NOT_ADDED';
      </Text>
    </SqlQuery>

    <SqlQuery Name="PochtaRuOrderAddressUpdateSqlQuery">
      <Text>
        UPDATE
          pochtaru.address A
        SET
          original_address = {OriginalAddressFrom},
          address_type = {AddressTypeFrom},
          area = {AreaFrom},
          building = {BuildingFrom},
          corpus = {CorpusFrom},
          hotel = {HotelFrom},
          house = {HouseFrom},
          index = {IndexFrom},
          letter = {LetterFrom},
          location = {LocationFrom},
          num_address_type = {NumAddressTypeFrom},
          office = {OfficeFrom},
          place = {PlaceFrom},
          region = {RegionFrom},
          room = {RoomFrom},
          slash = {SlashFrom},
          street = {StreetFrom},
          vladenie = {VladenieFrom}
        FROM
          pochtaru.order O
        WHERE
          A.address_id = O.address_from_id AND
          O.order_id = {OrderId};

        UPDATE
          pochtaru.address A
        SET
          original_address = {OriginalAddressTo},
          address_type = {AddressTypeTo},
          area = {AreaTo},
          building = {BuildingTo},
          corpus = {CorpusTo},
          hotel = {HotelTo},
          house = {HouseTo},
          index = {IndexTo},
          letter = {LetterTo},
          location = {LocationTo},
          num_address_type = {NumAddressTypeTo},
          office = {OfficeTo},
          place = {PlaceTo},
          region = {RegionTo},
          room = {RoomTo},
          slash = {SlashTo},
          street = {StreetTo},
          vladenie = {VladenieTo}
        FROM
          pochtaru.order O
        WHERE
          A.address_id  = O.address_to_id AND
          O.order_id = {OrderId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="BatchUpdateSqlQuery">
      <Text>
        UPDATE
          pochtaru.batch
        SET
          old_sending_date = sending_date,
          sending_date = {SendingDate}
        WHERE
          batch_id = {BatchId};
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===УВЕДОМЛЕНИЯ==============================================-->
    <!--============================================================-->
    <SqlQuery Name="NotificationCountSqlQuery">
      <Text>
        SELECT
          count(*) AS "NotificationCount"
        FROM
          collect.notification_view
        WHERE
          user_id = {UserId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="NotificationSelectSqlQuery">
      <Text>
          SELECT
          NV.notification_id AS "NotificationId",
          NV.task_id AS "TaskId",
          NV.notification_type_id AS "NotificationTypeId",
          NV.notification_date AS "NotificationDate",
          NV.description AS "Description"
        FROM
          collect.notification_view NV
        WHERE
          user_id = {UserId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="NotificationTypeSelectSqlQuery">
      <Text>
        SELECT
          notification_type_id AS "NotificationTypeId",
          title AS "Title",
          title_genitive AS "TitleGenetive",
          name AS "Name"
        FROM
          collect.notification_type;
      </Text>
    </SqlQuery>

    <SqlQuery Name="NotificationTargetSelectSqlQuery">
      <Text>
        SELECT
          notification_target_id AS "NotificationTargetId",
          title AS "Title",
          name AS "Name"
        FROM
          collect.notification_target;
      </Text>
    </SqlQuery>

    <SqlQuery Name="NotificationDeleteSqlQuery">
      <Text>
        DELETE FROM
          collect.notification
        WHERE
          notification_id = {NotificationId};
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===НАСТРОЙКИ================================================-->
    <!--============================================================-->
    <SqlQuery Name="SettingsSelectSqlQuery">
      <Text>
        WITH server_time_zone AS (
          SELECT
            trim(substr(title, strpos(title, ')') + 1) || ' ' || substr(title, 1, strpos(title, ')'))) AS title
          FROM
            public.time_zone_info
          WHERE
            name = {ServerTimeZone}
        ), equifax_settings AS (
          SELECT
            count(bki_export_id) + 1 AS portion
          FROM
            collect.bki_export BE
            LEFT JOIN collect.bki_type BT USING(bki_type_id)
          WHERE
            BT.name = 'equifax' AND
            BE.export_date::date = now()::date
          GROUP BY BE.export_date::date
        )
        SELECT
          S.audio_auth_token AS "AudioAuthToken",
          S.audio_correction AS "AudioCorrection",
          S.inbox_post_prefix AS "InboxPostPrefix",
          S.inbox_post_next_number AS "InboxPostNextNumber",
          S.outbox_post_prefix AS "OutboxPostPrefix",
          S.outbox_post_next_number AS "OutboxPostNextNumber",
          S.notification_refresh_period AS "NotificationRefreshPeriod",
          S.notification_task_new_enabled AS "NotificationTaskNewEnabled",
          S.notification_task_deadline_enabled AS "NotificationTaskDeadlineEnabled",
          S.notification_task_deadline_period AS "NotificationTaskDeadlinePeriod",
          S.notification_task_deadline_target AS "NotificationTaskDeadlineTarget",
          S.notification_task_overdue_enabled AS "NotificationTaskOverdueEnabled",
          S.notification_task_overdue_period AS "NotificationTaskOverduePeriod",
          S.notification_task_overdue_target AS "NotificationTaskOverdueTarget",
          S.notification_task_not_closed_enabled AS "NotificationTaskNotClosedEnabled",
          S.notification_task_not_closed_target AS "NotificationTaskNotClosedTarget",
          S.status_button_width AS "StatusButtonWidth",
          S.module_nbki_available AS "ModuleNbkiAvailable",
          S.nbki_member_code AS "NbkiMemberCode",
          S.nbki_authorization_code AS "NbkiAuthorizationCode",
          S.nbki_format_version_id AS "NbkiFormatVersionId",
          S.module_equifax_available AS "ModuleEquifaxAvailable",
          S.equifax_partner_code AS "EquifaxPartnerCode",
          S.equifax_format_version_id AS "EquifaxFormatVersionId",
          COALESCE(ES.portion, 1) AS "EquifaxFileRegNumber",
          S.module_okb_available AS "ModuleOkbAvailable",
          S.okb_subscriber_code AS "OkbSubscriberCode",
          S.okb_format_version_id AS "OkbFormatVersionId",
          S.okb_test_mode_on AS "OkbTestModeOn",
          S.module_fssp_available AS "ModuleFsspAvailable",
          S.fssp_token AS "FsspToken",
          S.fssp_max_group_size AS "FsspMaxGroupSize",
          S.fssp_auto_checking AS "FsspAutoChecking",
          S.fssp_auto_check_time AS "FsspAutoCheckTime",
          S.fssp_auto_check_days_interval AS "FsspAutoCheckDaysInterval",
          S.module_autotask_available AS "ModuleAutotaskAvailable",
          S.autotask_auto_checking AS "AutotaskAutoChecking",
          S.autotask_auto_check_minutes_interval AS "AutotaskAutoCheckMinutesInterval",
          STZ.title AS "ServerTimeZoneTitle",
          S.module_email_enabled AS "ModuleEmailEnabled",
          S.module_email_available AS "ModuleEmailAvailable",

          S.module_pochtaru_available AS "ModulePochtaRuAvailable",
          S.module_pochtaru_enabled AS "ModulePochtaRuEnabled",
          S.module_pochtaru_user_token AS "ModulePochtaRuUserToken",
          S.module_pochtaru_user_key AS "ModulePochtaRuUserKey",
          S.module_pochtaru_days_limit AS "ModulePochtaRuDaysLimit",
          S.module_pochtaru_days_of_week AS "ModulePochtaRuDaysOfWeek",

          S.module_debex_fssp_available AS "ModuleDebexFsspAvailable",
          S.module_debex_fssp_enabled AS "ModuleDebexFsspEnabled",
          S.module_debex_bankrupt_available AS "ModuleDebexBankruptAvailable",
          S.module_debex_bankrupt_enabled AS "ModuleDebexBankruptEnabled",
          S.module_debex_jurisdiction_available AS "ModuleDebexJurisdictionAvailable",
          S.module_debex_jurisdiction_enabled AS "ModuleDebexJurisdictionEnabled",
          S.module_debex_token AS "ModuleDebexToken",

          S.module_application_tax_available AS "ModuleApplicationTaxAvailable",
          S.module_application_tax_enabled AS "ModuleApplicationTaxEnabled",
          
          
          S.auto_send_bday_sms AS "AutoSendBdaySms",
          S.auto_send_bday_sms_time AS "AutoSendBdaySmsTime",
          S.sms_module_currency AS "SmsModuleCurrency",
          S.hide_sms_module AS "HideSmsModule",
          S.sms_module_is_on AS "SmsModuleIsOn"
        FROM
          collect.settings S
          LEFT JOIN server_time_zone STZ ON true
          LEFT JOIN equifax_settings ES ON true
        ORDER BY settings_id LIMIT 1;
      </Text>
    </SqlQuery>

    <SqlQuery Name="BkiSettingsSelectSqlQuery">
      <Text>
        WITH equifax_settings AS (
          SELECT
            count(bki_export_id) + 1 AS portion
          FROM
            collect.bki_export BE
            LEFT JOIN collect.bki_type BT USING(bki_type_id)
          WHERE
            BT.name = 'equifax' AND
            BE.export_date::date = now()::date
          GROUP BY BE.export_date::date
        )
        SELECT
          S.nbki_member_code AS "NbkiMemberCode",
          S.nbki_authorization_code AS "NbkiAuthorizationCode",
          NF.title AS "NbkiFormatVersion",
          S.equifax_partner_code AS "EquifaxPartnerCode",
          COALESCE(ES.portion, 1) AS "EquifaxFileRegNumber",
          EF.title AS "EquifaxFormatVersion",
          S.okb_subscriber_code AS "OkbSubscriberCode",
          OF.title AS "OkbFormatVersion",
          OF.filename  AS "OkbFileNameFormatVersion",
          S.okb_test_mode_on AS "OkbTestModeOn"
        FROM 
          collect.settings S
          LEFT JOIN collect.nbki_format_version NF USING (nbki_format_version_id)
          LEFT JOIN collect.equifax_format_version EF USING (equifax_format_version_id)
          LEFT JOIN collect.okb_format_version OF USING (okb_format_version_id)
          LEFT JOIN equifax_settings ES ON true
        ORDER BY settings_id LIMIT 1;  
      </Text>
    </SqlQuery>

    <SqlQuery Name="DebtTypeSelectSqlQuery">
      <Text>
        SELECT
          debt_type_id AS "DebtTypeId",
          name AS "Name",
          title AS "Title",
          order_number AS "OrderNumber"
        FROM
          collect.debt_type
        ORDER BY order_number;
      </Text>
    </SqlQuery>

    <SqlQuery Name="NbkiFormatVersionSelectSqlQuery">
      <Text>
        SELECT
          nbki_format_version_id AS "NbkiFormatVersionId",
          title AS "Title"
        FROM collect.nbki_format_version;
      </Text>
    </SqlQuery>

    <SqlQuery Name="EquifaxFormatVersionSelectSqlQuery">
      <Text>
        SELECT
          equifax_format_version_id AS "EquifaxFormatVersionId",
          title AS "Title"
        FROM collect.equifax_format_version;
      </Text>
    </SqlQuery>

    <SqlQuery Name="OkbFormatVersionSelectSqlQuery">
      <Text>
        SELECT
          okb_format_version_id AS "OkbFormatVersionId",
          title AS "Title"
        FROM collect.okb_format_version;
      </Text>
    </SqlQuery>

    <SqlQuery Name="SettingsUpdateSqlQuery">
      <Text>
        UPDATE
          collect.settings
        SET
          audio_auth_token = {AudioAuthToken},
          audio_correction = {AudioCorrection},
          inbox_post_prefix = {InboxPostPrefix},
          inbox_post_next_number = {InboxPostNextNumber},
          outbox_post_prefix = {OutboxPostPrefix},
          outbox_post_next_number = {OutboxPostNextNumber},
          notification_refresh_period = {NotificationRefreshPeriod},
          notification_task_new_enabled = {NotificationTaskNewEnabled},
          notification_task_deadline_enabled = {NotificationTaskDeadlineEnabled},
          notification_task_deadline_period = {NotificationTaskDeadlinePeriod},
          notification_task_deadline_target = {NotificationTaskDeadlineTarget}::integer[],
          notification_task_overdue_enabled = {NotificationTaskOverdueEnabled},
          notification_task_overdue_period = {NotificationTaskOverduePeriod},
          notification_task_overdue_target = {NotificationTaskOverdueTarget}::integer[],
          notification_task_not_closed_enabled = {NotificationTaskNotClosedEnabled},
          notification_task_not_closed_target = {NotificationTaskNotClosedTarget}::integer[],
          status_button_width = {StatusButtonWidth},
          fssp_token = {FsspToken},
          fssp_max_group_size = COALESCE({FsspMaxGroupSize}, 50),
          fssp_auto_checking = {FsspAutoChecking},
          fssp_auto_check_days_interval = COALESCE({FsspAutoCheckDaysInterval}, 7),
          fssp_auto_check_time = {FsspAutoCheckTime}::time,

          nbki_member_code = {NbkiMemberCode},
          nbki_authorization_code = {NbkiAuthorizationCode},
          equifax_partner_code = {EquifaxPartnerCode},
          okb_subscriber_code = {OkbSubscriberCode},
          okb_test_mode_on = {OkbTestModeOn},
          
          autotask_auto_checking = {AutotaskAutoChecking},
          autotask_auto_check_minutes_interval = COALESCE({AutotaskAutoCheckMinutesInterval}, 30),

          module_email_enabled = {ModuleEmailEnabled},

          module_pochtaru_enabled = {ModulePochtaRuEnabled},
          module_pochtaru_user_token = {ModulePochtaRuUserToken},
          module_pochtaru_user_key = {ModulePochtaRuUserKey},
          module_pochtaru_days_limit = {ModulePochtaRuDaysLimit},
          module_pochtaru_days_of_week = {ModulePochtaRuDaysOfWeek}::smallint[],

          module_debex_fssp_enabled = {ModuleDebexFsspEnabled},
          module_debex_bankrupt_enabled = {ModuleDebexBankruptEnabled},
          module_debex_jurisdiction_enabled = {ModuleDebexJurisdictionEnabled},
          module_debex_token = {ModuleDebexToken},

          module_application_tax_enabled = {ModuleApplicationTaxEnabled},
          
          sms_module_is_on = {SMSModuleIsOn},
          auto_send_bday_sms = {AutoSendBdaySMS},
          auto_send_bday_sms_time = {AutoSendBdaySMSTime}::time,
          sms_module_currency = {SMSModuleCurrency};

        UPDATE
          public.time_zone_info
        SET
          by_default = (time_zone_info_id = {DefaultTimeZoneInfoId});

        UPDATE
          public.load_mode
        SET
          selected = (load_mode_id = {LoadModeId});

        UPDATE
          collect.debt_type DT
        SET
          order_number = T.order_number
        FROM (
          SELECT
            unnest({DebtTypeId}::integer[]) AS debt_type_id,
            unnest({OrderNumber}::integer[]) AS order_number
          ) T
        WHERE
          DT.debt_type_id = T.debt_type_id;   
                 
        UPDATE 
          collect.sms_settings
        SET
          user_name = {SMSUserName},
          password = {SMSPassword}
        WHERE 
          name = 'SMSCenter';
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===ПОЛЬЗОВАТЕЛИ=============================================-->
    <!--============================================================-->
    <SqlQuery Name="UserLoginSelectSqlQuery">
      <Text>
        SELECT
          user_id AS "UserId",
          user_name AS "UserName",
          user_full_name AS "UserFullName"
        FROM
          collect.user_info
          JOIN collect.user_group USING(user_id)
          JOIN collect."group" USING (group_id)
        WHERE
          person AND
          NOT archive AND
          "group".name != 'GuestGroup';
      </Text>
    </SqlQuery>

    <SqlQuery Name="UserSelectSqlQuery">
      <Text>
        SELECT
          U.user_id AS "UserId",
          UI.user_full_name AS "Title",
          G.name AS "GroupName",
          G.title AS "GroupTitle",
          UI.archive AS "Archive"
        FROM
          collect.user U
          JOIN collect.user_group USING (user_id)
          JOIN collect.group G USING (group_id)
          JOIN collect.user_info UI USING(user_id)
        WHERE
          UI.person
        ORDER BY UI.user_full_name, user_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="UserSimpleSelectSqlQuery">
      <Text>
        SELECT
          U.user_id AS "UserId",
          UI.user_full_name AS "Title",
          UI.archive AS "Archive",
          UI.person AS "Person",
          {UserId} = U.user_id AS "IsCurrentUser"
        FROM
          collect.user U
          LEFT JOIN collect.user_info UI USING(user_id)
        ORDER BY UI.user_full_name, user_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="UserByIdSelectSqlQuery">
      <Text>
        SELECT
          UI.user_name AS "UserName",
          UI.user_full_name AS "Title",
          U.full_title AS "FullTitle",
          U.full_title_genitive AS "FullTitleGenitive",
          UG.group_id AS "GroupId",
          U.post AS "Post",
          U.procuration_number AS "ProcurationNumber",
          U.procuration_date AS "ProcurationDate",
          U.email AS "Email",
          U.user_id = {UserId} AS "IsCurrent",
          UI.report_payment AS "ReportPayment",
          UI.report_interaction AS "ReportInteraction",
          UI.report_debt as "ReportDebt",
          UI.report_application_tax_payment AS "ReportApplicationTaxPayment",
          UI.report_users as "ReportUsers",
          UI.list_claimant AS "ListClaimant",
          UI.list_inner_org AS "ListInnerOrg",
          UI.list_cession AS "ListCession",
          UI.list_client AS "ListClient",
          UI.list_address AS "ListAddress",
          UI.list_document AS "ListDocument",
          UI.list_court AS "ListCourt",
          UI.list_osp AS "ListOsp",
          UI.list_task_type AS "ListTaskType",
          UI.list_audio_file AS "ListAudioFile",
          UI.list_email AS "ListEmail",
          UI.list_application_tax_payment_export AS "ListApplicationTaxPaymentExport",
          UES.smtp_server_address AS "SmtpServerAddress",
          UES.smtp_server_port AS "SmtpServerPort",
          UES.email_sender AS "EmailSender",
          UES.email_password AS "EmailPassword",
          UES.email_sender_name AS "EmailSenderName",
          UES.email_signature AS "EmailSignature",
          UI.list_pochtaru_orders AS "ListPochtaRuOrders",
          UI.list_bankrupt_type AS "ListBankruptType",
          UI.debex_fssp_check AS "DebexFsspCheck",
          UI.debex_bankrupt_check AS "DebexBankruptCheck",
          UI.debex_jurisdiction_check AS "DebexJurisdictionCheck"
        FROM
          collect.user U
          JOIN collect.user_group UG USING (user_id)
          JOIN collect.user_info UI USING (user_id)
          LEFT JOIN collect.user_email_settings UES USING (user_id)
        WHERE
          U.user_id = {EditUserId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="UserUserByIdSelectSqlQuery">
      <Text>
        SELECT
          UU.child_user_id AS "ChildUserId"
        FROM
          collect.user_user UU
        WHERE
          parent_user_id = {EditUserId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="UserPhoneSelectSqlQuery">
      <Text>
        SELECT
          user_id AS "UserId",
          user_phone_id AS "UserPhoneId",
          phone_number AS "PhoneNumber",
          archive AS "Archive"
        FROM
          collect.user_phone
        ORDER BY user_id, user_phone_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="UserPhoneByUserIdSelectSqlQuery">
      <Text>
        SELECT
          user_phone_id AS "UserPhoneId",
          phone_number AS "PhoneNumber",
          is_main AS "IsMain"
        FROM
          collect.user_phone
        WHERE
          user_id = {EditUserId} AND
          NOT archive
        ORDER BY user_phone_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="GroupSelectSqlQuery">
      <Text>
        SELECT
          group_id AS "GroupId",
          name AS "Name",
          title AS "Title"
        FROM
          collect.group
        WHERE
          name NOT IN ('GuestGroup')
        ORDER BY title;
      </Text>
    </SqlQuery>

    <SqlQuery Name="UserPasswordUpdateSqlQuery">
      <Text>
        UPDATE
          public.user
        SET
          user_password = {Password}
        WHERE
          user_id = (SELECT public_user_id FROM collect.user WHERE user_id = {EditUserId});
      </Text>
    </SqlQuery>

    <SqlQuery Name="UserSaveSqlQuery">
      <Text>
        SELECT collect.user_save({Model}::json);
      </Text>
    </SqlQuery>

    <SqlQuery Name="UserArchiveSqlQuery">
      <Text>
        UPDATE
          public.user
        SET
          enabled = NOT {Archive}
        WHERE
          user_id = (SELECT public_user_id FROM collect.user WHERE user_id = {EditUserId});
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===ЦЕДЕНТЫ==================================================-->
    <!--============================================================-->
    <SqlQuery Name="ClaimantSelectSqlQuery">
      <Text>
        SELECT
          claimant_id AS "ClaimantId",
          title AS "Title",
          short_title AS "ShortTitle",
          inn AS "Inn",
          address AS "Address",
          archive AS "Archive"
        FROM
          collect.claimant
        ORDER BY title, claimant_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClaimantSimpleSelectSqlQuery">
      <Text>
        SELECT
          claimant_id AS "ClaimantId",
          short_title AS "Title",
          archive AS "Archive"
        FROM
          collect.claimant
        ORDER BY short_title, claimant_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClaimantTypeSelectSqlQuery">
      <Text>
        SELECT
          claimant_type_id AS "ClaimantTypeId",
          title AS "Title"
        FROM
          collect.claimant_type
        ORDER BY claimant_type_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClaimantByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title",
          short_title AS "ShortTitle",
          branch AS "Branch",
          representative AS "Representative",
          representative_post AS "RepresentativePost",
          document AS "Document",
          inn AS "Inn",
          address AS "Address",
          title_genitive AS "TitleGenitive",
          branch_genitive AS "BranchGenitive",
          representative_genitive AS "RepresentativeGenitive",
          representative_post_genitive AS "RepresentativePostGenitive",
          document_genitive AS "DocumentGenitive",
          claimant_type_id AS "ClaimantTypeId"
        FROM
          collect.claimant
        WHERE
          claimant_id = {ClaimantId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClaimantInsertSqlQuery">
      <Text>
        INSERT INTO collect.claimant(
          title,
          short_title,
          branch,
          representative,
          representative_post,
          document,
          inn,
          address,
          title_genitive,
          branch_genitive,
          representative_genitive,
          representative_post_genitive,
          document_genitive,
          claimant_type_id
          )
        VALUES (
          {Title},
          {ShortTitle},
          {Branch},
          {Representative},
          {RepresentativePost},
          {Document},
          {Inn},
          {Address},
          {TitleGenitive},
          {BranchGenitive},
          {RepresentativeGenitive},
          {RepresentativePostGenitive},
          {DocumentGenitive},
          {ClaimantTypeId}
          )
        RETURNING claimant_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClaimantUpdateSqlQuery">
      <Text>
        UPDATE
          collect.claimant
        SET
          title = {Title},
          short_title = {ShortTitle},
          branch = {Branch},
          representative = {Representative},
          representative_post = {RepresentativePost},
          document = {Document},
          inn = {Inn},
          address = {Address},
          title_genitive = {TitleGenitive},
          branch_genitive = {BranchGenitive},
          representative_genitive = {RepresentativeGenitive},
          representative_post_genitive = {RepresentativePostGenitive},
          document_genitive = {DocumentGenitive},
          claimant_type_id = {ClaimantTypeId}
        WHERE
          claimant_id = {ClaimantId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClaimantArchiveSqlQuery">
      <Text>
        UPDATE
          collect.claimant C
        SET
          archive = NOT T.archive
        FROM (
          SELECT
            unnest({ClaimantId}::bigint[]) AS claimant_id,
            unnest({Archive}::boolean[]) AS archive
        ) T
        WHERE
          C.claimant_id = T.claimant_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClaimantDeleteSqlQuery">
      <Text>
        SELECT collect.claimant_try_delete({ClaimantId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClaimantMergeSqlQuery">
      <Text>
        SELECT collect.claimant_merge({MergeClaimantIds}::bigint[], {ClaimantId}::bigint, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===ЦЕССИОНАРИИ==============================================-->
    <!--============================================================-->
    <SqlQuery Name="InnerOrgSelectSqlQuery">
      <Text>
        SELECT
          inner_org_id AS "InnerOrgId",
          title AS "Title",
          short_title AS "ShortTitle",
          inn AS "Inn",
          legal_address AS "Address",
          archive AS "Archive"
        FROM
          collect.inner_org
        ORDER BY title, inner_org_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="InnerOrgSimpleSelectSqlQuery">
      <Text>
        SELECT
          inner_org_id AS "InnerOrgId",
          short_title AS "Title",
          legal_address AS "Address",
          archive AS "Archive"
        FROM
          collect.inner_org
        ORDER BY short_title, inner_org_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="InnerOrgByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title",
          short_title AS "ShortTitle",
          leader_post AS "LeaderPost",
          document AS "Document",
          leader_title AS "LeaderTitle",
          leader_genitive AS "LeaderGenitive",
          leader_initials AS "LeaderInitials",
          legal_address AS "LegalAddress",
          actual_address AS "ActualAddress",
          city AS "City",
          inn AS "Inn",
          kpp AS "Kpp",
          ogrn AS "Ogrn",
          payment_account AS "PaymentAccount",
          bank AS "Bank",
          bank_city AS "BankCity",
          correspondent_account AS "CorrespondentAccount",
          bik AS "Bik",
          phone AS "Phone",
          fax AS "Fax",
          email AS "Email",
          website AS "Website",
          org_create_date AS "OrgCreateDate"
        FROM
          collect.inner_org
        WHERE
          inner_org_id = {InnerOrgId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="InnerOrgInsertSqlQuery">
      <Text>
        INSERT INTO collect.inner_org(
          title,
          short_title,
          leader_post,
          document,
          leader_title,
          leader_genitive,
          leader_initials,
          legal_address,
          actual_address,
          city,
          inn,
          kpp,
          ogrn,
          payment_account,
          bank,
          bank_city,
          correspondent_account,
          bik,
          phone,
          fax,
          email,
          website,
          org_create_date
          )
        VALUES (
          {Title},
          {ShortTitle},
          {LeaderPost},
          {Document},
          {LeaderTitle},
          {LeaderGenitive},
          {LeaderInitials},
          {LegalAddress},
          {ActualAddress},
          {City},
          {Inn},
          {Kpp},
          {Ogrn},
          {PaymentAccount},
          {Bank},
          {BankCity},
          {CorrespondentAccount},
          {Bik},
          {Phone},
          {Fax},
          {Email},
          {Website},
          {OrgCreateDate}
          )
        RETURNING inner_org_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="InnerOrgUpdateSqlQuery">
      <Text>
        UPDATE
          collect.inner_org
        SET
          title = {Title},
          short_title = {ShortTitle},
          leader_post = {LeaderPost},
          document = {Document},
          leader_title = {LeaderTitle},
          leader_genitive = {LeaderGenitive},
          leader_initials = {LeaderInitials},
          legal_address = {LegalAddress},
          actual_address = {ActualAddress},
          city = {City},
          inn = {Inn},
          kpp = {Kpp},
          ogrn = {Ogrn},
          payment_account = {PaymentAccount},
          bank = {Bank},
          bank_city = {BankCity},
          correspondent_account = {CorrespondentAccount},
          bik = {Bik},
          phone = {Phone},
          fax = {Fax},
          email = {Email},
          website = {Website},
          org_create_date = {OrgCreateDate}
        WHERE
          inner_org_id = {InnerOrgId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="InnerOrgArchiveSqlQuery">
      <Text>
        UPDATE
          collect.inner_org I
        SET
          archive = NOT T.archive
        FROM (
          SELECT
            unnest({InnerOrgId}::bigint[]) AS inner_org_id,
            unnest({Archive}::boolean[]) AS archive
        ) T
        WHERE
          I.inner_org_id = T.inner_org_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="InnerOrgDeleteSqlQuery">
      <Text>
        SELECT collect.inner_org_try_delete({InnerOrgId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="InnerOrgMergeSqlQuery">
      <Text>
        SELECT collect.inner_org_merge({MergeInnerOrgIds}::bigint[], {InnerOrgId}::bigint, {UserId}::smallint);
      </Text>
    </SqlQuery>
    <!--============================================================-->
    <!--===ЦЕССИИ===================================================-->
    <!--============================================================-->
    <SqlQuery Name="CessionSelectSqlQuery">
      <Text>
        SELECT
          1 AS "Order",
          C.cession_id AS "CessionId",
          C.title AS "Title",
          CT.title AS "CessionTypeTitle",
          C.cession_date AS "CessionDate",
          COALESCE(L.loan_count, 0) AS "LoanQuantity",
          COALESCE(L.total_debt_sum, 0) AS "LoanTotalDebtSum",
          CL.short_title AS "ClaimantTitle",
          IO.short_title AS "InnerOrgTitle",
          AR.title AS "AddressRegionTitle",
          C.archive AS "Archive"
        FROM
          collect.cession C
          JOIN collect.cession_type CT USING(cession_type_id)
          JOIN collect.claimant CL USING(claimant_id)
          JOIN collect.inner_org IO USING(inner_org_id)
          LEFT JOIN collect.address_region AR USING(address_region_id)
          LEFT JOIN (
            SELECT
              L.cession_id,
              count(*) AS loan_count,
              SUM(COALESCE(L.debt_base, 0) + COALESCE(L.debt_percent, 0) + COALESCE(L.debt_penalty, 0) + COALESCE(L.debt_tax, 0)) AS total_debt_sum
            FROM
              collect.loan L
            WHERE
              NOT deleted
            GROUP BY cession_id
          ) L USING(cession_id)

        UNION ALL

        SELECT
          2 AS "Order",
          -1::bigint AS "CessionId",
          'БЕЗ ЦЕССИИ' AS "Title",
          NULL AS "CessionTypeTitle",
          NULL::date AS "CessionDate",
          COALESCE(L.loan_count, 0) AS "LoanQuantity",
          COALESCE(L.total_debt_sum, 0) AS "LoanTotalDebtSum",
          NULL AS "ClaimantTitle",
          NULL AS "InnerOrgTitle",
          NULL AS "AddressRegionTitle",
          false AS "Archive"
        FROM (
          SELECT
            count(*) AS loan_count,
            SUM(COALESCE(L.debt_base, 0) + COALESCE(L.debt_percent, 0) + COALESCE(L.debt_penalty, 0) + COALESCE(L.debt_tax, 0)) AS total_debt_sum
          FROM
            collect.loan L
          WHERE
            NOT deleted AND
            cession_id IS NULL
          ) L
        ORDER BY "Order", "Title", "CessionId" ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="CessionSimpleSelectSqlQuery">
      <Text>
        SELECT
          cession_id AS "CessionId",
          claimant_id AS "ClaimantId",
          inner_org_id AS "InnerOrgId",
          cession_date AS "CessionDate",
          title AS "Title",
          archive AS "Archive"
        FROM
          collect.cession
        ORDER BY cession_date DESC, title, cession_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="CessionByIdSelectSqlQuery">
      <Text>
        SELECT
          cession_id AS "CessionId",
          title AS "Title",
          cession_type_id AS "CessionTypeId",
          cession_date AS "CessionDate",
          claimant_id AS "ClaimantId",
          inner_org_id AS "InnerOrgId",
          address_region_id AS "AddressRegionId",
          agreement_number AS "AgreementNumber"
        FROM
          collect.cession
        WHERE
          cession_id = {CessionId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanByCessionIdSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), T AS (
          SELECT
            loan_id
          FROM
            collect.loan L
          WHERE
            NOT L.deleted AND
            ((L.cession_id = {CessionId} AND NOT {FakeCession}) OR (L.cession_id IS NULL AND {FakeCession}))
        ), loan_users AS (
          SELECT
            LC.loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client LC
            JOIN T USING(loan_id)
          WHERE
            LC.user_id IS NOT NULL
          GROUP BY LC.loan_id
        ), final AS (
          SELECT
            T.loan_id
          FROM
            T
            LEFT JOIN loan_users LU USING(loan_id)
            LEFT JOIN current_user_info CUI ON true
          WHERE
            CUI.user_is_administrator OR
            (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
            {UserId} = ANY(LU.user_ids)
        ), loan_payment AS (
          SELECT
            LC.loan_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            final F
            LEFT JOIN collect.loan_client LC USING(loan_id)
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_id)
          GROUP BY LC.loan_id
        ), loan_info AS (
          SELECT
            L.loan_id,
            COALESCE(L.debt_base, 0) + COALESCE(L.debt_percent, 0) + COALESCE(L.debt_penalty, 0) + COALESCE(L.debt_tax, 0) AS total_debt_sum,
            COALESCE(LP.total_payment_sum, 0) AS total_payment_sum,
            GREATEST(COALESCE(L.debt_base, 0) + COALESCE(L.debt_percent, 0) + COALESCE(L.debt_penalty, 0) + COALESCE(L.debt_tax, 0) - COALESCE(LP.total_payment_sum, 0), 0) AS total_debt_rest_sum
          FROM
            final F
            LEFT JOIN collect.loan L USING(loan_id)
            LEFT JOIN loan_payment LP USING (loan_id)
        )
        SELECT
          L.loan_id AS "LoanId",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "ClientTitle",
          R.title AS "RoleTitle",
          L.credit_number AS "CreditNumber",
          L.credit_date AS "CreditDate",
          S.title AS "StatusTitle",
          LI.total_debt_sum AS "TotalDebtSum",
          LI.total_payment_sum AS "TotalPaymentSum",
          LI.total_debt_rest_sum AS "TotalDebtRestSum"
        FROM
          final F
          LEFT JOIN collect.loan L USING(loan_id)
          LEFT JOIN loan_info LI USING(loan_id)
          LEFT JOIN collect.loan_client LC ON L.loan_id = LC.loan_id AND LC.is_main
          LEFT JOIN collect.role R USING(role_id)
          LEFT JOIN collect.status S USING(status_id)
          LEFT JOIN collect.client_person CP USING(client_id);
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanCessionUpdateSqlQuery">
      <Text>
        SELECT collect.loan_update(
          L.loan_id,
          L.credit_number,
          {CessionId}::bigint,
          L.credit_date,
          L.credit_end_date,
          L.credit_sum,
          L.credit_rate,
          L.is_floating_credit_rate,
          L.credit_type_id,
          L.credit_line_type_id,
          L.credit_purpose_id,
          L.credit_get_type_id,
          L.first_claimant_id,
          L.debt_base,
          L.debt_percent,
          L.debt_penalty,
          L.debt_tax,
          L.fssp_debt,
          L.account_number,
          L.full_price,
          L.full_price_percent,
          L.overdue_date,
          {UserId}::smallint)
        FROM
          collect.loan L
        WHERE
          L.loan_id = ANY({LoanIds}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="CessionInsertSqlQuery">
      <Text>
        INSERT INTO collect.cession(
          title,
          cession_type_id,
          cession_date,
          claimant_id,
          inner_org_id,
          address_region_id,
          agreement_number)
        VALUES(
          {Title},
          {CessionTypeId},
          {CessionDate},
          {ClaimantId},
          {InnerOrgId},
          {AddressRegionId},
          {AgreementNumber})
        RETURNING cession_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="CessionUpdateSqlQuery">
      <Text>
        UPDATE
          collect.cession
        SET
          title = {Title},
          cession_type_id = {CessionTypeId},
          cession_date = {CessionDate},
          claimant_id = {ClaimantId},
          inner_org_id = {InnerOrgId},
          address_region_id = {AddressRegionId},
          agreement_number = {AgreementNumber}
        WHERE
          cession_id = {CessionId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="CessionArchiveSqlQuery">
      <Text>
        UPDATE
          collect.cession
        SET
          archive = {Archive}
        WHERE
          cession_id = {CessionId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="CessionDeleteSqlQuery">
      <Text>
        SELECT collect.cession_try_delete({CessionId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="CessionMergeSqlQuery">
      <Text>
        SELECT collect.cession_merge({MergeCessionIds}::bigint[], {CessionId}::bigint, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="CessionTypeSelectSqlQuery">
      <Text>
        SELECT
          cession_type_id AS "CessionTypeId",
          title AS "Title"
        FROM
          collect.cession_type;
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===СПИСКИ ПО АДРЕСАМ========================================-->
    <!--============================================================-->
    <!-- регионы -->
    <SqlQuery Name="AddressRegionSelectSqlQuery">
      <Text>
        SELECT
          address_region_id AS "AddressRegionId",
          title AS "Title"
        FROM
          collect.address_region
        ORDER BY address_region_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressRegionAlternativeSelectSqlQuery">
      <Text>
        SELECT
          address_region_alternative_id AS "AddressRegionAlternativeId",
          title AS "Title"
        FROM
          collect.address_region_alternative;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressRegionAlternativeByAddressRegionIdSelectSqlQuery">
      <Text>
        SELECT
          address_region_alternative_id AS "AddressRegionAlternativeId",
          title AS "Title"
        FROM
          collect.address_region_alternative
        WHERE
          address_region_id = {AddressRegionId}
        ORDER BY title;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressRegionAlternativeByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title"
        FROM
          collect.address_region_alternative
        WHERE
          address_region_alternative_id = {AddressRegionAlternativeId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressRegionAlternativeInsertSqlQuery">
      <Text>
        INSERT INTO collect.address_region_alternative(
          title,
          address_region_id
          )
        VALUES(
          {Title},
          {AddressRegionId}
          )
        RETURNING address_region_alternative_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressRegionAlternativeUpdateSqlQuery">
      <Text>
        UPDATE
          collect.address_region_alternative
        SET
          title = {Title}
        WHERE
          address_region_alternative_id = {AddressRegionAlternativeId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressRegionAlternativeDeleteSqlQuery">
      <Text>
        DELETE FROM
          collect.address_region_alternative
        WHERE
          address_region_alternative_id = {AddressRegionAlternativeId};
      </Text>
    </SqlQuery>

    <!-- районы региона -->
    <SqlQuery Name="AddressDistrictSelectSqlQuery">
      <Text>
        SELECT
          address_district_id AS "AddressDistrictId",
          title AS "Title",
          archive AS "Archive"
        FROM
          collect.address_district
        ORDER BY title, address_district_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressDistrictByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title"
        FROM
          collect.address_district
        WHERE
          address_district_id = {AddressDistrictId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressDistrictInsertSqlQuery">
      <Text>
        INSERT INTO collect.address_district(title)
        VALUES({Title})
        RETURNING address_district_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressDistrictUpdateSqlQuery">
      <Text>
        UPDATE
          collect.address_district
        SET
          title = {Title}
        WHERE
          address_district_id = {AddressDistrictId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressDistrictArchiveSqlQuery">
      <Text>
        UPDATE
          collect.address_district A
        SET
          archive = NOT T.archive
        FROM (
          SELECT
            unnest({AddressDistrictId}::bigint[]) AS address_district_id,
            unnest({Archive}::boolean[]) AS archive
        ) T
        WHERE
          A.address_district_id = T.address_district_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressDistrictDeleteSqlQuery">
      <Text>
        SELECT collect.address_district_try_delete({AddressDistrictId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressDistrictMergeSqlQuery">
      <Text>
        SELECT collect.address_district_merge({MergeAddressDistrictIds}::bigint[], {AddressDistrictId}::bigint, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <!-- типы городов -->
    <SqlQuery Name="AddressCityTypeSelectSqlQuery">
      <Text>
        SELECT
          address_city_type_id AS "AddressCityTypeId",
          title AS "Title"
        FROM
          collect.address_city_type;
      </Text>
    </SqlQuery>

    <!-- города -->
    <SqlQuery Name="AddressCitySelectSqlQuery">
      <Text>
        SELECT
          address_city_id AS "AddressCityId",
          title AS "Title",
          archive AS "Archive"
        FROM
          collect.address_city
        ORDER BY title, address_city_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressCityByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title"
        FROM
          collect.address_city
        WHERE
          address_city_id = {AddressCityId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressCityInsertSqlQuery">
      <Text>
        INSERT INTO collect.address_city(title)
        VALUES({Title})
        RETURNING address_city_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressCityUpdateSqlQuery">
      <Text>
        UPDATE
          collect.address_city
        SET
          title = {Title}
        WHERE
          address_city_id = {AddressCityId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressCityArchiveSqlQuery">
      <Text>
        UPDATE
          collect.address_city A
        SET
          archive = NOT T.archive
        FROM (
          SELECT
            unnest({AddressCityId}::bigint[]) AS address_city_id,
            unnest({Archive}::boolean[]) AS archive
        ) T
        WHERE
          A.address_city_id = T.address_city_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressCityDeleteSqlQuery">
      <Text>
        SELECT collect.address_city_try_delete({AddressCityId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressCityMergeSqlQuery">
      <Text>
        SELECT collect.address_city_merge({MergeAddressCityIds}::bigint[], {AddressCityId}::bigint, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <!-- типы улиц -->
    <SqlQuery Name="AddressStreetTypeSelectSqlQuery">
      <Text>
        SELECT
          address_street_type_id AS "AddressStreetTypeId",
          title AS "Title"
        FROM
          collect.address_street_type;
      </Text>
    </SqlQuery>

    <!-- улицы -->
    <SqlQuery Name="AddressStreetSelectSqlQuery">
      <Text>
        SELECT
          address_street_id AS "AddressStreetId",
          title AS "Title",
          archive AS "Archive"
        FROM
          collect.address_street
        ORDER BY title, address_street_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressStreetByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title"
        FROM
          collect.address_street
        WHERE
          address_street_id = {AddressStreetId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressStreetInsertSqlQuery">
      <Text>
        INSERT INTO collect.address_street(title)
        VALUES({Title})
        RETURNING address_street_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressStreetUpdateSqlQuery">
      <Text>
        UPDATE
          collect.address_street
        SET
          title = {Title}
        WHERE
          address_street_id = {AddressStreetId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressStreetArchiveSqlQuery">
      <Text>
        UPDATE
          collect.address_street A
        SET
          archive = NOT T.archive
        FROM (
          SELECT
            unnest({AddressStreetId}::bigint[]) AS address_street_id,
            unnest({Archive}::boolean[]) AS archive
        ) T
        WHERE
          A.address_street_id = T.address_street_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressStreetDeleteSqlQuery">
      <Text>
        SELECT collect.address_street_try_delete({AddressStreetId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressStreetMergeSqlQuery">
      <Text>
        SELECT collect.address_street_merge({MergeAddressStreetIds}::bigint[], {AddressStreetId}::bigint, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="OspByAddressSelectSqlQuery">
      <Text>
        SELECT
          O.osp_id AS "OspId",
          O.title AS "OspTitle"
        FROM
          collect.osp_address OA
          JOIN collect.osp O USING(osp_id)
          JOIN collect.address A USING(address_id)
          LEFT JOIN collect.get_address_string(address_id) GAS USING(address_id)
        WHERE
          similarity(CASE WHEN COALESCE(A.address_string,'') = '' THEN GAS.address_string ELSE A.address_string END, {Address}) IS NOT DISTINCT FROM 1;
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===СПИСОК СУДОВ=============================================-->
    <!--============================================================-->
    <SqlQuery Name="CourtSelectSqlQuery">
      <Text>
        SELECT
          court_id AS "CourtId",
          court.title AS "Title",
          address AS "Address",
          address_region_id AS "AddressRegionId",
          address_region.title AS "AddressRegionTitle",
          archive AS "Archive"
        FROM
          collect.court
          LEFT JOIN collect.address_region USING(address_region_id)
        ORDER BY court.title, court_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="CourtSimpleSelectSqlQuery">
      <Text>
        SELECT
          court_id AS "CourtId",
          court.title AS "Title",
          address AS "Address",
          archive AS "Archive"
        FROM
          collect.court
        ORDER BY court.title, court_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="CourtByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title",
          title_genitive AS "TitleGenitive",
          address AS "Address",
          address_region_id AS "AddressRegionId",
          receiver AS "Receiver",
          receiver_bank AS "ReceiverBank",
          receiver_bank_city AS "ReceiverBankCity",
          inn AS "INN",
          kpp AS "KPP",
          correspondent_account AS "CorrespondentAccount",
          account AS "Account",
          bik AS "BIK",
          oktmo AS "OKTMO",
          kbk AS "KBK",
          phone AS "Phone",
          email AS "Email",
          site AS "Site"
        FROM
          collect.court
        WHERE
          court_id = {CourtId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="CourtByClientIdSelectSqlQuery">
      <Text>
        SELECT
          court_id AS "CourtId",
          title AS "Title",
          address AS "Address",
          archive AS "Archive",
          client_id AS "ClientId"
        FROM
          collect.court
          LEFT JOIN (
            SELECT
              court_id,
              client_id,
              bool_or(collect.address_match(court_address.address_id, client_address.address_id)) AS address_match
            FROM
              collect.court_address,
              collect.client_address
              JOIN collect.address_type AT USING(address_type_id)
            WHERE
              client_id = ANY({ClientIds}::bigint[]) AND AT.title = 'Регистрация'
            GROUP BY court_id, client_id
          ) T USING(court_id)
        ORDER BY COALESCE(address_match, false) DESC, title, court_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="CourtSaveSqlQuery">
      <Text>
        SELECT collect.court_save({Model}::json, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="CourtArchiveSqlQuery">
      <Text>
        UPDATE
          collect.court C
        SET
          archive = NOT T.archive
        FROM (
          SELECT
            unnest({CourtId}::bigint[]) AS court_id,
            unnest({Archive}::boolean[]) AS archive
        ) T
        WHERE
          C.court_id = T.court_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="CourtDeleteSqlQuery">
      <Text>
        SELECT collect.court_try_delete({CourtId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="CourtMergeSqlQuery">
      <Text>
        SELECT collect.court_merge({MergeCourtIds}::bigint[], {CourtId}::bigint, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <!-- адреса суда -->
    <SqlQuery Name="CourtAddressByCourtIdSelectSqlQuery">
      <Text>
        SELECT
          A.address_id AS "AddressId",
          CASE WHEN COALESCE(A.address_string,'') = '' THEN ADR.address_string ELSE A.address_string END AS "Address",
          A.address_string AS "AddressString",
          A.address_index AS "AddressIndex",
          A.address_region_id AS "AddressRegionId",
          A.address_district_id AS "AddressDistrictId",
          A.address_city_district AS "AddressCityDistrict",
          A.address_city_type_id AS "AddressCityTypeId",
          A.address_city_id AS "AddressCityId",
          A.address_street_type_id AS "AddressStreetTypeId",
          A.address_street_id AS "AddressStreetId",
          A.address_building AS "AddressBuilding",
          A.address_block AS "AddressBlock",
          A.address_structure AS "AddressStructure",
          A.address_flat AS "AddressFlat"
        FROM
          collect.court_address CA
          JOIN collect.address A USING(address_id)
          LEFT JOIN collect.get_address_string(p_court_id => {CourtId}::bigint) ADR USING(address_id)
        WHERE
          court_id = {CourtId}
        ORDER BY A.address_id;
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===СПИСОК ОСП===============================================-->
    <!--============================================================-->
    <SqlQuery Name="OspSelectSqlQuery">
      <Text>
        SELECT
          osp_id AS "OspId",
          title AS "Title",
          address AS "Address",
          ufssp_title AS "UfsspTitle",
          archive AS "Archive"
        FROM
          collect.osp
        ORDER BY osp.title, osp_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="OspByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title",
          address AS "Address",
          ufssp_title AS "UfsspTitle",
          phone AS "Phone"
        FROM
          collect.osp
        WHERE
          osp_id = {OspId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="OspByClientIdSelectSqlQuery">
      <Text>
        SELECT
          osp_id AS "OspId",
          title AS "Title",
          address AS "Address",
          ufssp_title AS "UfsspTitle",
          archive AS "Archive",
          client_id AS "ClientId"
        FROM
          collect.osp
          LEFT JOIN (
            SELECT
              osp_id,
              client_id,
              bool_or(collect.address_match(osp_address.address_id, client_address.address_id)) AS address_match
            FROM
              collect.osp_address,
              collect.client_address
              JOIN collect.address_type AT USING(address_type_id)
            WHERE
              client_id = ANY({ClientIds}::bigint[]) AND AT.title = 'Регистрация'
            GROUP BY osp_id, client_id
          ) T USING(osp_id)
        ORDER BY COALESCE(address_match, false) DESC, title, osp_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="OspSaveSqlQuery">
      <Text>
        SELECT collect.osp_save({Model}::json, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="OspArchiveSqlQuery">
      <Text>
        UPDATE
          collect.osp O
        SET
          archive = NOT T.archive
        FROM (
          SELECT
            unnest({OspId}::bigint[]) AS osp_id,
            unnest({Archive}::boolean[]) AS archive
        ) T
        WHERE
          O.osp_id = T.osp_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="OspDeleteSqlQuery">
      <Text>
        SELECT collect.osp_try_delete({OspId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="OspMergeSqlQuery">
      <Text>
        SELECT collect.osp_merge({MergeOspIds}::bigint[], {OspId}::bigint, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <!-- адреса ОСП -->
    <SqlQuery Name="OspAddressByOspIdSelectSqlQuery">
      <Text>
        SELECT
          OA.address_id AS "AddressId",
          CASE WHEN COALESCE(A.address_string,'') = '' THEN ADR.address_string ELSE A.address_string END AS "Address",
          A.address_string AS "AddressString",
          A.address_index AS "AddressIndex",
          A.address_region_id AS "AddressRegionId",
          A.address_district_id AS "AddressDistrictId",
          A.address_city_district AS "AddressCityDistrict",
          A.address_city_type_id AS "AddressCityTypeId",
          A.address_city_id AS "AddressCityId",
          A.address_street_type_id AS "AddressStreetTypeId",
          A.address_street_id AS "AddressStreetId",
          A.address_building AS "AddressBuilding",
          A.address_block AS "AddressBlock",
          A.address_structure AS "AddressStructure",
          A.address_flat AS "AddressFlat"
        FROM
          collect.osp_address OA
          JOIN collect.address A USING(address_id)
          LEFT JOIN collect.get_address_string(p_osp_id => {OspId}::bigint) ADR USING(address_id)
        WHERE
          osp_id = {OspId}
        ORDER BY OA.address_id;
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===ТИПЫ ДЕЙСТВИЙ============================================-->
    <!--============================================================-->
    <SqlQuery Name="TaskTypeSelectSqlQuery">
      <Text>
        SELECT
          task_type_id AS "TaskTypeId",
          title AS "Title",
          archive AS "Archive"
        FROM
          collect.task_type
        ORDER BY title, task_type_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TaskTypeByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title"
        FROM
          collect.task_type
        WHERE
          task_type_id = {TaskTypeId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="TaskTypeInsertSqlQuery">
      <Text>
        INSERT INTO collect.task_type(title)
        VALUES({Title})
        RETURNING task_type_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TaskTypeUpdateSqlQuery">
      <Text>
        UPDATE
          collect.task_type
        SET
          title = {Title}
        WHERE
          task_type_id = {TaskTypeId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="TaskTypeArchiveSqlQuery">
      <Text>
        UPDATE
          collect.task_type
        SET
          archive = {Archive}
        WHERE
          task_type_id = {TaskTypeId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="TaskTypeDeleteSqlQuery">
      <Text>
        SELECT collect.task_type_try_delete({TaskTypeId});
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===ТИПЫ ЗАЯВЛЕНИЙ============================================-->
    <!--============================================================-->
    <SqlQuery Name="ApplicationTypeSelectSqlQuery">
      <Text>
        SELECT
          application_type_id AS "ApplicationTypeId",
          title AS "Title",
          archive AS "Archive"
        FROM
          collect.application_type
        ORDER BY title;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ApplicationTypeTaxSelectSqlQuery">
      <Text>
        SELECT
          application_type_tax_id AS "ApplicationTypeTaxId",
          application_type_id AS "ApplicationTypeId",
          sum_min AS "SumMin",
          sum_max AS "SumMax",
          min_tax AS "MinTax",
          percent_for_sum_above_min AS "Percent"
        FROM
          collect.application_type_tax
        ORDER BY sum_min, min_tax, percent_for_sum_above_min;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ApplicationTypeByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title"
        FROM
          collect.application_type
        WHERE
          application_type_id = {ApplicationTypeId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ApplicationTypeTaxByApplicationTypeIdSelectSqlQuery">
      <Text>
        SELECT
          application_type_tax_id AS "ApplicationTypeTaxId",
          application_type_id AS "ApplicationTypeId",
          sum_min AS "SumMin",
          sum_max AS "SumMax",
          min_tax AS "MinTax",
          percent_for_sum_above_min AS "Percent"
        FROM
          collect.application_type_tax
        WHERE
          application_type_id = {ApplicationTypeId}
        ORDER BY sum_max;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ApplicationTypeSaveSqlQuery">
      <Text>
        SELECT collect.application_type_save({Model}::json);
      </Text>
    </SqlQuery>

    <SqlQuery Name="ApplicationTypeArchiveSqlQuery">
      <Text>
        UPDATE
          collect.application_type
        SET
          archive = {Archive}
        WHERE
          application_type_id = {ApplicationTypeId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ApplicationTypeDeleteSqlQuery">
      <Text>
        SELECT collect.application_type_try_delete({ApplicationTypeId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="ApplicationTypeMergeSqlQuery">
      <Text>
        SELECT collect.application_type_merge({MergeApplicationTypeIds}::integer[], {ApplicationTypeId}::integer, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===ДОЛЖНИКИ=================================================-->
    <!--============================================================-->
    <SqlQuery Name="ClientSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids,
            (SELECT list_client FROM collect.user_info WHERE user_id = {UserId}) AS list_client
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}
        ), loan_users AS (
          SELECT
            loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client
          WHERE
            user_id IS NOT NULL
          GROUP BY loan_id
        ), allowed_client AS (
          SELECT
            DISTINCT client_id
          FROM
            collect.client
            LEFT JOIN collect.loan_client USING(client_id)
            LEFT JOIN loan_users LU USING(loan_id)
            LEFT JOIN current_user_info CUI ON true
          WHERE
            (NOT (list_client = 'none') AND
            (list_client = 'full' OR
            (list_client = 'partial' AND
            (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
            {UserId} = ANY(LU.user_ids))))
        ), filtered_client AS (
          SELECT
            client_id
          FROM
            collect.filtered_client({SearchString}::character varying)
        ), S AS (
          SELECT
            C.client_id,
            collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "ClientTitle"
          FROM
            collect.client C
            LEFT JOIN collect.client_person CP USING(client_id)
            JOIN allowed_client AC USING(client_id)
            JOIN filtered_client FC USING(client_id)
          WHERE
            NOT C.deleted AND
            (C.archive = {Archive}::boolean OR {Archive} IS NULL) AND
            ({ExcludeClientIds}::bigint[] = ARRAY[NULL]::bigint[] OR C.client_id != ALL({ExcludeClientIds}::bigint[]))
          ORDER BY "ClientTitle", client_id
        ), R AS (
          SELECT
            count(*) AS total_rows,
            COALESCE(CEIL(count(*)::numeric/GREATEST(COALESCE({RowsPerPage}, count(*))::numeric, 1)), 1) AS total_pages
          FROM
            S
        ), final AS (
          SELECT
            row_number() over() AS "RowNumber",
            (SELECT R.total_rows FROM R) AS "TotalRows",
            (SELECT R.total_pages FROM R) AS "TotalPages",
            *
          FROM
            S
          LIMIT COALESCE({RowsPerPage}, (SELECT R.total_rows FROM R))
          OFFSET (GREATEST((LEAST((SELECT R.total_pages FROM R), COALESCE({CurrentPage}, 1)) - 1)::integer, 0) * COALESCE({RowsPerPage}, (SELECT R.total_rows FROM R)))
        ), phones AS (
          SELECT
            client_id,
            string_agg(phone_number, E';\r\n') AS pnones
          FROM
            final F
            LEFT JOIN collect.client_phone USING(client_id)
          GROUP BY client_id
        ), registration_address AS (
          SELECT
            DISTINCT ON (F.client_id)
            F.client_id,
            CA.address_id,
            A.address_string
          FROM
            final F
            LEFT JOIN collect.client_address CA USING(client_id)
            LEFT JOIN collect.address A USING(address_id)
            LEFT JOIN collect.address_type ATP USING (address_type_id)
          WHERE
            ATP.title = 'Регистрация'
          ORDER BY F.client_id, CA.address_id DESC
        ), all_address AS (
          SELECT
            DISTINCT ON (GAS.address_id)
            GAS.address_id,
            GAS.address_string
          FROM
            final F
            LEFT JOIN collect.get_address_string() GAS USING(client_id)
        ), client_registration_address AS (
          SELECT
            RA.client_id,
            CASE
              WHEN COALESCE(RA.address_string, '') = '' THEN GAS.address_string
              ELSE RA.address_string
            END AS registration_address
          FROM
            registration_address RA
            LEFT JOIN all_address GAS USING (address_id)
        ), passport_info AS (
          SELECT
            CP.client_id,
            CASE
              WHEN COALESCE(CP.passport_series, '') = '' THEN '—'::character varying
              ELSE CP.passport_series
            END AS passport_series,
            CASE
              WHEN COALESCE(CP.passport_number, '') = '' THEN '—'::character varying
              ELSE CP.passport_number
            END AS passport_number,
            CASE
              WHEN COALESCE(CP.passport_given_by, '') = '' THEN '—'::character varying
              ELSE CP.passport_given_by
            END AS passport_given_by,
            COALESCE(to_char(CP.passport_given_date, 'dd.MM.yyyy'), '—') AS passport_given_date
          FROM
            final F
            LEFT JOIN collect.client_person CP USING(client_id)
        )
        SELECT
          F."RowNumber",
          F."TotalRows",
          F."TotalPages",
          F.client_id AS "ClientId",
          F."ClientTitle",
          'Серия: ' || PI.passport_series || ', номер: ' || PI.passport_number || ', выдан: ' || PI.passport_given_by || ', дата выдачи: ' || PI.passport_given_date AS "ClientFullPassport",
          CP.birth_date AS "ClientBirthDate",
          P.pnones AS "ClientPhones",
          CRA.registration_address AS "ClientRegistrationAddress",
          C.archive AS "Archive"
        FROM
          final F
          LEFT JOIN collect.client C USING(client_id)
          LEFT JOIN collect.client_person CP USING(client_id)
          LEFT JOIN client_registration_address CRA USING(client_id)
          LEFT JOIN phones P USING(client_id)
          LEFT JOIN passport_info PI USING(client_id)
        ORDER BY F."RowNumber";
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientSimpleSelectSqlQuery">
      <Text>
        SELECT
          client_id AS "ClientId",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "Title",
          archive AS "Archive"
        FROM
          collect.client
          LEFT JOIN collect.client_person CP USING(client_id)
        WHERE
          NOT deleted
        ORDER BY "Title";
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientByIdSelectSqlQuery">
      <Text>
        SELECT
          first_name AS "FirstName",
          second_name AS "SecondName",
          third_name AS "ThirdName",
          gender AS "Gender",
          birth_date AS "BirthDate",
          birth_place AS "BirthPlace",
          passport_series AS "PassportSeries",
          passport_number AS "PassportNumber",
          passport_given_by AS "PassportGivenBy",
          passport_given_date AS "PassportGivenDate",
          passport_code AS "PassportCode",
          passport_loaded AS "PassportLoaded",
          inn AS "Inn",
          is_special_tax_regime AS "IsSpecialTaxRegime",
          snils AS "Snils",
          email AS "Email",
          work_company_title AS "WorkCompanyTitle",
          work_post AS "WorkPost",
          work_salary AS "WorkSalary",
          work_hired_date AS "WorkHiredDate",
          work_fired_date AS "WorkFiredDate",
          address_region_id AS "AddressRegionId"
        FROM
          collect.client_person
        WHERE
          client_id = {ClientId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanClientStatsSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), loan_users AS (
          SELECT
            loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client
          WHERE
            user_id IS NOT NULL AND
            client_id = {ClientId}
          GROUP BY loan_id
        ), loan_client_payment AS (
          SELECT
            LC.loan_client_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            collect.loan_client LC
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_id)
          WHERE
            LC.client_id = {ClientId}
          GROUP BY LC.loan_client_id
        ), loan_client_repayment_payment AS (
          SELECT
            LC.loan_client_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            collect.loan_client LC
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_id)
          WHERE
            LC.client_id = {ClientId} AND
            LCP.date >= LC.repayment_date
          GROUP BY LC.loan_client_id
        ), loan_client_info AS (
          SELECT
            LC.loan_client_id,
            CASE
              WHEN LC.repayment_date IS NULL THEN COALESCE(LC.debt_base, 0) + COALESCE(LC.debt_percent, 0) + COALESCE(LC.debt_penalty, 0) + COALESCE(LC.debt_tax, 0)
              ELSE COALESCE(LC.repayment_sum, 0)
            END AS total_debt_sum,
            CASE
              WHEN LC.repayment_date IS NULL THEN COALESCE(P.total_payment_sum, 0)
              ELSE COALESCE(RP.total_payment_sum, 0)
            END AS total_payment_sum,
            CASE
              WHEN LC.repayment_date IS NULL THEN GREATEST(COALESCE(LC.debt_base, 0) + COALESCE(LC.debt_percent, 0) + COALESCE(LC.debt_penalty, 0) + COALESCE(LC.debt_tax, 0) - COALESCE(P.total_payment_sum, 0), 0)
              ELSE GREATEST(COALESCE(LC.repayment_sum, 0) - COALESCE(RP.total_payment_sum, 0), 0)
            END AS total_debt_rest_sum
          FROM
            collect.loan_client LC
            LEFT JOIN loan_client_payment P USING (loan_client_id)
            LEFT JOIN loan_client_repayment_payment RP USING (loan_client_id)
          WHERE
            LC.client_id = {ClientId}
        )
        SELECT
          count(L.loan_id) AS "LoanTotalCount",
          SUM(CASE WHEN LCI.total_debt_rest_sum = 0 AND LCI.total_debt_sum > 0 THEN 1 ELSE 0 END) AS "PayedLoanTotalCount",
          SUM(LCI.total_debt_sum) AS "TotalDebtSum",
          SUM(LCI.total_payment_sum) AS "TotalPaymentSum",
          SUM(LCI.total_debt_rest_sum) AS "TotalDebtRestSum"
        FROM
          collect.client_person CP
          LEFT JOIN collect.loan_client LC USING(client_id)
          JOIN collect.loan L USING(loan_id)
          LEFT JOIN loan_users LU USING(loan_id)
          LEFT JOIN loan_client_info LCI USING(loan_client_id)
          LEFT JOIN current_user_info CUI ON true
        WHERE
          {ClientId} IS NOT NULL AND
          CP.client_id = {ClientId} AND
          NOT L.deleted AND
          NOT L.archive AND
          (CUI.user_is_administrator OR
          (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
          {UserId} = ANY(LU.user_ids));
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanClientByClientIdSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), loan_client_main AS (
          SELECT
            L.loan_id,
            LC.client_id
          FROM
            collect.loan L
            JOIN collect.loan_client LC USING(loan_id)
          WHERE
            NOT L.deleted AND
            NOT L.archive AND
            LC.is_main
        ), loan_users AS (
          SELECT
            loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client
          WHERE
            user_id IS NOT NULL
          GROUP BY loan_id
        ), loan_client_payment AS (
          SELECT
            LC.loan_client_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            collect.loan_client LC
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_id)
          WHERE
            LC.client_id = {ClientId}
          GROUP BY LC.loan_client_id
        ), loan_client_repayment_payment AS (
          SELECT
            LC.loan_client_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            collect.loan_client LC
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_id)
          WHERE
            LC.client_id = {ClientId} AND
            LCP.date >= LC.repayment_date
          GROUP BY LC.loan_client_id
        ), loan_client_info AS (
          SELECT
            LC.loan_client_id,
            CASE
              WHEN LC.repayment_date IS NULL THEN COALESCE(LC.debt_base, 0) + COALESCE(LC.debt_percent, 0) + COALESCE(LC.debt_penalty, 0) + COALESCE(LC.debt_tax, 0)
              ELSE COALESCE(LC.repayment_sum, 0)
            END AS total_debt_sum,
            CASE
              WHEN LC.repayment_date IS NULL THEN COALESCE(P.total_payment_sum, 0)
              ELSE COALESCE(RP.total_payment_sum, 0)
            END AS total_payment_sum,
            CASE
              WHEN LC.repayment_date IS NULL THEN GREATEST(COALESCE(LC.debt_base, 0) + COALESCE(LC.debt_percent, 0) + COALESCE(LC.debt_penalty, 0) + COALESCE(LC.debt_tax, 0) - COALESCE(P.total_payment_sum, 0), 0)
              ELSE GREATEST(COALESCE(LC.repayment_sum, 0) - COALESCE(RP.total_payment_sum, 0), 0)
            END AS total_debt_rest_sum
          FROM
            collect.loan_client LC
            LEFT JOIN loan_client_payment P USING (loan_client_id)
            LEFT JOIN loan_client_repayment_payment RP USING (loan_client_id)
          WHERE
            LC.client_id = {ClientId}
        )
        SELECT
          LC.loan_client_id AS "LoanClientId",
          LC.loan_id AS "LoanId",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "MainLoanClientTitle",
          L.credit_number AS "CreditNumber",
          L.credit_date AS "CreditDate",
          R.title AS "RoleTitle",
          LC.surety_number AS "SuretyNumber",
          LCI.total_debt_rest_sum AS "TotalDebtRestSum",
          S.title AS "StatusTitle",
          CL.short_title AS "ClaimantTitle",
          LCI.total_debt_sum AS "TotalDebtSum",
          LCI.total_payment_sum AS "TotalPaymentSum",
          UI.user_full_name AS "UserTitle",
          L.create_date AS "CreateDate"
        FROM
          collect.loan_client LC
          JOIN collect.loan L USING(loan_id)
          LEFT JOIN loan_users LU USING(loan_id)
          LEFT JOIN loan_client_main LCM USING(loan_id)
          LEFT JOIN collect.client_person CP ON CP.client_id = LCM.client_id
          LEFT JOIN collect.role R USING(role_id)
          LEFT JOIN loan_client_info LCI USING(loan_client_id)
          LEFT JOIN collect.status S USING(status_id)
          LEFT JOIN collect.cession C USING(cession_id)
          LEFT JOIN collect.claimant CL USING(claimant_id)
          LEFT JOIN collect.user_info UI USING(user_id)
          LEFT JOIN current_user_info CUI ON true
        WHERE
          NOT L.deleted AND
          NOT L.archive AND
          {ClientId} IS NOT NULL AND
          LC.client_id = {ClientId} AND
          (CUI.user_is_administrator OR
          (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
          {UserId} = ANY(LU.user_ids))
        ORDER BY LC.loan_id, LC.loan_client_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="CommentByClientIdSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), loan_users AS (
          SELECT
            loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client
          WHERE
            user_id IS NOT NULL AND
            client_id = {ClientId}
          GROUP BY loan_id
        )
        SELECT
          LC.loan_comment_id AS "LoanCommentId",
          LC.create_date AS "CreateDate",
          UI.user_full_name AS "EditUserTitle",
          L.credit_number AS "CreditNumber",
          LC.comment AS "Comment",
          COALESCE(LCF.file_count, 0) > 0 AS "FileExists"
        FROM
          collect.loan_comment LC
          LEFT JOIN current_user_info CUI ON true
          LEFT JOIN collect.loan_client LCL ON LCL.loan_id = LC.loan_id OR LCL.loan_client_id = LC.loan_client_id
          LEFT JOIN collect.loan L ON L.loan_id = LCL.loan_id
          LEFT JOIN loan_users LU ON L.loan_id = LU.loan_id
          LEFT JOIN collect.user_info UI ON UI.user_id = LC.edit_user_id
          LEFT JOIN (
            SELECT
              LCF.loan_comment_id,
              count(loan_comment_file_id) AS file_count
            FROM
              collect.loan_comment_file LCF
            GROUP BY loan_comment_id
          ) LCF USING(loan_comment_id)
        WHERE
          {ClientId} IS NOT NULL AND
          LCL.client_id = {ClientId} AND
          NOT L.deleted AND
          NOT L.archive AND
          (CUI.user_is_administrator OR
          (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
          {UserId} = ANY(LU.user_ids))
        ORDER BY LC.create_date DESC, LC.loan_comment_id DESC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientFileByClientIdSelectSqlQuery">
      <Text>
        SELECT
          CF.client_file_id AS "ClientFileId",
          CF.create_date AS "CreateDate",
          UI.user_full_name AS "EditUserTitle",
          substr(F.path, length(F.path) - strpos(reverse(F.path),'\') + 2) AS "FileName",
          F.guid AS "Guid",
          CF.description AS "Description"
        FROM
          collect.client_file CF
          JOIN public.file F USING(file_id)
          JOIN collect.user_info UI ON UI.user_id = CF.edit_user_id
        WHERE
          CF.client_id = {ClientId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientArchiveSqlQuery">
      <Text>
        UPDATE
          collect.client
        SET
          archive = {Archive}
        WHERE
          client_id = {ClientId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientEditDateSelectSqlQuery">
      <Text>
        SELECT
          COALESCE((
            SELECT
              edit_date AS "EditDate"
            FROM
              collect.client
            WHERE
              client_id = {ClientId}
          ), 'infinity')::character varying AS "EditDate";
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientCheckBeforeSaveSelectSqlQuery">
      <Text>
        SELECT
          {FormEditDate}::timestamp != COALESCE((SELECT edit_date FROM collect.client WHERE client_id = {ClientId} AND {ClientId} IS NOT NULL), 'infinity'::timestamp) AS "ClientChanged",
          (SELECT user_full_name FROM collect.client C LEFT JOIN collect.user_info UI ON C.edit_user_id = UI.user_id WHERE client_id = {ClientId}) AS "UserTitle";
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientSaveSqlQuery">
      <Text>
        SELECT collect.client_save({Model}::json, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientDeleteSqlQuery">
      <Text>
        SELECT collect.client_try_delete({ClientId});
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientDuplicateGuidSelectSqlQuery">
      <Text>
        SELECT
          DISTINCT guid AS "Guid"
        FROM (
          SELECT
            guid
          FROM
            collect.client_photo CP
            JOIN public.file F USING(file_id)
          GROUP BY file_id, guid
          HAVING
            count(*) > 1 AND
            ({ClientId} IS NOT NULL AND {ClientId} = ANY(array_agg(client_id)))

          UNION ALL

          SELECT
            guid
          FROM
            collect.client_file CF
            JOIN public.file F USING(file_id)
          GROUP BY file_id, guid
          HAVING
            count(*) > 1 AND
            ({ClientId} IS NOT NULL AND {ClientId} = ANY(array_agg(client_id)))
       ) A;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientCheckBeforeMergeSqlQuery">
      <Text>
        SELECT
          DISTINCT ON (loan_id)
          '№ ' || COALESCE(L.credit_number,'') AS "CreditNumber"
        FROM
          collect.loan_client LC
          JOIN collect.loan L USING(loan_id)
        WHERE
          client_id = {ClientId} AND
          EXISTS (SELECT 1 FROM collect.loan_client LCM WHERE client_id = {MergeClientId} AND loan_id = LC.loan_id);
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientMergeSqlQuery">
      <Text>
        SELECT collect.client_merge({MergeClientId}::bigint, {ClientId}::bigint, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientPhotoSelectSqlQuery">
      <Text>
        SELECT
          CP.client_photo_id AS "ClientPhotoId",
          CP.file_id AS "FileId",
          CP.is_main AS "IsMain",
          PF.guid AS "Guid",
          'guid://' || PF.guid AS "GuidPath"
        FROM
          collect.client_photo CP
          LEFT JOIN public.file PF USING (file_id)
        WHERE
          CP.client_id = {ClientId}
        ORDER BY CP.is_main DESC, CP.client_photo_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="HistoryByClientIdSelectSqlQuery">
      <Text>
        SELECT
          H.out_history_id AS "HistoryId",
          H.out_loan_id AS "LoanId",
          H.out_user_id AS "UserId",
          UI.user_full_name AS "AuthorTitle",
          H.out_history_date AS "HistoryDate",
          H.out_text AS "HistoryText"
        FROM
          collect.get_history({ClientId}::bigint, NULL::bigint, {FilterTable}::character varying[]) H
          LEFT JOIN collect.user_info UI ON UI.user_id = H.out_user_id
        WHERE
          {ClientId} IS NOT NULL
        ORDER BY H.out_history_date DESC, H.out_history_id DESC;
      </Text>
    </SqlQuery>

    <!-- телефоны -->
    <SqlQuery Name="PhoneTypeSelectSqlQuery">
      <Text>
        SELECT
          phone_type_id AS "PhoneTypeId",
          title AS "Title"
        FROM
          collect.phone_type
        ORDER BY phone_type_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ContactPersonTypeSelectSqlQuery">
      <Text>
        SELECT
          contact_person_type_id AS "ContactPersonTypeId",
          title AS "Title"
        FROM
          collect.contact_person_type
        ORDER BY contact_person_type_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientPhoneByClientIdSelectSqlQuery">
      <Text>
        SELECT
          client_phone_id AS "ClientPhoneId",
          phone_number AS "PhoneNumber",
          P.phone_type_id AS "PhoneTypeId",
          phone_type AS "PhoneType",
          CASE WHEN PT.title = 'Другой' AND COALESCE(phone_type,'') != '' THEN phone_type ELSE PT.title END AS "PhoneTypeTitle",
          P.contact_person_type_id AS "ContactPersonTypeId",
          contact_person_type AS "ContactPersonType",
          CASE WHEN CPT.title = 'Другой' AND COALESCE(contact_person_type,'') != '' THEN contact_person_type ELSE CPT.title END AS "ContactPersonTypeTitle",
          contact_person AS "ContactPerson",
          P.comment AS "Comment",
          is_main AS "IsMain"
        FROM
          collect.client_phone P
          LEFT JOIN collect.phone_type PT USING(phone_type_id)
          LEFT JOIN collect.contact_person_type CPT USING(contact_person_type_id)
        WHERE
          client_id = {ClientId};
      </Text>
    </SqlQuery>

    <!-- банк. счета должника -->
    <SqlQuery Name="ClientAccountByClientIdSelectSqlQuery">
      <Text>
        SELECT
          client_account_id AS "ClientAccountId",
          bank_title AS "BankTitle",
          bank_requisite AS "BankRequisite",
          account AS "Account",
          description AS "Description",
          arrest_date AS "ArrestDate",
          is_salary_account AS "IsSalaryAccount"
        FROM
          collect.client_account
        WHERE
          client_id = {ClientId};
      </Text>
    </SqlQuery>

    <!--имущество должника -->
    <SqlQuery Name="SellResultSelectSqlQuery">
      <Text>
        SELECT
          sell_result_id AS "SellResultId",
          title AS "Title"
        FROM
          collect.sell_result;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientPropertyByClientIdSelectSqlQuery">
      <Text>
       SELECT
          CP.client_property_id AS "ClientPropertyId",
          CASE
            WHEN CPM.client_property_id IS NOT NULL THEN 'Движимое имущество'
            WHEN CPR.client_property_id IS NOT NULL THEN 'Недвижимость'
            WHEN CPC.client_property_id IS NOT NULL THEN 'Доля в ООО / ИП'
            ELSE NULL::character varying
          END AS "PropertyType",
          CP.title AS "PropertyTitle",
          CP.price AS "PropertyPrice",
          CP.share AS "PropertyShare",
          CP.is_pledged AS "PropertyIsPledged",
          CP.pledge_date AS "PropertyPledgeDate",
          CP.pledge_price AS "PropertyPledgePrice",
          CP.description AS "PropertyDescription",
          CPM.model AS "PropertyMovableModel",
          CPM.year AS "PropertyMovableYear",
          CPM.buy_date AS "PropertyMovableBuyDate",
          CPM.number AS "PropertyMovableNumber",
          CPM.color AS "PropertyMovableColor",
          CPM.vin AS "PropertyMovableVin",
          CPM.ban_raise_date AS "PropertyMovableBanRaiseDate",
          CPM.ban_result_date AS "PropertyMovableBanResultDate",
          CPM.unban_date AS "PropertyMovableUnBanDate",
          CPM.ban_result AS "PropertyMovableBanResult",
          CPM.arrest_raise_date AS "PropertyMovableArrestRaiseDate",
          CPM.arrest_result_date AS "PropertyMovableArrestResultDate",
          CPM.unarrest_date AS "PropertyMovableUnArrestDate",
          CPM.arrest_result AS "PropertyMovableArrestResult",
          CPM.wanted_raise_date AS "PropertyMovableWantedRaiseDate",
          CPM.wanted_result_date AS "PropertyMovableWantedResultDate",
          CPM.unwanted_date AS "PropertyMovableUnWantedDate",
          CPM.wanted_result AS "PropertyMovableWantedResult",
          CPM.sell_date AS "PropertyMovableSellDate",
          CPM.sell_result_id AS "PropertyMovableSellResultId",
          CPR.address AS "PropertyRealAddress",
          CPR.cadastral_number AS "PropertyRealCadastralNumber",
          CPR.cadastral_price AS "PropertyRealCadastralPrice",
          CPR.area AS "PropertyRealArea",
          CPR.ban_raise_date AS "PropertyRealBanRaiseDate",
          CPR.ban_result_date AS "PropertyRealBanResultDate",
          CPR.unban_date AS "PropertyRealUnBanDate",
          CPR.ban_result AS "PropertyRealBanResult",
          CPR.arrest_raise_date AS "PropertyRealArrestRaiseDate",
          CPR.arrest_result_date AS "PropertyRealArrestResultDate",
          CPR.unarrest_date AS "PropertyRealUnArrestDate",
          CPR.arrest_result AS "PropertyRealArrestResult",
          CPR.sell_date AS "PropertyRealSellDate",
          CPR.sell_result_id AS "PropertyRealSellResultId",
          CPC.inn AS "PropertyCompanyInn",
          CPC.title AS "PropertyCompanyTitle",
          CPC.address AS "PropertyCompanyAddress",
          CPC.contact AS "PropertyCompanyContact",
          CPC.ban_raise_date AS "PropertyCompanyBanRaiseDate",
          CPC.ban_result_date AS "PropertyCompanyBanResultDate",
          CPC.unban_date AS "PropertyCompanyUnBanDate",
          CPC.ban_result AS "PropertyCompanyBanResult"
        FROM
          collect.client_property CP
          LEFT JOIN collect.client_property_movable CPM USING(client_property_id)
          LEFT JOIN collect.client_property_real CPR USING(client_property_id)
          LEFT JOIN collect.client_property_company CPC USING(client_property_id)
        WHERE
          client_id = {ClientId}
        ORDER BY CP.client_property_id;
      </Text>
    </SqlQuery>

    <!-- адреса должника -->
    <SqlQuery Name="AddressTypeSelectSqlQuery">
      <Text>
        SELECT
          address_type_id AS "AddressTypeId",
          title AS "Title"
        FROM
          collect.address_type;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientAddressSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids,
            (SELECT list_client FROM collect.user_info WHERE user_id = {UserId}) AS list_client
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}
        ), loan_users AS (
          SELECT
            loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client
          WHERE
            user_id IS NOT NULL
          GROUP BY loan_id
        ), allowed_client AS (
          SELECT
            DISTINCT client_id
          FROM
            collect.client
            LEFT JOIN collect.loan_client USING(client_id)
            LEFT JOIN loan_users LU USING(loan_id)
            LEFT JOIN current_user_info CUI ON true
          WHERE
            (NOT (list_client = 'none') AND
            (list_client = 'full' OR
            (list_client = 'partial' AND
             (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
             {UserId} = ANY(LU.user_ids))))
        ), S AS (
          SELECT
            CA.address_id
          FROM
            allowed_client AC
            LEFT JOIN collect.client_address CA USING(client_id)
          ORDER BY client_id, address_id
        ), R AS (
          SELECT
            count(*) AS total_rows,
            COALESCE(CEIL(count(*)::numeric/GREATEST(COALESCE({RowsPerPage}, count(*))::numeric, 1)), 1) AS total_pages
          FROM
            S
        ), final AS (
          SELECT
            row_number() over() AS "RowNumber",
            (SELECT R.total_rows FROM R) AS "TotalRows",
            (SELECT R.total_pages FROM R) AS "TotalPages",
            *
          FROM
            S
          LIMIT COALESCE({RowsPerPage}, (SELECT R.total_rows FROM R))
          OFFSET (GREATEST((LEAST((SELECT R.total_pages FROM R), COALESCE({CurrentPage}, 1)) - 1)::integer, 0) * COALESCE({RowsPerPage}, (SELECT R.total_rows FROM R)))
        )
        SELECT
          F."RowNumber",
          F."TotalRows",
          F."TotalPages",
          F.address_id AS "AddressId",
          CA.client_id AS "ClientId",
          A.address_string AS "AddressString",
          A.address_index AS "AddressIndex",
          AR.title AS "AddressRegionTitle",
          ACT.title AS "AddressCityTypeTitle",
          AC.title AS "AddressCityTitle",
          AST.title AS "AddressStreetTypeTitle",
          ASTR.title AS "AddressStreetTitle",
          A.address_building AS "AddressBuilding",
          A.address_flat AS "AddressFlat"
        FROM
          final F
          LEFT JOIN collect.client_address CA USING(address_id)
          LEFT JOIN collect.client C USING(client_id)
          LEFT JOIN collect.address A USING(address_id)
          LEFT JOIN collect.address_region AR USING(address_region_id)
          LEFT JOIN collect.address_district AD USING(address_district_id)
          LEFT JOIN collect.address_city_type ACT USING(address_city_type_id)
          LEFT JOIN collect.address_city AC USING(address_city_id)
          LEFT JOIN collect.address_street_type AST USING(address_street_type_id)
          LEFT JOIN collect.address_street ASTR USING(address_street_id)
        ORDER BY F."RowNumber";
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientAddressByClientIdSelectSqlQuery">
      <Text>
        SELECT
          CA.address_id AS "AddressId",
          CA.address_type_id AS "AddressTypeId",
          CA.address_type AS "AddressType",
          CASE WHEN ATP.title = 'Другой' AND COALESCE(CA.address_type,'') != '' THEN CA.address_type ELSE ATP.title END AS "AddressTypeTitle",
          CASE WHEN COALESCE(A.address_string,'') = '' THEN ADR.address_string ELSE A.address_string END AS "Address",
          A.address_string AS "AddressString",
          A.address_okato AS "AddressOkato",
          A.address_index AS "AddressIndex",
          A.address_region_id AS "AddressRegionId",
          A.address_district_id AS "AddressDistrictId",
          A.address_city_district AS "AddressCityDistrict",
          A.address_city_type_id AS "AddressCityTypeId",
          A.address_city_id AS "AddressCityId",
          A.address_street_type_id AS "AddressStreetTypeId",
          A.address_street_id AS "AddressStreetId",
          A.address_building AS "AddressBuilding",
          A.address_block AS "AddressBlock",
          A.address_structure AS "AddressStructure",
          A.address_flat AS "AddressFlat"
        FROM
          collect.client_address CA
          LEFT JOIN collect.address A USING(address_id)
          LEFT JOIN collect.address_type ATP USING(address_type_id)
          LEFT JOIN collect.get_address_string(p_client_id => {ClientId}::bigint) ADR USING(address_id)
        WHERE
          CA.client_id = {ClientId}
        ORDER BY CA.address_type_id, CA.address_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientAddressUpdateSqlQuery">
      <Text>
        SELECT collect.address_update(
          {AddressId}::bigint,
          {AddressTypeId}::integer,
          {AddressType}::character varying,
          {AddressString}::character varying,
          {AddressOkato}::character varying,
          {AddressIndex}::character varying,
          {AddressRegionId}::integer,
          {AddressDistrictId}::bigint,
          {AddressDistrict}::character varying,
          {AddressCityDistrict}::character varying,
          {AddressCityTypeId}::integer,
          {AddressCityId}::bigint,
          {AddressCity}::character varying,
          {AddressStreetTypeId}::integer,
          {AddressStreetId}::bigint,
          {AddressStreet}::character varying,
          {AddressBuilding}::character varying,
          {AddressBlock}::character varying,
          {AddressStructure}::character varying,
          {AddressFlat}::character varying,
          {UserId}::smallint,
          true);
      </Text>
    </SqlQuery>

    <!--cоц. сети должника -->
    <SqlQuery Name="SocialWebsiteSelectSqlQuery">
      <Text>
        SELECT
          social_website_id AS "SocialWebsiteId",
          title AS "Title"
        FROM
          collect.social_website
        ORDER BY social_website_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientSocialByClientIdSelectSqlQuery">
      <Text>
        SELECT
          client_social_id AS "ClientSocialId",
          CS.social_website_id AS "SocialWebsiteId",
          social_website AS "SocialWebsite",
          CASE WHEN SW.title = 'Другое' AND COALESCE(social_website,'') != '' THEN social_website ELSE SW.title END AS "SocialWebsiteTitle",
          link AS "Link"
        FROM
          collect.client_social CS
          LEFT JOIN collect.social_website SW USING(social_website_id)
        WHERE
          client_id = {ClientId}
        ORDER BY client_social_id;
      </Text>
    </SqlQuery>

    <!-- подсудность -->
    <SqlQuery Name="ClientJurisdictionUpdateByDebexResultJurisdictionSqlQuery">
      <Text>
        SELECT collect.client_jurisdiction_update_by_debex_result_jurisdiction({DebexResultJurisdictionIds}::bigint[], {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientJurisdictionSelectSqlQuery">
      <Text>
        SELECT
          CJ.client_jurisdiction_id AS "ClientJurisdictionId",
          C.court_id AS "CourtId",
          O.osp_id AS "OspId",
          CJ.create_date AS "CreateDate",
          C.title AS "CourtTitle",
          C.address AS "CourtAddress",
          O.title AS "OspTitle",
          O.address AS "OspAddress"
        FROM
          collect.client_jurisdiction CJ
          LEFT JOIN collect.court C USING(court_id)
          LEFT JOIN collect.osp O USING(osp_id)
        WHERE
          CJ.client_id = {ClientId}
        ORDER BY
          CJ.create_date;
      </Text>
    </SqlQuery>

    <SqlQuery Name="JurisdictionByClientIdSelectSqlQuery">
      <Text>
        SELECT
          CJ.client_jurisdiction_id AS "ClientJurisdictionId",
          CJ.client_id AS "ClientId",
          CJ.create_date AS "CreateDate",
          C.court_id AS "CourtId",
          C.title AS "CourtTitle",
          C.address AS "CourtAddress",
          C.receiver AS "CourtReceiver",
          C.receiver_bank AS "CourtReceiverBank",
          C.inn AS "CourtInn",
          C.kpp AS "CourtKpp",
          C.correspondent_account AS "CourtCorrespondentAccount",
          C.account AS "CourtAccount",
          C.bik AS "CourtBik",
          C.oktmo AS "CourtOktmo",
          C.kbk AS "CourtKbk",
          C.receiver_bank_city AS "CourtReceiverBankCity",
          C.phone AS "CourtPhone",
          C.email AS "CourtEmail",
          C.site AS "CourtSite",
          O.title AS "OspTitle",
          O.address AS "OspAddress",
          O.ufssp_title AS "OspUfsspTitle",
          O.phone AS "OspPhone"
        FROM
          collect.client_jurisdiction CJ
          LEFT JOIN collect.court C USING(court_id)
          LEFT JOIN collect.osp O USING(osp_id)
        WHERE
          CJ.client_id = ANY({ClientIds}::bigint[])
        ORDER BY
          CJ.create_date;
      </Text>
    </SqlQuery>

    <!-- банкротство -->
    <SqlQuery Name="BankruptTypeSelectSqlQuery">
      <Text>
        SELECT
          bankrupt_type_id AS "BankruptTypeId",
          title AS "Title",
          archive AS "Archive"
        FROM
          collect.bankrupt_type
        ORDER BY title, bankrupt_type_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="BankruptTypeByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title"
        FROM
          collect.bankrupt_type
        WHERE
          bankrupt_type_id = {BankruptTypeId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="BankruptTypeInsertSqlQuery">
      <Text>
        INSERT INTO collect.bankrupt_type (title)
        VALUES ({Title})
        RETURNING bankrupt_type_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="BankruptTypeUpdateSqlQuery">
      <Text>
        UPDATE
          collect.bankrupt_type
        SET
          title = {Title}
        WHERE
          bankrupt_type_id = {BankruptTypeId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="BankruptTypeArchiveSqlQuery">
      <Text>
        UPDATE
          collect.bankrupt_type BT
        SET
          archive = NOT T.archive
        FROM 
          (
            SELECT
              unnest({BankruptTypeId}::bigint[]) AS bankrupt_type_id,
              unnest({Archive}::boolean[]) AS archive
          ) T
        WHERE
          BT.bankrupt_type_id = T.bankrupt_type_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="BankruptTypeDeleteSqlQuery">
      <Text>
        SELECT collect.bankrupt_type_try_delete({BankruptTypeId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="BankruptTypeMergeSqlQuery">
      <Text>
        SELECT collect.bankrupt_type_merge({MergeBankruptTypeIds}::bigint[], {BankruptTypeId}::bigint, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientBankruptUpdateByDebexResultBankruptSqlQuery">
      <Text>
        SELECT collect.client_bankrupt_update_by_debex_result_bankrupt({DebexResultBankruptIds}::bigint[], {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientBankruptCheckDateUpdateSqlQuery">
      <Text>
        SELECT collect.client_bankrupt_check_date_update({ClientIds}::bigint[], {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientBankruptSelectSqlQuery">
      <Text>
        SELECT
          client_bankrupt_id AS "ClientBankruptId",
          court_id AS "CourtId",
          case_number AS "CaseNumber",
          out_court_bankrupt_end_date AS "OutCourtBankruptEndDate",
          next_session_date AS "NextSessionDate",
          recognition_date AS "RecognitionDate",
          sale_property_date AS "SalePropertyDate",
          work_state_date AS "WorkStateDate",
          description AS "Description",
          bankrupt_type_id AS "BankruptTypeId",
          efrsb_number AS "EFRSBNumber",
          efrsb_link AS "EFRSBLink",
          create_date AS "CreateDate",
          edit_date AS "EditDate"
        FROM
          collect.client_bankrupt
        WHERE
          client_id = {ClientId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="BankruptByClientIdSelectSqlQuery">
      <Text>
        SELECT
          CBL.client_id AS "ClientId",
          C.title AS "CourtTitle",
          CB.case_number AS "CaseNumber",
          CB.out_court_bankrupt_end_date AS "BankruptOutCourtBankruptEndDate",
          CB.next_session_date AS "BankruptNextSessionDate",
          CB.recognition_date AS "BankruptRecognitionDate",
          CB.sale_property_date AS "BankruptSalePropertyDate",
          CB.work_state_date AS "BankruptWorkStartDate",
          CB.description AS "BankruptDescription",
          BT.title AS "BankruptTypeTitle",
          CB.efrsb_number AS "BankruptEFRSBNumber",
          CB.efrsb_link AS "BankruptEFRSBLink"
        FROM
          collect.client_bankrupt_last({ClientIds}::bigint[]) CBL
          LEFT JOIN collect.client_bankrupt CB USING(client_bankrupt_id)
          LEFT JOIN collect.court C USING(court_id)
          LEFT JOIN collect.bankrupt_type BT USING(bankrupt_type_id);
      </Text>
    </SqlQuery>
    <!--==============================================================-->
    <!--======================ДЕЛА ЗАЕМЩИКОВ==========================-->
    <!--==============================================================-->
    <!-- запросы для печати шаблонов документов -->
    <SqlQuery Name="LoanForExportSelectSqlQuery">
      <Text>
        WITH LCF AS (
          SELECT
            loan_client_id
          FROM
            collect.loan_client
          WHERE
            loan_client_id = ANY({LoanClientId}::bigint[]) OR
            ({LoanId} IS NOT NULL AND {ClientId} IS NOT NULL AND loan_id = {LoanId} AND client_id = {ClientId})
        ), LCRPT AS (
          SELECT
            SUM(sum) AS total_sum,
            loan_client_id
          FROM
            collect.loan_client
            JOIN LCF USING(loan_client_id)
            LEFT JOIN collect.loan_client_payment USING(loan_client_id)
          WHERE
            date >= repayment_date
          GROUP BY
            loan_client_id
        ), final_loan AS (
          SELECT
            DISTINCT loan_id
          FROM
            collect.loan_client
            JOIN LCF USING(loan_client_id)
        ), final_client AS (
          SELECT
            DISTINCT client_id
          FROM
            collect.loan_client
            JOIN final_loan USING(loan_id)
        ), client_person_info AS (
          SELECT
            CP.client_id,
            collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS full_title,
            collect.get_client_title(CP.first_name, CP.second_name, CP.third_name, true) AS short_title,
            CASE
              WHEN COALESCE(CP.passport_series, '') = '' THEN '—'::character varying
              ELSE CP.passport_series
            END AS passport_series,
            CASE
              WHEN COALESCE(CP.passport_number, '') = '' THEN '—'::character varying
              ELSE CP.passport_number
            END AS passport_number,
            CASE
              WHEN COALESCE(CP.passport_given_by, '') = '' THEN '—'::character varying
              ELSE CP.passport_given_by
            END AS passport_given_by,
            COALESCE(to_char(CP.passport_given_date, 'dd.MM.yyyy'), '—') AS passport_given_date
          FROM
            final_client F
            JOIN collect.client_person CP USING(client_id)
        ), registration_address AS (
          SELECT
            DISTINCT ON (F.client_id)
            F.client_id,
            CA.address_id,
            A.address_string
          FROM
            final_client F
            LEFT JOIN collect.client_address CA USING(client_id)
            LEFT JOIN collect.address A USING(address_id)
            LEFT JOIN collect.address_type ATP USING (address_type_id)
          WHERE
            ATP.title = 'Регистрация'
          ORDER BY F.client_id, CA.address_id DESC
        ), actual_address AS (
          SELECT
            DISTINCT ON (F.client_id)
            F.client_id,
            CA.address_id,
            A.address_string
          FROM
            final_client F
            LEFT JOIN collect.client_address CA USING(client_id)
            LEFT JOIN collect.address A USING(address_id)
            LEFT JOIN collect.address_type ATP USING (address_type_id)
          WHERE
            ATP.title = 'Проживание'
          ORDER BY F.client_id, CA.address_id DESC
        ), all_address AS (
          SELECT
            DISTINCT ON (GAS.address_id)
            GAS.address_id,
            GAS.address_string
          FROM
            final_client F
            LEFT JOIN collect.get_address_string(p_client_id => F.client_id) GAS USING(client_id)
        ), client_registration_address AS (
          SELECT
            RA.client_id,
            CASE
              WHEN COALESCE(RA.address_string, '') = '' THEN GAS.address_string
              ELSE RA.address_string
            END AS registration_address
          FROM
            registration_address RA
            LEFT JOIN all_address GAS USING (address_id)
        ), client_actual_address AS (
          SELECT
            AA.client_id,
            CASE
              WHEN COALESCE(AA.address_string, '') = '' THEN GAS.address_string
              ELSE AA.address_string
            END AS actual_address
          FROM
            actual_address AA
            LEFT JOIN all_address GAS USING (address_id)
        ), client_info AS (
          SELECT
            CPI.client_id,
            CPI.full_title,
            CPI.short_title,
            'Серия: ' || CPI.passport_series || ', номер: ' || CPI.passport_number || ', выдан: ' || CPI.passport_given_by || ', дата выдачи: ' || CPI.passport_given_date AS full_passport,
            CRA.registration_address,
            CAA.actual_address
          FROM
            client_person_info CPI
            LEFT JOIN client_actual_address CAA USING(client_id)
            LEFT JOIN client_registration_address CRA USING(client_id)
        )
        SELECT
          LC.loan_client_id AS "LoanClientId",
          CL.title AS "ClaimantTitle",
          CL.title_genitive AS "ClaimantTitleGenitive",
          CL.short_title AS "ClaimantShortTitle",
          CL.branch AS "ClaimantBranch",
          CL.branch_genitive AS "ClaimantBranchGenitive",
          CL.representative AS "ClaimantRepresentative",
          CL.representative_genitive AS "ClaimantRepresentativeGenitive",
          CL.representative_post AS "ClaimantRepresentativePost",
          CL.representative_post_genitive AS "ClaimantRepresentativePostGenitive",
          CL.document AS "ClaimantDocument",
          CL.document_genitive AS "ClaimantDocumentGenitive",
          CL.inn AS "ClaimantINN",
          CL.address AS "ClaimantAddress",
          IO.title AS "InnerOrgTitle",
          IO.short_title AS "InnerOrgShortTitle",
          IO.leader_post AS "InnerOrgLeaderPost",
          IO.document AS "InnerOrgDocument",
          IO.leader_title AS "InnerOrgLeaderTitle",
          IO.leader_genitive AS "InnerOrgLeaderGenitive",
          IO.leader_initials AS "InnerOrgLeaderInitials",
          IO.legal_address AS "InnerOrgLegalAddress",
          IO.actual_address AS "InnerOrgActualAddress",
          IO.city AS "InnerOrgCity",
          IO.inn AS "InnerOrgINN",
          IO.kpp AS "InnerOrgKPP",
          IO.ogrn AS "InnerOrgOGRN",
          IO.payment_account AS "InnerOrgPaymentAccount",
          IO.bank AS "InnerOrgBank",
          IO.bank_city AS "InnerOrgBankCity",
          IO.correspondent_account AS "InnerOrgCorrespondentAccount",
          IO.bik AS "InnerOrgBIK",
          IO.phone AS "InnerOrgPhone",
          IO.fax AS "InnerOrgFax",
          IO.email AS "InnerOrgEmail",
          IO.website AS "InnerOrgWebsite",
          C.title AS "CessionTitle",
          CT.title AS "CessionType",
          C.cession_date AS "CessionDate", --DATE
          C_AR.title AS "CessionRegion",
          C.agreement_number AS "CessionAgreementNumber",
          PU.user_full_name AS "UserInitials",
          U.full_title AS "UserTitle",
          U.full_title_genitive AS "UserTitleGenitive",
          U.post AS "UserPost",
          U.procuration_number AS "UserProcurationNumber",
          U.procuration_date AS "UserProcurationDate", --DATE
          U.email AS "UserEmail",
          UP.phone_number AS "UserMainPhone",
          CI.full_title AS "ClientTitle",
          CI.short_title AS "ClientShortTitle",
          CP.first_name AS "ClientFirstName",
          CP.second_name AS "ClientSecondName",
          CP.third_name AS "ClientThirdName",
          CASE
            WHEN CP.gender THEN 'Мужской'
            WHEN NOT CP.gender THEN 'Женский'
            ELSE NULL::character varying
          END AS "ClientGender",
          CP.birth_date AS "ClientBirthDate", --DATE
          CP.birth_place AS "ClientBirthPlace",
          CPH_F.guid AS "ClientMainPhotoGuid",
          CPHN.phone_number AS "ClientMainPhone",
          CI.registration_address AS "ClientRegistrationAddress",
          CI.actual_address AS "ClientActualAddress",
          CI.full_passport AS "ClientPassport",
          CP.passport_series AS "ClientPassportSeries",
          CP.passport_number AS "ClientPassportNumber",
          CP.passport_given_by AS "ClientPassportGivenBy",
          CP.passport_given_date AS "ClientPassportGivenDate", --DATE
          CP.passport_code AS "ClientPassportCode",
          CP.inn AS "ClientINN",
          CP.snils AS "ClientSNILS",
          CP.email AS "ClientEmail",
          CP.work_company_title AS "ClientWorkCompanyTitle",
          CP.work_post AS "ClientWorkPost",
          CP.work_salary AS "ClientWorkSalary", --NUMERIC
          CP.work_hired_date AS "ClientWorkHiredDate", --DATE
          CP.work_fired_date AS "ClientWorkFiredDate", --DATE
          CSA.bank_title AS "ClientSalaryAccountBankTitle",
          CSA.bank_requisite AS "ClientSalaryAccountBankRequisite",
          CSA.account AS "ClientSalaryAccount",
          CSA.description AS "ClientSalaryAccountDescription",
          CSA.arrest_date AS "ClientSalaryAccountArrestDate", --DATE
          CB_C.title AS "ClientBankruptCourtTitle",
          CB_C.title_genitive AS "ClientBankruptCourtTitleGenitive",
          CB_C.address AS "ClientBankruptCourtAddress",
          CB_C_AR.title AS "ClientBankruptCourtRegion",
          CB_C.receiver AS "ClientBankruptCourtReceiver",
          CB_C.receiver_bank AS "ClientBankruptCourtReceiverBank",
          CB_C.receiver_bank_city AS "ClientBankruptCourtReceiverBankCity",
          CB_C.inn AS "ClientBankruptCourtInn",
          CB_C.kpp AS "ClientBankruptCourtKpp",
          CB_C.correspondent_account AS "ClientBankruptCourtCorrespondentAccount",
          CB_C.account AS "ClientBankruptCourtAccount",
          CB_C.bik AS "ClientBankruptCourtBik",
          CB_C.oktmo AS "ClientBankruptCourtOktmo",
          CB_C.kbk AS "ClientBankruptCourtKbk",
          CB_C.phone AS "ClientBankruptCourtPhone",
          CB_C.email AS "ClientBankruptCourtEmail",
          CB_C.site AS "ClientBankruptCourtSite",
          CB.case_number AS "ClientBankruptCaseNumber",
          CB.out_court_bankrupt_end_date AS "ClientBankruptOutCourtBankruptEndDate", --DATE
          CB.next_session_date AS "ClientBankruptNextSessionDate", --DATE
          CB.recognition_date AS "ClientBankruptRecognitionDate", --DATE
          CB.sale_property_date AS "ClientBankruptSalePropertyDate", --DATE
          CB.work_state_date AS "ClientBankruptWorkStateDate", --DATE
          CB.description AS "ClientBankruptDescription",
          BT.title AS "ClientBankruptType",
          CB.efrsb_number AS "ClientBankruptEFRSBNumber",
          CB.efrsb_link AS "ClientBankruptEFRSBLink",
          L.credit_number AS "LoanCreditNumber",
          L.credit_date AS "LoanCreditDate", --DATE
          L.account_number AS "LoanAccountNumber",
          L.credit_end_date AS "LoanCreditEndDate", --DATE
          L.credit_sum AS "LoanCreditSum", --NUMERIC
          L.credit_rate AS "LoanCreditRate", --NUMERIC
          L.full_price AS "LoanFullPrice", --NUMERIC
          L.full_price_percent AS "LoanFullPricePercent", --NUMERIC
          L.overdue_date AS "LoanOverdueDate", --DATE
          CRT.title AS "LoanCreditType",
          CRGT.title AS "LoanCreditGetType",
          LCHF.date AS "LoanHistoryFirstDate", --DATE
          LCHF.sum AS "LoanHistoryFirstSum", --NUMERIC
          LCHF.claimant_title AS "LoanHistoryFirstClaimant",
          LCHF.inner_org_title AS "LoanHistoryFirstInnerOrg",
          LCHF.cession_title AS "LoanHistoryFirstCession",
          LCHL.date AS "LoanHistoryLastDate", --DATE
          LCHL.sum AS "LoanHistoryLastSum", --NUMERIC
          LCHL.claimant_title AS "LoanHistoryLastClaimant",
          LCHL.inner_org_title AS "LoanHistoryLastInnerOrg",
          LCHL.cession_title AS "LoanHistoryLastCession",
          L.debt_base AS "LoanDebtBase", --NUMERIC
          L.debt_percent AS "LoanDebtPercent", --NUMERIC
          L.debt_penalty AS "LoanDebtPenalty", --NUMERIC
          L.debt_tax AS "LoanDebtTax", --NUMERIC
          COALESCE(L.debt_base,0) + COALESCE(L.debt_percent,0) AS "LoanDebtBaseAndPercent", --NUMERIC
          COALESCE(L.debt_base,0) + COALESCE(L.debt_percent,0) + COALESCE(L.debt_penalty,0) AS "LoanDebtBaseAndPercentAndPenalty", --NUMERIC
          COALESCE(L.debt_base,0) + COALESCE(L.debt_percent,0) + COALESCE(L.debt_penalty,0) + COALESCE(L.debt_tax,0) AS "LoanDebtTotal", --NUMERIC
          LDR.debt_base_rest AS "LoanDebtBaseRest", --NUMERIC
          LDR.debt_percent_rest AS "LoanDebtPercentRest", --NUMERIC
          LDR.debt_penalty_rest AS "LoanDebtPenaltyRest", --NUMERIC
          LDR.debt_tax_rest AS "LoanDebtTaxRest", --NUMERIC
          LDR.debt_base_rest + LDR.debt_percent_rest AS "LoanDebtBaseAndPercentRest", --NUMERIC
          LDR.debt_base_rest + LDR.debt_percent_rest + LDR.debt_penalty_rest AS "LoanDebtBaseAndPercentAndPenaltyRest", --NUMERIC
          LDR.debt_base_rest + LDR.debt_percent_rest + LDR.debt_penalty_rest + LDR.debt_tax_rest AS "LoanDebtTotalRest", --NUMERIC
          R.title AS "LoanClientRole",
          LC.surety_number AS "LoanClientSuretyNumber",
          CASE
            WHEN LC.surety_duty THEN 'В полном объеме'
            WHEN NOT LC.surety_duty THEN 'Частично'
            ELSE NULL::character varying
          END AS "LoanClientSuretyDuty",
          LC.surety_sum AS "LoanClientSuretySum", --NUMERIC
          LC.court_sum AS "LoanClientCourtSum", --NUMERIC
          LC.court_date AS "LoanClientCourtDate", --DATE
          LC.debt_base AS "LoanClientDebtBase", --NUMERIC
          LC.debt_percent AS "LoanClientDebtPercent", --NUMERIC
          LC.debt_penalty AS "LoanClientDebtPenalty", --NUMERIC
          LC.debt_tax AS "LoanClientDebtTax", --NUMERIC
          COALESCE(LC.debt_base,0) + COALESCE(LC.debt_percent,0) AS "LoanClientDebtBaseAndPercent", --NUMERIC
          COALESCE(LC.debt_base,0) + COALESCE(LC.debt_percent,0) + COALESCE(LC.debt_penalty,0) AS "LoanClientDebtBaseAndPercentAndPenalty", --NUMERIC
          COALESCE(LC.debt_base,0) + COALESCE(LC.debt_percent,0) + COALESCE(LC.debt_penalty,0) + COALESCE(LC.debt_tax,0) AS "LoanClientDebtTotal", --NUMERIC
          LCDR.debt_base_rest AS "LoanClientDebtBaseRest", --NUMERIC
          LCDR.debt_percent_rest AS "LoanClientDebtPercentRest", --NUMERIC
          LCDR.debt_penalty_rest AS "LoanClientDebtPenaltyRest", --NUMERIC
          LCDR.debt_tax_rest AS "LoanClientDebtTaxRest", --NUMERIC
          LCDR.debt_base_rest + LCDR.debt_percent_rest AS "LoanClientDebtBaseAndPercentRest", --NUMERIC
          LCDR.debt_base_rest + LCDR.debt_percent_rest + LCDR.debt_penalty_rest AS "LoanClientDebtBaseAndPercentAndPenaltyRest", --NUMERIC
          LCDR.debt_base_rest + LCDR.debt_percent_rest + LCDR.debt_penalty_rest + LCDR.debt_tax_rest AS "LoanClientDebtTotalRest", --NUMERIC
          OLC.title AS "OtherLoanClientTitle",
          OLC.title_and_passport AS "OtherLoanClientTitleAndPassport",
          OLC.title_and_address AS "OtherLoanClientTitleAndRegistrationAddress",
          OLC.title_and_passport_and_address AS "OtherLoanClientTitleAndPassportAndRegistrationAddress",
          LCNF.number AS "NotificationFirstActualNumber",
          LCNF.date AS "NotificationFirstActualDate", --DATE
          LCNF.send_date AS "NotificationFirstActualSendDate", --DATE
          LCNF.post_number AS "NotificationFirstActualPostNumber",
          LCNF.delivery_info AS "NotificationFirstActualDeliveryInfo",
          LCNL.number AS "NotificationLastActualNumber",
          LCNL.date AS "NotificationLastActualDate", --DATE
          LCNL.send_date AS "NotificationLastActualSendDate", --DATE
          LCNL.post_number AS "NotificationLastActualPostNumber",
          LCNL.delivery_info AS "NotificationLastActualDeliveryInfo",
          LCS_C.title AS "SuccessionCourtTitle",
          LCS_C.title_genitive AS "SuccessionCourtTitleGenitive",
          LCS_C.address AS "SuccessionCourtAddress",
          LCS_C_AR.title AS "SuccessionCourtRegion",
          LCS_C.receiver AS "SuccessionCourtReceiver",
          LCS_C.receiver_bank AS "SuccessionCourtReceiverBank",
          LCS_C.receiver_bank_city AS "SuccessionCourtReceiverBankCity",
          LCS_C.inn AS "SuccessionCourtInn",
          LCS_C.kpp AS "SuccessionCourtKpp",
          LCS_C.correspondent_account AS "SuccessionCourtCorrespondentAccount",
          LCS_C.account AS "SuccessionCourtAccount",
          LCS_C.bik AS "SuccessionCourtBik",
          LCS_C.oktmo AS "SuccessionCourtOktmo",
          LCS_C.kbk AS "SuccessionCourtKbk",
          LCS_C.phone AS "SuccessionCourtPhone",
          LCS_C.email AS "SuccessionCourtEmail",
          LCS_C.site AS "SuccessionCourtSite",
          LCS_CD.title AS "SuccessionDocument",
          LCS.document_number AS "SuccessionDocumentNumber",
          LCS.document_date AS "SuccessionDocumentDate", --DATE
          CASE WHEN LCS.document_is_duplicate THEN 'Да' ELSE 'Нет' END AS "SuccessionDocumentIsDuplicate",
          LCS.duplicate_get_date AS "SuccessionDuplicateGetDate", --DATE
          LCS.duplicate_court_date AS "SuccessionDuplicateCourtDate", --DATE
          LCS.document_info AS "SuccessionDocumentInfo",
          LCS.case_number AS "SuccessionCaseNumber",
          LCS.document_sum AS "SuccessionDocumentSum", --NUMERIC
          LCS.tax_sum AS "SuccessionTaxSum", --NUMERIC
          LCS.send_date AS "SuccessionSendDate", --DATE
          LCS.court_date AS "SuccessionCourtDate", --DATE
          LCS.result AS "SuccessionResult",
          LCS.comment AS "SuccessionComment",
          LCS.cancel_date AS "SuccessionCancelDate", --DATE
          LCS.appeal_send_date AS "SuccessionAppealSendDate", --DATE
          LCS.appeal_date AS "SuccessionAppealDate", --DATE
          LCS.appeal_result AS "SuccessionAppealResult",
          LCS.cassation_send_date AS "SuccessionCassationSendDate", --DATE
          LCS.cassation_date AS "SuccessionCassationDate", --DATE
          LCS.cassation_result AS "SuccessionCassationResult",
          LCC_CD.title AS "CollectionCourtDocument",
          LCC.court_document_number AS "CollectionCourtDocumentNumber",
          LCC.court_document_date AS "CollectionCourtDocumentDate", --DATE
          LCC_C.title AS "CollectionCourtTitle",
          LCC_C.title_genitive AS "CollectionCourtTitleGenitive",
          LCC_C.address AS "CollectionCourtAddress",
          LCC_C_AR.title AS "CollectionCourtRegion",
          LCC_C.receiver AS "CollectionCourtReceiver",
          LCC_C.receiver_bank AS "CollectionCourtReceiverBank",
          LCC_C.receiver_bank_city AS "CollectionCourtReceiverBankCity",
          LCC_C.inn AS "CollectionCourtInn",
          LCC_C.kpp AS "CollectionCourtKpp",
          LCC_C.correspondent_account AS "CollectionCourtCorrespondentAccount",
          LCC_C.account AS "CollectionCourtAccount",
          LCC_C.bik AS "CollectionCourtBik",
          LCC_C.oktmo AS "CollectionCourtOktmo",
          LCC_C.kbk AS "CollectionCourtKbk",
          LCC_C.phone AS "CollectionCourtPhone",
          LCC_C.email AS "CollectionCourtEmail",
          LCC_C.site AS "CollectionCourtSite",
          LCC.send_date AS "CollectionSendDate", --DATE
          LCC.case_number AS "CollectionCaseNumber",
          LCC.judge AS "CollectionJudge",
          LCC.contact_date AS "CollectionContactDate", --DATE
          LCC.court_date AS "CollectionCourtDate", --DATE
          LCC.result_date AS "CollectionResultDate", --DATE
          LCC_CR.title AS "CollectionCourtResult",
          LCC.sum AS "CollectionSum", --NUMERIC
          CASE WHEN LCC.is_recieved THEN 'Да' ELSE 'Нет' END AS "CollectionIsRecieved",
          LCC.legal_date AS "CollectionLegalDate", --DATE
          LCC.document_get_date AS "CollectionDocumentGetDate", --DATE
          LCC.cancel_date AS "CollectionCancelDate", --DATE
          LCC.appeal_send_date AS "CollectionAppealSendDate", --DATE
          LCC.appeal_date AS "CollectionAppealDate", --DATE
          LCC.appeal_result AS "CollectionAppealResult",
          LCC.cassation_send_date AS "CollectionCassationSendDate", --DATE
          LCC.cassation_date AS "CollectionCassationDate", --DATE
          LCC.cassation_result AS "CollectionCassationResult",
          LCC_AT.title AS "CollectionApplicationType",
          LCC.application_sum AS "CollectionApplicationSum", --NUMERIC
          LCC.application_tax AS "CollectionApplicationTax", --NUMERIC
          LCE.document_info AS "ExecutiveDocumentInfo",
          LCE_O.title AS "ExecutiveOspTitle",
          LCE_O.ufssp_title AS "ExecutiveUfsspTitle",
          LCE_O.address AS "ExecutiveOspAddress",
          LCE_O.phone AS "ExecutiveOspPhone",
          LCE.bailiff_title AS "ExecutiveBailiffTitle",
          LCE.bailiff_phone AS "ExecutiveBailiffPhone",
          LCE.send_date AS "ExecutiveSendDate", --DATE
          LCE.start_date AS "ExecutiveStartDate", --DATE
          LCE.number AS "ExecutiveNumber",
          LCE.other_info AS "ExecutiveOtherInfo",
          LCE.replacement_send_date AS "ExecutiveReplacementSendDate", --DATE
          LCE.replacement_date AS "ExecutiveReplacementDate", --DATE
          LCE.request AS "ExecutiveRequest",
          LCE.request_response AS "ExecutiveRequestResponse",
          LCE.end_date AS "ExecutiveEndDate", --DATE
          LCE.resend_date AS "ExecutiveReSendDate", --DATE
          LCE.end_reason AS "ExecutiveEndReason",
          LCE.restrict_date AS "ExecutiveRestrictDate", --DATE
          LCE.restrict_end_date AS "ExecutiveRestrictEndDate", --DATE
          LCE.appeal_send_date AS "ExecutiveAppealSendDate", --DATE
          LCE.appeal_date AS "ExecutiveAppealDate", --DATE
          LCE.appeal_result AS "ExecutiveAppealResult",
          LC.repayment_date AS "RepaymentDate", --DATE
          LC.repayment_number AS "RepaymentNumber",
          LCRPT.total_sum AS "RepaymentPaymentTotal", --NUMERIC
          LC.repayment_sum AS "RepaymentSum", --NUMERIC
          GREATEST(COALESCE(LC.repayment_sum,0) - COALESCE(LCRPT.total_sum,0),0) AS "RepaymentSumRest", --NUMERIC
          LCRF.date AS "RepaymentFirstDate", --DATE
          LCRF.status AS "RepaymentFirstStatus",
          LCRF.sum AS "RepaymentFirstSum", --NUMERIC
          LCRL.date AS "RepaymentLastDate", --DATE
          LCRL.status AS "RepaymentLastStatus",
          LCRL.sum AS "RepaymentLastSum", --NUMERIC
          LPT.total_sum AS "PaymentLoanTotal", --NUMERIC
          LPF.client_title AS "PaymentLoanFirstClientTitle",
          LPF.payer_title AS "PaymentLoanFirstPayerTitle",
          LPF.date AS "PaymentLoanFirstDate", --DATE
          LPF.sum AS "PaymentLoanFirstSum", --NUMERIC
          LPF.number AS "PaymentLoanFirstNumber",
          LPF.comment AS "PaymentLoanFirstComment",
          LPL.client_title AS "PaymentLoanLastClientTitle",
          LPL.payer_title AS "PaymentLoanLastPayerTitle",
          LPL.date AS "PaymentLoanLastDate", --DATE
          LPL.sum AS "PaymentLoanLastSum", --NUMERIC
          LPL.number AS "PaymentLoanLastNumber",
          LPL.comment AS "PaymentLoanLastComment",
          LCPT.total_sum AS "PaymentLoanClientTotal", --NUMERIC
          LCPF.payer_title AS "PaymentLoanClientFirstPayerTitle",
          LCPF.date AS "PaymentLoanClientFirstDate", --DATE
          LCPF.sum AS "PaymentLoanClientFirstSum", --NUMERIC
          LCPF.number AS "PaymentLoanClientFirstNumber",
          LCPF.comment AS "PaymentLoanClientFirstComment",
          LCPL.payer_title AS "PaymentLoanClientLastPayerTitle",
          LCPL.date AS "PaymentLoanClientLastDate", --DATE
          LCPL.sum AS "PaymentLoanClientLastSum", --NUMERIC
          LCPL.number AS "PaymentLoanClientLastNumber",
          LCPL.comment AS "PaymentLoanClientLastComment",
          LCIL.concent_date AS "InteractionLimitConcentDate", --DATE
          LCIL.agent_concent_date AS "InteractionLimitAgentConcentDate", --DATE
          LCIL.agent_title AS "InteractionLimitAgentTitle",
          LCIL.agent_birth_date AS "InteractionLimitAgentBirthDate", --DATE
          LCIL.agent_phone AS "InteractionLimitAgentPhone",
          LCIL.agent_address AS "InteractionLimitAgentAddress",
          LCIL.agent_email AS "InteractionLimitAgentEmail",
          LCIL.agent_lawyer AS "InteractionLimitAgentLawyer",
          LCIL.reject_date AS "InteractionLimitRejectDate", --DATE
          LCIL.agent_reject_date AS "InteractionLimitAgentRejectDate", --DATE
          LCIL.reject_cancel_date AS "InteractionLimitRejectCancelDate", --DATE
          LCIL.other_agent_date AS "InteractionLimitOtherAgentDate", --DATE
          LCIL.request AS "InteractionLimitRequest",
          LCIL.request_response AS "InteractionLimitRequestResponse"
        FROM
          collect.loan_client LC
          JOIN LCF USING(loan_client_id)
          JOIN collect.loan L USING(loan_id)
          LEFT JOIN collect.cession C USING(cession_id)
          LEFT JOIN collect.claimant CL USING(claimant_id)
          LEFT JOIN collect.inner_org IO USING(inner_org_id)
          LEFT JOIN collect.cession_type CT USING(cession_type_id)
          LEFT JOIN collect.address_region C_AR ON C.address_region_id = C_AR.address_region_id
          LEFT JOIN collect.user U USING(user_id)
          LEFT JOIN public.user PU ON U.public_user_id = PU.user_id
          LEFT JOIN collect.user_phone UP ON U.user_id = UP.user_id AND UP.is_main
          JOIN collect.client_person CP USING(client_id)
          LEFT JOIN client_info CI USING(client_id)
          LEFT JOIN collect.client_photo CPH ON LC.client_id = CPH.client_id AND CPH.is_main
          LEFT JOIN public.file CPH_F ON CPH.file_id = CPH_F.file_id
          LEFT JOIN collect.client_phone CPHN ON LC.client_id = CPHN.client_id AND CPHN.is_main
          LEFT JOIN collect.client_account CSA ON LC.client_id = CSA.client_id AND CSA.is_salary_account
          LEFT JOIN collect.credit_type CRT USING(credit_type_id)
          LEFT JOIN collect.credit_get_type CRGT USING(credit_get_type_id)
          LEFT JOIN (
            SELECT
              DISTINCT ON(loan_id) *
            FROM
              collect.loan_cession_history
            WHERE
              loan_id IN (SELECT DISTINCT loan_id FROM collect.loan_client JOIN LCF USING(loan_client_id))
            ORDER BY loan_id, date ASC
          ) LCHF USING(loan_id)
          LEFT JOIN (
            SELECT
              DISTINCT ON(loan_id) *
            FROM
              collect.loan_cession_history
            WHERE
              loan_id IN (SELECT DISTINCT loan_id FROM collect.loan_client JOIN LCF USING(loan_client_id))
            ORDER BY loan_id, date DESC
          ) LCHL USING(loan_id)
          LEFT JOIN (
            SELECT
              SUM(sum) AS total_sum,
              loan_id
            FROM
              collect.loan_client_payment
              JOIN collect.loan_client USING(loan_client_id)
            WHERE
              loan_id IN (SELECT DISTINCT loan_id FROM collect.loan_client JOIN LCF USING(loan_client_id))
            GROUP BY
              loan_id
          ) LPT USING(loan_id)
          LEFT JOIN collect.role R USING(role_id)
          LEFT JOIN (
            SELECT
              SUM(sum) AS total_sum,
              loan_client_id
            FROM
              collect.loan_client
              JOIN LCF USING(loan_client_id)
              LEFT JOIN collect.loan_client_payment USING(loan_client_id)
            GROUP BY
              loan_client_id
          ) LCPT USING(loan_client_id)
          LEFT JOIN LCRPT USING(loan_client_id)
          LEFT JOIN (
            SELECT
              OLC_LC.loan_id,
              string_agg(OLC_CI.full_title, ', ') AS title,
              string_agg(COALESCE(OLC_CI.full_title,'') || COALESCE(', ' || OLC_CI.full_passport,''), E'\r\n') AS title_and_passport,
              string_agg(COALESCE(OLC_CI.full_title,'') || COALESCE(', ' || OLC_CI.registration_address,''), E'\r\n') AS title_and_address,
              string_agg(COALESCE(OLC_CI.full_title,'') || COALESCE(', ' || OLC_CI.full_passport,'') || COALESCE(', ' || OLC_CI.registration_address,''), E'\r\n') AS title_and_passport_and_address
            FROM
              collect.loan_client OLC_LC
              LEFT JOIN client_info OLC_CI USING(client_id)
            WHERE
              OLC_LC.loan_id IN (SELECT DISTINCT loan_id FROM collect.loan_client JOIN LCF USING(loan_client_id)) AND
              OLC_LC.loan_client_id NOT IN (SELECT loan_client_id FROM LCF)
            GROUP BY OLC_LC.loan_id
          ) OLC USING(loan_id)
          LEFT JOIN (
            SELECT
              DISTINCT ON (loan_client_id) *
            FROM
              collect.loan_client_notification
              JOIN LCF USING(loan_client_id)
            WHERE
              is_actual
            ORDER BY loan_client_id, date ASC
          ) LCNF USING(loan_client_id)
          LEFT JOIN (
            SELECT
              DISTINCT ON (loan_client_id) *
            FROM
              collect.loan_client_notification
              JOIN LCF USING(loan_client_id)
            WHERE
              is_actual
            ORDER BY loan_client_id, date DESC
          ) LCNL USING(loan_client_id)
          LEFT JOIN collect.loan_client_succession LCS USING(loan_client_id)
          LEFT JOIN collect.court LCS_C ON LCS.court_id = LCS_C.court_id
          LEFT JOIN collect.address_region LCS_C_AR ON LCS_C.address_region_id = LCS_C_AR.address_region_id
          LEFT JOIN collect.court_document LCS_CD ON LCS.court_document_id = LCS_CD.court_document_id
          LEFT JOIN collect.loan_client_collection LCC ON LC.loan_client_id = LCC.loan_client_id AND LCC.is_main
          LEFT JOIN collect.court_document LCC_CD ON LCC.court_document_id = LCC_CD.court_document_id
          LEFT JOIN collect.court LCC_C ON LCC.court_id = LCC_C.court_id
          LEFT JOIN collect.address_region LCC_C_AR ON LCC_C.address_region_id = LCC_C_AR.address_region_id
          LEFT JOIN collect.court_result LCC_CR USING(court_result_id)
          LEFT JOIN collect.application_type LCC_AT ON LCC.application_type_id = LCC_AT.application_type_id
          LEFT JOIN collect.loan_client_executive LCE USING(loan_client_collection_id)
          LEFT JOIN collect.osp LCE_O USING(osp_id)
          LEFT JOIN (
            SELECT
              DISTINCT ON (loan_client_id)
              R.*,
              CASE WHEN COALESCE(sum,0) > COALESCE(LCRPT.total_sum,0) THEN 'Не оплачено' ELSE 'Оплачено' END AS status
            FROM
              collect.loan_client_repayment R
              JOIN LCF USING(loan_client_id)
              LEFT JOIN LCRPT USING(loan_client_id)
            ORDER BY loan_client_id, date ASC
          ) LCRF ON LC.loan_client_id = LCRF.loan_client_id
          LEFT JOIN (
            SELECT
              DISTINCT ON (loan_client_id)
              R.*,
              CASE WHEN COALESCE(LCRT.total_sum,0) > COALESCE(LCRPT.total_sum,0) THEN 'Не оплачено' ELSE 'Оплачено' END AS status
            FROM
              collect.loan_client_repayment R
              JOIN LCF USING(loan_client_id)
              LEFT JOIN LCRPT USING(loan_client_id)
              LEFT JOIN (
                SELECT
                  SUM(sum) AS total_sum,
                  loan_client_id
                FROM
                  collect.loan_client_repayment
                  JOIN LCF USING(loan_client_id)
                GROUP BY loan_client_id
              ) LCRT USING(loan_client_id)
            ORDER BY loan_client_id, date DESC
          ) LCRL ON LC.loan_client_id = LCRL.loan_client_id
          LEFT JOIN (
            SELECT
              DISTINCT ON (LC.loan_id)
              LC.loan_id,
              collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS client_title,
              CASE
                WHEN LCP.payer_client_id IS NULL THEN LCP.payer
                ELSE collect.get_client_title(CP_P.first_name, CP_P.second_name, CP_P.third_name)
              END AS payer_title,
              LCP.date,
              LCP.sum,
              LCP.number,
              LCP.comment
            FROM
              collect.loan_client_payment LCP
              LEFT JOIN collect.client_person CP_P ON CP_P.client_id = payer_client_id
              JOIN collect.loan_client LC USING(loan_client_id)
              LEFT JOIN collect.client_person CP ON CP.client_id = LC.client_id
            WHERE
              loan_id IN (SELECT DISTINCT loan_id FROM collect.loan_client JOIN LCF USING(loan_client_id))
            ORDER BY LC.loan_id, LCP.date ASC, LCP.loan_client_payment_id ASC
          ) LPF USING(loan_id)
          LEFT JOIN (
            SELECT
              DISTINCT ON (LC.loan_id)
              LC.loan_id,
              collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS client_title,
              CASE
                WHEN LCP.payer_client_id IS NULL THEN LCP.payer
                ELSE collect.get_client_title(CP_P.first_name, CP_P.second_name, CP_P.third_name)
              END AS payer_title,
              LCP.date,
              LCP.sum,
              LCP.number,
              LCP.comment
            FROM
              collect.loan_client_payment LCP
              LEFT JOIN collect.client_person CP_P ON CP_P.client_id = payer_client_id
              JOIN collect.loan_client LC USING(loan_client_id)
              LEFT JOIN collect.client_person CP ON CP.client_id = LC.client_id
            WHERE
              loan_id IN (SELECT DISTINCT loan_id FROM collect.loan_client JOIN LCF USING(loan_client_id))
            ORDER BY LC.loan_id, LCP.date DESC, LCP.loan_client_payment_id DESC
          ) LPL USING(loan_id)
          LEFT JOIN collect.get_loan_debt_rest((SELECT array_agg(DISTINCT loan_id) FROM collect.loan_client JOIN LCF USING(loan_client_id))::bigint[]) LDR USING(loan_id)
          LEFT JOIN collect.get_loan_client_debt_rest((SELECT array_agg(loan_client_id) FROM LCF)::bigint[]) LCDR ON LC.loan_client_id = LCDR.loan_client_id
          LEFT JOIN (
            SELECT
              DISTINCT ON (LC.loan_client_id)
              LC.loan_client_id,
              collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS client_title,
              CASE
                WHEN LCP.payer_client_id IS NULL THEN LCP.payer
                ELSE collect.get_client_title(CP_P.first_name, CP_P.second_name, CP_P.third_name)
              END AS payer_title,
              LCP.date,
              LCP.sum,
              LCP.number,
              LCP.comment
            FROM
              collect.loan_client_payment LCP
              LEFT JOIN collect.client_person CP_P ON CP_P.client_id = payer_client_id
              JOIN LCF USING(loan_client_id)
              JOIN collect.loan_client LC USING(loan_client_id)
              LEFT JOIN collect.client_person CP ON CP.client_id = LC.client_id
            ORDER BY LC.loan_client_id, LCP.date ASC, LCP.loan_client_payment_id ASC
          ) LCPF ON LC.loan_client_id = LCPF.loan_client_id
          LEFT JOIN (
            SELECT
              DISTINCT ON (LC.loan_client_id)
              LC.loan_client_id,
              collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS client_title,
              CASE
                WHEN LCP.payer_client_id IS NULL THEN LCP.payer
                ELSE collect.get_client_title(CP_P.first_name, CP_P.second_name, CP_P.third_name)
              END AS payer_title,
              LCP.date,
              LCP.sum,
              LCP.number,
              LCP.comment
            FROM
              collect.loan_client_payment LCP
              LEFT JOIN collect.client_person CP_P ON CP_P.client_id = payer_client_id
              JOIN LCF USING(loan_client_id)
              JOIN collect.loan_client LC USING(loan_client_id)
              LEFT JOIN collect.client_person CP ON CP.client_id = LC.client_id
            ORDER BY LC.loan_client_id, LCP.date DESC, LCP.loan_client_payment_id DESC
          ) LCPL ON LC.loan_client_id = LCPL.loan_client_id
          LEFT JOIN collect.client_bankrupt_last(ARRAY[NULL]::bigint[]) CBL ON CBL.client_id = LC.client_id
          LEFT JOIN collect.client_bankrupt CB USING(client_bankrupt_id)
          LEFT JOIN collect.bankrupt_type BT USING(bankrupt_type_id)
          LEFT JOIN collect.court CB_C ON CB.court_id = CB_C.court_id
          LEFT JOIN collect.address_region CB_C_AR ON CB_C.address_region_id = CB_C_AR.address_region_id
          LEFT JOIN collect.loan_client_interaction_limit LCIL ON LC.loan_client_id = LCIL.loan_client_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientSocialForExportSqlQuery">
      <Text>
        WITH LCF AS (
          SELECT
            loan_client_id
          FROM
            collect.loan_client
          WHERE
            loan_client_id = ANY({LoanClientId}::bigint[]) OR
            ({LoanId} IS NOT NULL AND {ClientId} IS NOT NULL AND loan_id = {LoanId} AND client_id = {ClientId})
        )
        SELECT
          LC.loan_client_id AS "LoanClientId",
          row_number() OVER(PARTITION BY LC.loan_client_id ORDER BY LC.loan_client_id, CS.client_social_id) AS "SocialTableRowNumber",
          CASE WHEN SW.title = 'Другое' AND COALESCE(CS.social_website,'') != '' THEN CS.social_website ELSE SW.title END AS "SocialTableWebsite",
          CS.link AS "SocialTableLink"
        FROM
          collect.loan_client LC
          JOIN LCF USING(loan_client_id)
          JOIN collect.client_social CS USING(client_id)
          LEFT JOIN collect.social_website SW USING(social_website_id)
        ORDER BY LC.loan_client_id, CS.client_social_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientPhoneForExportSqlQuery">
      <Text>
        WITH LCF AS (
          SELECT
            loan_client_id
          FROM
            collect.loan_client
          WHERE
            loan_client_id = ANY({LoanClientId}::bigint[]) OR
            ({LoanId} IS NOT NULL AND {ClientId} IS NOT NULL AND loan_id = {LoanId} AND client_id = {ClientId})
        )
        SELECT
          LC.loan_client_id AS "LoanClientId",
          row_number() OVER(PARTITION BY LC.loan_client_id ORDER BY LC.loan_client_id, CP.client_phone_id) AS "PhoneTableRowNumber",
          CP.phone_number AS "PhoneTablePhoneNumber",
          CASE WHEN PT.title = 'Другой' AND COALESCE(CP.phone_type,'') != '' THEN CP.phone_type ELSE PT.title END AS "PhoneTablePhoneType",
          CASE WHEN CPT.title = 'Другой' AND COALESCE(CP.contact_person_type,'') != '' THEN CP.contact_person_type ELSE CPT.title END AS "PhoneTableContactPersonType",
          CP.contact_person AS "PhoneTableContactPerson",
          CP.comment AS "PhoneTableComment"
        FROM
          collect.loan_client LC
          JOIN LCF USING(loan_client_id)
          JOIN collect.client_phone CP USING(client_id)
          LEFT JOIN collect.phone_type PT USING(phone_type_id)
          LEFT JOIN collect.contact_person_type CPT USING(contact_person_type_id)
        ORDER BY LC.loan_client_id, CP.client_phone_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientAddressForExportSqlQuery">
      <Text>
        WITH LCF AS (
          SELECT
            loan_client_id
          FROM
            collect.loan_client
          WHERE
            loan_client_id = ANY({LoanClientId}::bigint[]) OR
            ({LoanId} IS NOT NULL AND {ClientId} IS NOT NULL AND loan_id = {LoanId} AND client_id = {ClientId})
        )
        SELECT
          LC.loan_client_id AS "LoanClientId",
          row_number() OVER(PARTITION BY LC.loan_client_id ORDER BY LC.loan_client_id, CA.address_type_id, CA.address_id) AS "AddressTableRowNumber",
          CASE WHEN AT.title = 'Другой' AND COALESCE(CA.address_type,'') != '' THEN CA.address_type ELSE AT.title END AS "AddressTableAddressType",
          CASE WHEN COALESCE(A.address_string,'') = '' THEN GAS.address_string ELSE A.address_string END AS "AddressTableAddress"
        FROM
          collect.loan_client LC
          JOIN LCF USING(loan_client_id)
          JOIN collect.client_address CA USING(client_id)
          JOIN collect.address A USING(address_id)
          LEFT JOIN collect.address_type AT USING(address_type_id)
          LEFT JOIN collect.get_address_string(A.address_id) GAS USING(address_id)
        ORDER BY LC.loan_client_id, CA.address_type_id, CA.address_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientPropertyMovableForExportSqlQuery">
      <Text>
        WITH LCF AS (
          SELECT
            loan_client_id
          FROM
            collect.loan_client
          WHERE
            loan_client_id = ANY({LoanClientId}::bigint[]) OR
            ({LoanId} IS NOT NULL AND {ClientId} IS NOT NULL AND loan_id = {LoanId} AND client_id = {ClientId})
        )
        SELECT
          LC.loan_client_id AS "LoanClientId",
          row_number() OVER(PARTITION BY LC.loan_client_id ORDER BY LC.loan_client_id, CP.client_property_id) AS "PropertyMovableTableRowNumber",
          CP.title AS "PropertyMovableTablePropertyTitle",
          CP.price AS "PropertyMovableTablePrice", --NUMERIC
          CP.share AS "PropertyMovableTableShare",
          CASE WHEN CP.is_pledged THEN 'Да' ELSE 'Нет' END AS "PropertyMovableTableIsPledged",
          CP.pledge_date AS "PropertyMovableTablePledgeDate", --DATE
          CP.pledge_price AS "PropertyMovableTablePledgePrice", --NUMERIC
          CP.description AS "PropertyMovableTableDescription"
        FROM
          collect.loan_client LC
          JOIN LCF USING(loan_client_id)
          JOIN collect.client_property CP USING(client_id)
          JOIN collect.client_property_movable CPM USING(client_property_id)
        ORDER BY LC.loan_client_id, CP.client_property_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientPropertyRealForExportSqlQuery">
      <Text>
        WITH LCF AS (
          SELECT
            loan_client_id
          FROM
            collect.loan_client
          WHERE
            loan_client_id = ANY({LoanClientId}::bigint[]) OR
            ({LoanId} IS NOT NULL AND {ClientId} IS NOT NULL AND loan_id = {LoanId} AND client_id = {ClientId})
        )
        SELECT
          LC.loan_client_id AS "LoanClientId",
          row_number() OVER(PARTITION BY LC.loan_client_id ORDER BY LC.loan_client_id, CP.client_property_id) AS "PropertyRealTableRowNumber",
          CP.title AS "PropertyRealTablePropertyTitle",
          CP.price AS "PropertyRealTablePrice", --NUMERIC
          CP.share AS "PropertyRealTableShare",
          CASE WHEN CP.is_pledged THEN 'Да' ELSE 'Нет' END AS "PropertyRealTableIsPledged",
          CP.pledge_date AS "PropertyRealTablePledgeDate", --DATE
          CP.pledge_price AS "PropertyRealTablePledgePrice", --NUMERIC
          CP.description AS "PropertyRealTableDescription"
        FROM
          collect.loan_client LC
          JOIN LCF USING(loan_client_id)
          JOIN collect.client_property CP USING(client_id)
          JOIN collect.client_property_real CPR USING(client_property_id)
        ORDER BY LC.loan_client_id, CP.client_property_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientPropertyCompanyForExportSqlQuery">
      <Text>
        WITH LCF AS (
          SELECT
            loan_client_id
          FROM
            collect.loan_client
          WHERE
            loan_client_id = ANY({LoanClientId}::bigint[]) OR
            ({LoanId} IS NOT NULL AND {ClientId} IS NOT NULL AND loan_id = {LoanId} AND client_id = {ClientId})
        )
        SELECT
          LC.loan_client_id AS "LoanClientId",
          row_number() OVER(PARTITION BY LC.loan_client_id ORDER BY LC.loan_client_id, CP.client_property_id) AS "PropertyCompanyTableRowNumber",
          CP.title AS "PropertyCompanyTablePropertyTitle",
          CP.price AS "PropertyCompanyTablePrice", --NUMERIC
          CP.share AS "PropertyCompanyTableShare",
          CASE WHEN CP.is_pledged THEN 'Да' ELSE 'Нет' END AS "PropertyCompanyTableIsPledged",
          CP.pledge_date AS "PropertyCompanyTablePledgeDate", --DATE
          CP.pledge_price AS "PropertyCompanyTablePledgePrice", --NUMERIC
          CP.description AS "PropertyCompanyTableDescription"
        FROM
          collect.loan_client LC
          JOIN LCF USING(loan_client_id)
          JOIN collect.client_property CP USING(client_id)
          JOIN collect.client_property_company CPC USING(client_property_id)
        ORDER BY LC.loan_client_id, CP.client_property_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientAccountForExportSqlQuery">
      <Text>
        WITH LCF AS (
          SELECT
            loan_client_id
          FROM
            collect.loan_client
          WHERE
            loan_client_id = ANY({LoanClientId}::bigint[]) OR
            ({LoanId} IS NOT NULL AND {ClientId} IS NOT NULL AND loan_id = {LoanId} AND client_id = {ClientId})
        )
        SELECT
          LC.loan_client_id AS "LoanClientId",
          row_number() OVER(PARTITION BY LC.loan_client_id ORDER BY LC.loan_client_id, CA.client_account_id) AS "AccountTableRowNumber",
          CA.bank_title AS "AccountTableBankTitle",
          CA.bank_requisite AS "AccountTableBankRequisite",
          CA.account AS "AccountTableAccount",
          CA.description AS "AccountTableDescription",
          CA.arrest_date AS "AccountTableArrestDate", --DATE
          CASE WHEN CA.is_salary_account THEN 'Да' ELSE 'Нет' END AS "AccountTableIsSalaryAccount"
        FROM
          collect.loan_client LC
          JOIN LCF USING(loan_client_id)
          JOIN collect.client_account CA USING(client_id)
        ORDER BY LC.loan_client_id, CA.client_account_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientJurisdictionForExportSqlQuery">
      <Text>
        WITH LCF AS (
          SELECT
            loan_client_id
          FROM
            collect.loan_client
          WHERE
            loan_client_id = ANY({LoanClientId}::bigint[]) OR
            ({LoanId} IS NOT NULL AND {ClientId} IS NOT NULL AND loan_id = {LoanId} AND client_id = {ClientId})
        )
        SELECT
          LC.loan_client_id AS "LoanClientId",
          row_number() OVER (PARTITION BY LC.loan_client_id ORDER BY LC.loan_client_id, CJ.client_jurisdiction_id ASC) AS "JurisdictionTableRowNumber",
          C.title AS "JurisdictionTableCourtTitle",
          C.title_genitive AS "JurisdictionTableCourtTitleGenitive",
          AR.title AS "JurisdictionTableCourtRegion",
          C.address AS "JurisdictionTableCourtAddress",
          C.receiver AS "JurisdictionTableCourtReceiver",
          C.receiver_bank AS "JurisdictionTableCourtReceiverBank",
          C.receiver_bank_city AS "JurisdictionTableCourtReceiverBankCity",
          C.inn AS "JurisdictionTableCourtInn",
          C.kpp AS "JurisdictionTableCourtKpp",
          C.correspondent_account AS "JurisdictionTableCourtCorrespondentAccount",
          C.account AS "JurisdictionTableCourtAccount",
          C.bik AS "JurisdictionTableCourtBik",
          C.oktmo AS "JurisdictionTableCourtOktmo",
          C.kbk AS "JurisdictionTableCourtKbk",
          C.phone AS "JurisdictionTableCourtPhone",
          C.email AS "JurisdictionTableCourtEmail",
          C.site AS "JurisdictionTableCourtSite",
          O.title AS "JurisdictionTableOspTitle",
          O.address AS "JurisdictionTableOspAddress",
          O.ufssp_title AS "JurisdictionTableOspUfsspTitle",
          O.phone AS "JurisdictionTableOspPhone"
        FROM
          collect.loan_client LC
          JOIN LCF USING(loan_client_id)
          LEFT JOIN collect.client_jurisdiction CJ USING(client_id)
          LEFT JOIN collect.court C USING(court_id)
          LEFT JOIN collect.address_region AR USING(address_region_id)
          LEFT JOIN collect.osp O USING(osp_id)
        ORDER BY LC.loan_client_id, CJ.client_jurisdiction_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanClientRepaymentForExportSqlQuery">
      <Text>
        WITH LCF AS (
          SELECT
            loan_client_id
          FROM
            collect.loan_client
          WHERE
            loan_client_id = ANY({LoanClientId}::bigint[]) OR
            ({LoanId} IS NOT NULL AND {ClientId} IS NOT NULL AND loan_id = {LoanId} AND client_id = {ClientId})
        ), P AS (
          SELECT
            LC.loan_client_id,
            SUM(LCP.sum) AS total_payment
          FROM
            collect.loan_client_payment LCP
            JOIN collect.loan_client LC USING(loan_client_id)
          WHERE
            LCP.loan_client_id = ANY({LoanClientId}::bigint[]) AND
            LCP.date >= LC.repayment_date
          GROUP BY LC.loan_client_id
        )
        SELECT
          LCR.loan_client_id AS "LoanClientId",
          row_number() OVER (PARTITION BY LCR.loan_client_id ORDER BY LCR.loan_client_id, LCR.date ASC) AS "RepaymentTableRowNumber",
          LCR.date AS "RepaymentTableDate", --DATE
          CASE WHEN
            SUM(LCR.sum) OVER (PARTITION BY LCR.loan_client_id ORDER BY LCR.loan_client_id, LCR.date ASC) > COALESCE(P.total_payment, 0)
          THEN 'Не оплачено' ELSE 'Оплачено' END AS "RepaymentTableStatus",
          LCR.sum AS "RepaymentTableSum" --NUMERIC
        FROM
          collect.loan_client_repayment LCR
          JOIN LCF USING(loan_client_id)
          LEFT JOIN P USING(loan_client_id)
        ORDER BY
          LCR.loan_client_id, LCR.date ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanPaymentForExportSqlQuery">
      <Text>
        WITH LCF AS (
          SELECT
            loan_client_id
          FROM
            collect.loan_client
          WHERE
            loan_client_id = ANY({LoanClientId}::bigint[]) OR
            ({LoanId} IS NOT NULL AND {ClientId} IS NOT NULL AND loan_id = {LoanId} AND client_id = {ClientId})
        ), LCA AS (
          SELECT
            loan_id,
            array_agg(LC.loan_client_id) AS loan_client_id_array
          FROM
            collect.loan_client LC
          WHERE
            loan_id IN (SELECT DISTINCT loan_id FROM collect.loan_client JOIN LCF USING(loan_client_id))
          GROUP BY
            loan_id
        )
        SELECT
          LCA.loan_client_id_array AS "LoanClientIdArray",
          row_number() OVER (PARTITION BY LC.loan_id ORDER BY LC.loan_id, LCP.date ASC, LCP.loan_client_payment_id ASC) AS "PaymentLoanTableRowNumber",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "PaymentLoanTableClientTitle",
          CASE
            WHEN LCP.payer_client_id IS NULL THEN LCP.payer
            ELSE collect.get_client_title(CP_P.first_name, CP_P.second_name, CP_P.third_name)
          END AS "PaymentLoanTablePayerTitle",
          LCP.date AS "PaymentLoanTableDate", --DATE
          LCP.sum AS "PaymentLoanTableSum", --NUMERIC
          LCP.number AS "PaymentLoanTableNumber",
          LCP.comment AS "PaymentLoanTableComment"
        FROM
          collect.loan_client_payment LCP
          LEFT JOIN collect.loan_client LC USING(loan_client_id)
          JOIN LCA USING(loan_id)
          LEFT JOIN collect.client_person CP ON LC.client_id = CP.client_id
          LEFT JOIN collect.client_person CP_P ON LCP.payer_client_id = CP_P.client_id
        ORDER BY LC.loan_id, LCP.date ASC, LCP.loan_client_payment_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanClientPaymentForExportSqlQuery">
      <Text>
        WITH LCF AS (
          SELECT
            loan_client_id
          FROM
            collect.loan_client
          WHERE
            loan_client_id = ANY({LoanClientId}::bigint[]) OR
            ({LoanId} IS NOT NULL AND {ClientId} IS NOT NULL AND loan_id = {LoanId} AND client_id = {ClientId})
        )
        SELECT
          LCP.loan_client_id AS "LoanClientId",
          row_number() OVER (PARTITION BY LCP.loan_client_id ORDER BY LCP.loan_client_id, LCP.date ASC, LCP.loan_client_payment_id ASC) AS "PaymentLoanClientTableRowNumber",
          CASE
            WHEN LCP.payer_client_id IS NULL THEN LCP.payer
            ELSE collect.get_client_title(CP.first_name, CP.second_name, CP.third_name)
          END AS "PaymentLoanClientTablePayerTitle",
          LCP.date AS "PaymentLoanClientTableDate", --DATE
          LCP.sum AS "PaymentLoanClientTableSum", --NUMERIC
          LCP.number AS "PaymentLoanClientTableNumber",
          LCP.comment AS "PaymentLoanClientTableComment"
        FROM
          collect.loan_client_payment LCP
          LEFT JOIN collect.loan_client LC USING(loan_client_id)
          LEFT JOIN collect.client_person CP ON CP.client_id = LC.client_id
          JOIN LCF USING(loan_client_id)
        ORDER BY LCP.loan_client_id, LCP.date ASC, LCP.loan_client_payment_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanPostFromExportInsertSqlQuery">
      <Text>
        WITH client AS (
          SELECT
            client_id,
            collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS full_title
          FROM
            collect.loan_client
            LEFT JOIN collect.client_person CP USING(client_id)
          WHERE
            loan_client_id = {LoanClientId}
        ), registration_address AS (
          SELECT
            DISTINCT ON (C.client_id)
            C.client_id,
            CASE
              WHEN COALESCE(A.address_string, '') = '' THEN GAS.address_string
              ELSE A.address_string
            END AS registration_address
          FROM
            client C
            LEFT JOIN collect.client_address CA USING(client_id)
            LEFT JOIN collect.address A USING(address_id)
            LEFT JOIN collect.address_type ATP USING (address_type_id)
            LEFT JOIN collect.get_address_string(A.address_id) GAS USING(address_id)
          WHERE
            ATP.title = 'Регистрация'
          ORDER BY C.client_id, CA.address_id DESC
        ), client_info AS (
          SELECT
            C.client_id,
            C.full_title,
            RA.registration_address
          FROM
            client C
            LEFT JOIN registration_address RA USING(client_id)
        )
        SELECT
          collect.loan_post_file_insert(
            (
            SELECT
              collect.loan_post_insert(
              LC.loan_client_id,
              NULL::bigint,
              false,
              {Number}::bigint,
              {RegisterDate}::date,
              NULL::date,
              true,
              CI.full_title,
              CI.registration_address,
              C.inner_org_id,
              IO.actual_address,
              NULL::character varying,
              NULL::character varying,
              {UserId}::smallint)
            FROM
              collect.loan_client LC
              LEFT JOIN client_info CI USING(client_id)
              LEFT JOIN collect.loan L USING(loan_id)
              LEFT JOIN collect.cession C USING(cession_id)
              LEFT JOIN collect.inner_org IO USING(inner_org_id)
            WHERE
              LC.loan_client_id = {LoanClientId}
            ),
            F.file_id,
            {TemplateId}::bigint,
            {Description}::character varying,
            {UserId}::smallint
          )
        FROM
          public.file F
        WHERE
          guid = {Guid};
      </Text>
    </SqlQuery>

    <!-- запрос для стартовой формы -->
    <SqlQuery Name="LoanClientSelectSqlQuery">
      <Text>
        WITH filtered_loan_client AS (
          SELECT
            loan_client_id
          FROM
            collect.filtered_loan_client(
              {Archive}::boolean,
              {UserId}::smallint,
              {CessionId}::bigint[],
              {ClaimantId}::bigint[],
              {InnerOrgId}::bigint[],
              {CreditNumber}::character varying,
              {LoanDebtTotalFrom}::numeric,
              {LoanDebtTotalTo}::numeric,
              {LoanDebtRestTotalFrom}::numeric,
              {LoanDebtRestTotalTo}::numeric,
              {ClientTitle}::character varying,
              {BirthDateFrom}::date,
              {BirthDateTo}::date,
              {RegistrationAddress}::character varying,
              {ActualAddress}::character varying,
              {RoleId}::integer[],
              {CommentNotificationDateFrom}::date,
              {CommentNotificationDateTo}::date,
              {RepaymentDateFrom}::date,
              {RepaymentDateTo}::date,
              {LoanClientDebtTotalFrom}::numeric,
              {LoanClientDebtTotalTo}::numeric,
              {LoanClientPaymentFrom}::numeric,
              {LoanClientPaymentTo}::numeric,
              {LoanClientPaymentDateFrom}::date,
              {LoanClientPaymentDateTo}::date,
              {LoanClientDebtRestTotalFrom}::numeric,
              {LoanClientDebtRestTotalTo}::numeric,
              {LoanClientUserId}::smallint[],
              {LoanClientStatusId}::bigint[],
              {LoanClientStatus2Id}::bigint[],
              {LoanClientStatus3Id}::bigint[],
              {SuccessionCourtId}::bigint[],
              {SuccessionCourtDocumentId}::integer[],
              {SuccessionDocumentNumber}::character varying,
              {SuccessionDocumentDateFrom}::date,
              {SuccessionDocumentDateTo}::date,
              {SuccessionDuplicateGetDateFrom}::date,
              {SuccessionDuplicateGetDateTo}::date,
              {SuccessionDuplicateCourtDateFrom}::date,
              {SuccessionDuplicateCourtDateTo}::date,
              {SuccessionCourtDateFrom}::date,
              {SuccessionCourtDateTo}::date,
              {CollectionDocumentTitle}::character varying,
              {CollectionCaseNumber}::character varying,
              {CollectionSendDateFrom}::date,
              {CollectionSendDateTo}::date,
              {CollectionLegalDateFrom}::date,
              {CollectionLegalDateTo}::date,
              {CollectionDocumentGetDateFrom}::date,
              {CollectionDocumentGetDateTo}::date,
              {CollectionCancelDateFrom}::date,
              {CollectionCancelDateTo}::date,
              {ExecutiveOspId}::bigint[],
              {ExecutiveUfsspOspId}::bigint[],
              {ExecutiveSendDateFrom}::date,
              {ExecutiveSendDateTo}::date,
              {ExecutiveStartDateFrom}::date,
              {ExecutiveStartDateTo}::date,
              {ExecutiveNumber}::character varying,
              {ExecutiveReplacementSendDateFrom}::date,
              {ExecutiveReplacementSendDateTo}::date,
              {ExecutiveRequest}::character varying,
              {ExecutiveEndDateFrom}::date,
              {ExecutiveEndDateTo}::date,
              {ExecutiveReSendDateFrom}::date,
              {ExecutiveReSendDateTo}::date)
        ), S AS (
          SELECT
            LC.loan_client_id
          FROM
            collect.loan_client LC
            JOIN filtered_loan_client USING(loan_client_id)
          ORDER BY LC.loan_id, LC.loan_client_id
        ), R AS (
          SELECT
            count(*) AS total_rows,
            COALESCE(CEIL(count(*)::numeric/GREATEST(COALESCE({RowsPerPage}, count(*))::numeric, 1)), 1) AS total_pages
          FROM
            S
        ), final AS (
          SELECT
            row_number() over() AS "RowNumber",
            (SELECT R.total_rows FROM R) AS "TotalRows",
            (SELECT R.total_pages FROM R) AS "TotalPages",
            *
          FROM
            S
          LIMIT COALESCE({RowsPerPage}, (SELECT R.total_rows FROM R))
          OFFSET (GREATEST((LEAST((SELECT R.total_pages FROM R), COALESCE({CurrentPage}, 1)) - 1)::integer, 0) * COALESCE({RowsPerPage}, (SELECT R.total_rows FROM R)))
        ), comment_loan_client AS (
          SELECT
            DISTINCT ON (LC.loan_client_id)
            LC.loan_client_id,
            LC.comment,
            LC.loan_comment_id,
            LC.notification_date
          FROM
            final F
            LEFT JOIN collect.loan_comment LC USING(loan_client_id)
          WHERE
            LC.notification_date IS NOT NULL AND
            LC.execution_date IS NULL AND
            LC.loan_client_id IS NOT NULL
          ORDER BY LC.loan_client_id, LC.notification_date DESC, LC.loan_comment_id DESC
        ), comment_loan AS (
          SELECT
            DISTINCT ON (LCL.loan_client_id)
            LCL.loan_client_id,
            LC.comment,
            LC.loan_comment_id,
            LC.notification_date
          FROM
            final F
            LEFT JOIN collect.loan_client LCL USING(loan_client_id)
            LEFT JOIN collect.loan_comment LC USING(loan_id)
          WHERE
            LC.notification_date IS NOT NULL AND
            LC.execution_date IS NULL AND
            LC.loan_id IS NOT NULL
          ORDER BY LCL.loan_client_id, LC.notification_date DESC, LC.loan_comment_id DESC
        ), comment_total AS (
          SELECT
            loan_client_id,
            notification_date,
            comment,
            loan_comment_id
          FROM
            comment_loan_client

          UNION ALL

          SELECT
            loan_client_id,
            notification_date,
            comment,
            loan_comment_id
          FROM
            comment_loan
        ), comment_result AS (
          SELECT
            DISTINCT ON (loan_client_id)
            loan_client_id,
            notification_date,
            comment
          FROM
            comment_total
          ORDER BY loan_client_id, notification_date DESC, loan_comment_id DESC
        ), dates AS (
          SELECT
            date_trunc('month', collect.convert_date_now())::date AS cm_date,
            date_trunc('month', collect.convert_date_now() + interval '1 month')::date AS nm_date,
            date_trunc('month', collect.convert_date_now() - interval '1 month')::date AS pm_date
        ), loan_client_payment_current_month AS (
          SELECT
            SUM(LCP.sum) AS payment_sum,
            F.loan_client_id
          FROM
            final F
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_id)
            LEFT JOIN dates D ON true
          WHERE
            LCP.date >= D.cm_date AND
            LCP.date <![CDATA[<]]> D.nm_date
          GROUP BY F.loan_client_id
        ), loan_client_payment_previous_month AS (
          SELECT
            SUM(LCP.sum) AS payment_sum,
            F.loan_client_id
          FROM
            final F
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_id)
            LEFT JOIN dates D ON true
          WHERE
            LCP.date >= D.pm_date AND
            LCP.date <![CDATA[<]]> D.cm_date
          GROUP BY F.loan_client_id
        ), registration_address AS (
          SELECT
            DISTINCT ON (LC.client_id)
            LC.client_id,
            CA.address_id,
            A.address_string
          FROM
            final F
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN collect.client_address CA USING(client_id)
            LEFT JOIN collect.address A USING(address_id)
            LEFT JOIN collect.address_type ATP USING (address_type_id)
          WHERE
            ATP.title = 'Регистрация'
          ORDER BY LC.client_id, CA.address_id DESC
        ), actual_address AS (
          SELECT
            DISTINCT ON (LC.client_id)
            LC.client_id,
            CA.address_id,
            A.address_string
          FROM
            final F
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN collect.client_address CA USING(client_id)
            LEFT JOIN collect.address A USING(address_id)
            LEFT JOIN collect.address_type ATP USING (address_type_id)
          WHERE
            ATP.title = 'Проживание'
          ORDER BY LC.client_id, CA.address_id DESC
        ), all_address AS (
          SELECT
            DISTINCT ON (GAS.address_id)
            GAS.address_id,
            GAS.address_string
          FROM
            final F
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN collect.get_address_string() GAS USING(client_id)
        ), client_registration_address AS (
          SELECT
            RA.client_id,
            CASE
              WHEN COALESCE(RA.address_string, '') = '' THEN GAS.address_string
              ELSE RA.address_string
            END AS registration_address
          FROM
            registration_address RA
            LEFT JOIN all_address GAS USING (address_id)
        ), client_actual_address AS (
          SELECT
            AA.client_id,
            CASE
              WHEN COALESCE(AA.address_string, '') = '' THEN GAS.address_string
              ELSE AA.address_string
            END AS actual_address
          FROM
            actual_address AA
            LEFT JOIN all_address GAS USING (address_id)
        ), loan_client_payment AS (
          SELECT
            F.loan_client_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            final F
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_id)
          GROUP BY F.loan_client_id
        ), loan_client_repayment_payment AS (
          SELECT
            F.loan_client_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            final F
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_id)
          WHERE
            LCP.date >= LC.repayment_date
          GROUP BY F.loan_client_id
        ), loan_payment AS (
          SELECT
            LC.loan_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            final F
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_id)
          GROUP BY LC.loan_id
        ), pochtaru_orders AS (
          SELECT
            F.loan_client_id,
            COUNT(LCO.order_id) AS count
          FROM
            final F
            LEFT JOIN collect.loan_client LC ON F.loan_client_id = LC.loan_client_id
            LEFT JOIN collect.loan L USING (loan_id)
            LEFT JOIN collect.loan_client LC2 ON L.loan_id = LC2.loan_client_id
            LEFT JOIN collect.pochtaru_order_view LCO ON LCO.loan_client_id = LC2.loan_client_id AND LCO.state = 'ADDED'
          GROUP BY
            F.loan_client_id
        ), ts_loan_client_salary AS (
          SELECT T1.loan_client_id as loan_client_id, T1.comment, T1.create_date
          FROM collect.loan_comment T1
          INNER JOIN (
            SELECT loan_client_id, MAX(loan_comment_id) as max_comment_id
            FROM collect.loan_comment
            WHERE task_type_id = 10
            GROUP BY loan_client_id
          ) T2 ON T1.loan_client_id = T2.loan_client_id AND T1.loan_comment_id = T2.max_comment_id
        ), ts_loan_client_last_egpu AS (
          SELECT T1.loan_client_id as loan_client_id, T1.comment, T1.create_date
          FROM collect.loan_comment T1
          INNER JOIN (
            SELECT loan_client_id, MAX(loan_comment_id) as max_comment_id
            FROM collect.loan_comment
            WHERE task_type_id = 7
            GROUP BY loan_client_id
          ) T2 ON T1.loan_client_id = T2.loan_client_id AND T1.loan_comment_id = T2.max_comment_id
        ), client_interaction AS (
          SELECT LC.client_id, LCI.*
          FROM
            collect.loan_client_interaction LCI
            LEFT JOIN collect.loan_client LC USING (loan_client_id)
        ), last_interaction AS (
          SELECT T1.client_id, description, notification_date
          FROM client_interaction T1
          INNER JOIN (
            SELECT client_id, MAX(loan_client_interaction_id) as max_id
            FROM client_interaction
            GROUP BY client_id
          ) T2 ON T1.loan_client_interaction_id = T2.max_id
        )

        SELECT
          F."RowNumber",
          F."TotalRows",
          F."TotalPages",
          F.loan_client_id AS "LoanClientId",
          LC.loan_id AS "LoanId",
          C.claimant_id AS "ClaimantId",
          L.cession_id AS "CessionId",
          LC.role_id AS "RoleId",
          LC.user_id AS "LoanClientUserId",
          LC.status_id AS "LoanClientStatusId",
          LC.status2_id as "LoanClientStatus2Id",
          LC.status3_id as "LoanClientStatus3Id",
          LCME.comment as "TsEgpuComment",
          LCME.create_date as "TsEgpuCommentDate",
          LCMS.create_date as "TsSalaryDate",
          LLCI.description as "TsLastInteractionDescription",
          LLCI.notification_date as "TsLastInteractionNotificationDate",
          C.inner_org_id AS "InnerOrgId",
          LCS.court_id AS "SuccessionCourtId",
          LCS.court_document_id AS "SuccessionCourtDocumentId",
          LCE.osp_id AS "ExecutiveOspId",
          CR.notification_date AS "CommentNotificationDate",
          CR.comment AS "TsComment",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "ClientTitle",
          CP.email AS "ClientEmail",
          CP.inn as "ClientInn",
          CP.client_id AS "ClientId",
          L.credit_number AS "LoanCreditNumber",
          CASE
            WHEN LC.repayment_date IS NULL THEN COALESCE(LC.debt_base, 0) + COALESCE(LC.debt_percent, 0) + COALESCE(LC.debt_penalty, 0) + COALESCE(LC.debt_tax, 0)
            ELSE COALESCE(LC.repayment_sum, 0)
          END AS "LoanClientDebtTotal",
          CASE
            WHEN LC.repayment_date IS NULL THEN COALESCE(LCP.total_payment_sum, 0)
            ELSE COALESCE(LCRP.total_payment_sum, 0)
          END AS "LoanClientPaymentTotal",
          CASE
            WHEN LC.repayment_date IS NULL THEN GREATEST(COALESCE(LC.debt_base, 0) + COALESCE(LC.debt_percent, 0) + COALESCE(LC.debt_penalty, 0) + COALESCE(LC.debt_tax, 0) - COALESCE(LCP.total_payment_sum, 0), 0)
            ELSE GREATEST(COALESCE(LC.repayment_sum, 0) - COALESCE(LCRP.total_payment_sum, 0), 0)
          END AS "LoanClientDebtRestTotal",
          COALESCE(LCP_CM.payment_sum, 0) AS "LoanClientPaymentCurrentMonth",
          COALESCE(LCP_PM.payment_sum, 0) AS "LoanClientPaymentPreviousMonth",
          COALESCE(L.debt_base, 0) + COALESCE(L.debt_percent, 0) + COALESCE(L.debt_penalty, 0) + COALESCE(L.debt_tax, 0) AS "LoanDebtTotal",
          GREATEST(COALESCE(L.debt_base, 0) + COALESCE(L.debt_percent, 0) + COALESCE(L.debt_penalty, 0) + COALESCE(L.debt_tax, 0) - COALESCE(LP.total_payment_sum, 0), 0) AS "LoanDebtRestTotal",
          CRA.registration_address AS "ClientRegistrationAddress",
          CAA.actual_address AS "ClientActualAddress",
          CP.birth_date AS "ClientBirthDate",
          LCS.document_number AS "SuccessionDocumentNumber",
          LCS.document_date AS "SuccessionDocumentDate",
          LCS.duplicate_get_date AS "SuccessionDuplicateGetDate",
          LCS.duplicate_court_date AS "SuccessionDuplicateCourtDate",
          LCS.court_date AS "SuccessionCourtDate",
          COALESCE(LCC_CD.title || ' ', '') || COALESCE(LCC.court_document_number, '') AS "CollectionDocumentTitle",
          LCC.legal_date AS "CollectionLegalDate",
          LCC.document_get_date AS "CollectionDocumentGetDate",
          LCC.application_type_id AS "CollectionApplicationTypeId",
          LCC.application_sum AS "CollectionApplicationSum",
          LCC.case_number AS "CollectionCaseNumber",
          CC.title AS "CollectionApplicationCourtTitle",
          LCC.application_tax AS "CollectionApplicationTax",
          LCE.send_date AS "ExecutiveSendDate",
          LCE.start_date AS "ExecutiveStartDate",
          LCE.number AS "ExecutiveNumber",
          LCE.replacement_send_date AS "ExecutiveReplacementSendDate",
          LCE.request AS "ExecutiveRequest",
          LCE.end_date AS "ExecutiveEndDate",
          LCE.resend_date AS "ExecutiveReSendDate",
          LC.repayment_date AS "LoanClientRepaymentDate",
          CL.bankrupt_check_date AS "BankruptCheckDate",
          LC.loan_client_id AS "TsLoanClientId",
          L.credit_date AS "CreditDate",
          LCC.court_date AS "CourtDate"
        FROM
          final F
          LEFT JOIN collect.loan_client LC USING(loan_client_id)
          LEFT JOIN collect.client CL USING(client_id)
          LEFT JOIN comment_result CR USING(loan_client_id)
          LEFT JOIN loan_client_payment_current_month LCP_CM USING(loan_client_id)
          LEFT JOIN loan_client_payment_previous_month LCP_PM USING(loan_client_id)
          LEFT JOIN collect.client_person CP USING(client_id)
          LEFT JOIN client_registration_address CRA USING(client_id)
          LEFT JOIN client_actual_address CAA USING(client_id)
          LEFT JOIN loan_client_payment LCP USING(loan_client_id)
          LEFT JOIN loan_client_repayment_payment LCRP USING(loan_client_id)
          LEFT JOIN collect.loan L USING(loan_id)
          LEFT JOIN loan_payment LP USING(loan_id)
          LEFT JOIN collect.cession C USING(cession_id)
          LEFT JOIN collect.loan_client_succession LCS USING(loan_client_id)
          LEFT JOIN collect.loan_client_collection LCC ON LCC.loan_client_id = LC.loan_client_id AND LCC.is_main
          LEFT JOIN collect.court CC ON LCC.court_id = CC.court_id
          LEFT JOIN collect.court_document LCC_CD ON LCC.court_document_id = LCC_CD.court_document_id
          LEFT JOIN collect.loan_client_executive LCE USING(loan_client_collection_id)
          LEFT JOIN ts_loan_client_last_egpu LCME ON LCC.loan_client_id = LCME.loan_client_id
          LEFT JOIN ts_loan_client_salary LCMS ON LCC.loan_client_id = LCMS.loan_client_id
          LEFT JOIN last_interaction LLCI USING (client_id)
        ORDER BY F."RowNumber";
      </Text>
    </SqlQuery>

    <!-- экспорт в Excel с главной формы -->
    <SqlQuery Name="LoanClientForExportSelectSqlQuery">
      <Text>
        WITH filtered_loan_client AS (
          SELECT
            loan_client_id
          FROM
            collect.filtered_loan_client(
              {Archive}::boolean,
              {UserId}::smallint,
              {CessionId}::bigint[],
              {ClaimantId}::bigint[],
              {InnerOrgId}::bigint[],
              {CreditNumber}::character varying,
              {LoanDebtTotalFrom}::numeric,
              {LoanDebtTotalTo}::numeric,
              {LoanDebtRestTotalFrom}::numeric,
              {LoanDebtRestTotalTo}::numeric,
              {ClientTitle}::character varying,
              {BirthDateFrom}::date,
              {BirthDateTo}::date,
              {RegistrationAddress}::character varying,
              {ActualAddress}::character varying,
              {RoleId}::integer[],
              {CommentNotificationDateFrom}::date,
              {CommentNotificationDateTo}::date,
              {RepaymentDateFrom}::date,
              {RepaymentDateTo}::date,
              {LoanClientDebtTotalFrom}::numeric,
              {LoanClientDebtTotalTo}::numeric,
              {LoanClientPaymentFrom}::numeric,
              {LoanClientPaymentTo}::numeric,
              {LoanClientPaymentDateFrom}::date,
              {LoanClientPaymentDateTo}::date,
              {LoanClientDebtRestTotalFrom}::numeric,
              {LoanClientDebtRestTotalTo}::numeric,
              {LoanClientUserId}::smallint[],
              {LoanClientStatusId}::bigint[],
              {LoanClientStatus2Id}::bigint[],
              {LoanClientStatus3Id}::bigint[],
              {SuccessionCourtId}::bigint[],
              {SuccessionCourtDocumentId}::integer[],
              {SuccessionDocumentNumber}::character varying,
              {SuccessionDocumentDateFrom}::date,
              {SuccessionDocumentDateTo}::date,
              {SuccessionDuplicateGetDateFrom}::date,
              {SuccessionDuplicateGetDateTo}::date,
              {SuccessionDuplicateCourtDateFrom}::date,
              {SuccessionDuplicateCourtDateTo}::date,
              {SuccessionCourtDateFrom}::date,
              {SuccessionCourtDateTo}::date,
              {CollectionDocumentTitle}::character varying,
              {CollectionCaseNumber}::character varying,
              {CollectionSendDateFrom}::date,
              {CollectionSendDateTo}::date,
              {CollectionLegalDateFrom}::date,
              {CollectionLegalDateTo}::date,
              {CollectionDocumentGetDateFrom}::date,
              {CollectionDocumentGetDateTo}::date,
              {CollectionCancelDateFrom}::date,
              {CollectionCancelDateTo}::date,
              {ExecutiveOspId}::bigint[],
              {ExecutiveUfsspOspId}::bigint[],
              {ExecutiveSendDateFrom}::date,
              {ExecutiveSendDateTo}::date,
              {ExecutiveStartDateFrom}::date,
              {ExecutiveStartDateTo}::date,
              {ExecutiveNumber}::character varying,
              {ExecutiveReplacementSendDateFrom}::date,
              {ExecutiveReplacementSendDateTo}::date,
              {ExecutiveRequest}::character varying,
              {ExecutiveEndDateFrom}::date,
              {ExecutiveEndDateTo}::date,
              {ExecutiveReSendDateFrom}::date,
              {ExecutiveReSendDateTo}::date)
        ), S AS (
          SELECT
            LC.loan_client_id
          FROM
            collect.loan_client LC
            JOIN filtered_loan_client USING(loan_client_id)
          ORDER BY LC.loan_id, LC.loan_client_id
        ), final AS (
          SELECT
            row_number() over() AS "RowNumber",
            *
          FROM
            S
        ), comment_loan_client AS (
          SELECT
            DISTINCT ON (LC.loan_client_id)
            LC.loan_client_id,
            LC.notification_date
          FROM
            final F
            LEFT JOIN collect.loan_comment LC USING(loan_client_id)
          WHERE
            LC.notification_date IS NOT NULL AND
            LC.execution_date IS NULL AND
            LC.loan_client_id IS NOT NULL
          ORDER BY LC.loan_client_id, LC.notification_date
        ), comment_loan AS (
          SELECT
            DISTINCT ON (LCL.loan_client_id)
            LCL.loan_client_id,
            LC.notification_date
          FROM
            final F
            LEFT JOIN collect.loan_client LCL USING(loan_client_id)
            LEFT JOIN collect.loan_comment LC USING(loan_id)
          WHERE
            LC.notification_date IS NOT NULL AND
            LC.execution_date IS NULL AND
            LC.loan_id IS NOT NULL
          ORDER BY LCL.loan_client_id, LC.notification_date
        ), comment_total AS (
          SELECT
            loan_client_id,
            notification_date
          FROM
            comment_loan_client

          UNION ALL

          SELECT
            loan_client_id,
            notification_date
          FROM
            comment_loan
        ), comment_result AS (
          SELECT
            DISTINCT ON (loan_client_id)
            loan_client_id,
            notification_date
          FROM
            comment_total
          ORDER BY loan_client_id, notification_date
        ), dates AS (
          SELECT
            date_trunc('month', collect.convert_date_now())::date AS cm_date,
            date_trunc('month', collect.convert_date_now() + interval '1 month')::date AS nm_date,
            date_trunc('month', collect.convert_date_now() - interval '1 month')::date AS pm_date
        ), loan_client_payment_current_month AS (
          SELECT
            SUM(LCP.sum) AS payment_sum,
            F.loan_client_id
          FROM
            final F
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_id)
            LEFT JOIN dates D ON true
          WHERE
            LCP.date >= D.cm_date AND
            LCP.date <![CDATA[<]]> D.nm_date
          GROUP BY F.loan_client_id
        ), loan_client_payment_previous_month AS (
          SELECT
            SUM(LCP.sum) AS payment_sum,
            F.loan_client_id
          FROM
            final F
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_id)
            LEFT JOIN dates D ON true
          WHERE
            LCP.date >= pm_date AND
            LCP.date <![CDATA[<]]> cm_date
          GROUP BY F.loan_client_id
        ), registration_address AS (
          SELECT
            DISTINCT ON (LC.client_id)
            LC.client_id,
            CA.address_id,
            A.address_string
          FROM
            final F
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN collect.client_address CA USING(client_id)
            LEFT JOIN collect.address A USING(address_id)
            LEFT JOIN collect.address_type ATP USING (address_type_id)
          WHERE
            ATP.title = 'Регистрация'
          ORDER BY LC.client_id, CA.address_id DESC
        ), actual_address AS (
          SELECT
            DISTINCT ON (LC.client_id)
            LC.client_id,
            CA.address_id,
            A.address_string
          FROM
            final F
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN collect.client_address CA USING(client_id)
            LEFT JOIN collect.address A USING(address_id)
            LEFT JOIN collect.address_type ATP USING (address_type_id)
          WHERE
            ATP.title = 'Проживание'
          ORDER BY LC.client_id, CA.address_id DESC
        ), all_address AS (
          SELECT
            DISTINCT ON (GAS.address_id)
            GAS.address_id,
            GAS.address_string
          FROM
            final F
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN collect.get_address_string() GAS USING(client_id)
        ), client_registration_address AS (
          SELECT
            RA.client_id,
            CASE
              WHEN COALESCE(RA.address_string, '') = '' THEN GAS.address_string
              ELSE RA.address_string
            END AS registration_address
          FROM
            registration_address RA
            LEFT JOIN all_address GAS USING (address_id)
        ), client_actual_address AS (
          SELECT
            AA.client_id,
            CASE
              WHEN COALESCE(AA.address_string, '') = '' THEN GAS.address_string
              ELSE AA.address_string
            END AS actual_address
          FROM
            actual_address AA
            LEFT JOIN all_address GAS USING (address_id)
        ), loan_client_payment AS (
          SELECT
            F.loan_client_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            final F
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_id)
          GROUP BY F.loan_client_id
        ), loan_client_repayment_payment AS (
          SELECT
            F.loan_client_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            final F
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_id)
          WHERE
            LCP.date >= LC.repayment_date
          GROUP BY F.loan_client_id
        ), loan_payment AS (
          SELECT
            LC.loan_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            collect.loan_client_payment LCP
            JOIN collect.loan_client LC USING (loan_client_id)
          GROUP BY LC.loan_id
        )
        SELECT
          F."RowNumber",
          CR.notification_date AS "CommentNotificationDate",
          CL.short_title AS "ClaimantTitle",
          C.title AS "CessionTitle",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "ClientTitle",
          R.title AS "RoleTitle",
          L.credit_number AS "LoanCreditNumber",
          CASE
            WHEN LC.repayment_date IS NULL THEN COALESCE(LC.debt_base, 0) + COALESCE(LC.debt_percent, 0) + COALESCE(LC.debt_penalty, 0) + COALESCE(LC.debt_tax, 0)
            ELSE COALESCE(LC.repayment_sum, 0)
          END AS "LoanClientDebtTotal",
          CASE
            WHEN LC.repayment_date IS NULL THEN COALESCE(LCP.total_payment_sum, 0)
            ELSE COALESCE(LCRP.total_payment_sum, 0)
          END AS "LoanClientPaymentTotal",
          CASE
            WHEN LC.repayment_date IS NULL THEN GREATEST(COALESCE(LC.debt_base, 0) + COALESCE(LC.debt_percent, 0) + COALESCE(LC.debt_penalty, 0) + COALESCE(LC.debt_tax, 0) - COALESCE(LCP.total_payment_sum, 0), 0)
            ELSE GREATEST(COALESCE(LC.repayment_sum, 0) - COALESCE(LCRP.total_payment_sum, 0), 0)
          END AS "LoanClientDebtRestTotal",
          COALESCE(LCP_CM.payment_sum, 0) AS "LoanClientPaymentCurrentMonth",
          COALESCE(LCP_PM.payment_sum, 0) AS "LoanClientPaymentPreviousMonth",
          COALESCE(L.debt_base, 0) + COALESCE(L.debt_percent, 0) + COALESCE(L.debt_penalty, 0) + COALESCE(L.debt_tax, 0) AS "LoanDebtTotal",
          GREATEST(COALESCE(L.debt_base, 0) + COALESCE(L.debt_percent, 0) + COALESCE(L.debt_penalty, 0) + COALESCE(L.debt_tax, 0) - COALESCE(LP.total_payment_sum, 0), 0) AS "LoanDebtRestTotal",
          UI.user_full_name AS "LoanClientUserTitle",
          S.title AS "LoanClientStatusTitle",
          S2.title AS "LoanClientStatus2Title",
          S3.title AS "LoanClientStatus3Title",
          IO.short_title AS "InnerOrgTitle",
          CRA.registration_address AS "ClientRegistrationAddress",
          CAA.actual_address AS "ClientActualAddress",
          CP.birth_date AS "ClientBirthDate",
          CP.inn as "ClientInn",
          bankrupt_check_date AS "BankruptCheckDate",
          LCS_C.title AS "SuccessionCourtTitle",
          LCS_CD.title AS "SuccessionCourtDocumentTitle",
          LCS.document_number AS "SuccessionDocumentNumber",
          LCS.document_date AS "SuccessionDocumentDate",
          LCS.duplicate_get_date AS "SuccessionDuplicateGetDate",
          LCS.duplicate_court_date AS "SuccessionDuplicateCourtDate",
          LCS.court_date AS "SuccessionCourtDate",
          COALESCE(LCC_CD.title || ' ', '') || COALESCE(LCC.court_document_number, '') AS "CollectionDocumentTitle",
          LCC.legal_date AS "CollectionLegalDate",
          LCC.document_get_date AS "CollectionDocumentGetDate",
          LCC_AT.title AS "CollectionApplicationTypeTitle",
          LCC.application_sum AS "CollectionApplicationSum",
          LCC.application_tax AS "CollectionApplicationTax",
          CC.title AS "CollectionApplicationCourtTitle",
          LCC.case_number AS "CollectionCaseNumber",
          O.title AS "ExecutiveOspTitle",
          O.ufssp_title AS "ExecutiveUfsspTitle",
          LCE.send_date AS "ExecutiveSendDate",
          LCE.start_date AS "ExecutiveStartDate",
          LCE.number AS "ExecutiveNumber",
          LCE.replacement_send_date AS "ExecutiveReplacementSendDate",
          LCE.request AS "ExecutiveRequest",
          LCE.end_date AS "ExecutiveEndDate",
          LCE.resend_date AS "ExecutiveReSendDate",
          LC.repayment_date AS "LoanClientRepaymentDate",
          LC.loan_client_id AS "LoanClientId",
          L.credit_date AS CreditDate
        FROM
          final F
          LEFT JOIN collect.loan_client LC USING(loan_client_id)
          LEFT JOIN comment_result CR USING(loan_client_id)
          LEFT JOIN loan_client_payment_current_month LCP_CM USING(loan_client_id)
          LEFT JOIN loan_client_payment_previous_month LCP_PM USING(loan_client_id)
          LEFT JOIN collect.client_person CP USING(client_id)
          LEFT JOIN collect.client USING(client_id)
          LEFT JOIN client_registration_address CRA USING(client_id)
          LEFT JOIN client_actual_address CAA USING(client_id)
          LEFT JOIN loan_client_payment LCP USING(loan_client_id)
          LEFT JOIN loan_client_repayment_payment LCRP USING(loan_client_id)
          LEFT JOIN collect.loan L USING(loan_id)
          LEFT JOIN loan_payment LP USING(loan_id)
          LEFT JOIN collect.cession C USING(cession_id)
          LEFT JOIN collect.claimant CL USING(claimant_id)
          LEFT JOIN collect.inner_org IO USING(inner_org_id)
          LEFT JOIN collect.user_info UI USING(user_id)
          LEFT JOIN collect.status S USING(status_id)
          LEFT JOIN collect.status2 S2 ON status2_id = S2.status_id
          LEFT JOIN collect.status3 S3 ON status3_id = S3.status_id
          LEFT JOIN collect.role R USING(role_id)
          LEFT JOIN collect.loan_client_succession LCS USING(loan_client_id)
          LEFT JOIN collect.court LCS_C USING(court_id)
          LEFT JOIN collect.court_document LCS_CD ON LCS.court_document_id = LCS_CD.court_document_id
          LEFT JOIN collect.loan_client_collection LCC ON LCC.loan_client_id = LC.loan_client_id AND LCC.is_main
          LEFT JOIN collect.court CC ON LCC.court_id = CC.court_id
          LEFT JOIN collect.court_document LCC_CD ON LCC.court_document_id = LCC_CD.court_document_id
          LEFT JOIN collect.application_type LCC_AT ON LCC.application_type_id = LCC_AT.application_type_id
          LEFT JOIN collect.loan_client_executive LCE USING(loan_client_collection_id)
          LEFT JOIN collect.osp O USING(osp_id)
        ORDER BY F."RowNumber";
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanClientStatusUpdateSqlQuery">
      <Text>
        SELECT collect.loan_client_update(
          LC.loan_client_id,
          LC.client_id,
          LC.surety_number,
          LC.role_id,
          LC.is_main,
          LC.user_id,
          {StatusId}::bigint,
          LC.court_sum,
          LC.court_date,
          LC.debt_base,
          LC.debt_percent,
          LC.debt_penalty,
          LC.debt_tax,
          LC.repayment_date,
          LC.repayment_sum,
          LC.repayment_number,
          LC.surety_duty,
          LC.surety_sum,
          LC.unique_id,
          COALESCE({CloseDate}::date, LC.close_date),
          COALESCE({SaleDate}::date, LC.sale_date),
          {UserId}::smallint)
        FROM
          collect.loan_client LC
        WHERE
          LC.loan_client_id = ANY({LoanClientId}::bigint[]) AND
          {StatusId} IS NOT NULL;
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanClientStatus2UpdateSqlQuery">
      <Text>
        SELECT collect.loan_client_update(
          LC.loan_client_id,
          LC.client_id,
          LC.surety_number,
          LC.role_id,
          LC.is_main,
          LC.user_id,
          LC.status_id,
          {StatusId}::bigint,
          LC.status3_id,
          LC.court_sum,
          LC.court_date,
          LC.debt_base,
          LC.debt_percent,
          LC.debt_penalty,
          LC.debt_tax,
          LC.repayment_date,
          LC.repayment_sum,
          LC.repayment_number,
          LC.surety_duty,
          LC.surety_sum,
          LC.unique_id,
          COALESCE({CloseDate}::date, LC.close_date),
          COALESCE({SaleDate}::date, LC.sale_date),
          {UserId}::smallint)
        FROM
          collect.loan_client LC
        WHERE
          LC.loan_client_id = ANY({LoanClientId}::bigint[]) AND
          {StatusId} IS NOT NULL;
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanClientStatus3UpdateSqlQuery">
      <Text>
        SELECT collect.loan_client_update(
          LC.loan_client_id,
          LC.client_id,
          LC.surety_number,
          LC.role_id,
          LC.is_main,
          LC.user_id,
          LC.status_id,
          LC.status2_id,
          {StatusId}::bigint,
          LC.court_sum,
          LC.court_date,
          LC.debt_base,
          LC.debt_percent,
          LC.debt_penalty,
          LC.debt_tax,
          LC.repayment_date,
          LC.repayment_sum,
          LC.repayment_number,
          LC.surety_duty,
          LC.surety_sum,
          LC.unique_id,
          COALESCE({CloseDate}::date, LC.close_date),
          COALESCE({SaleDate}::date, LC.sale_date),
          {UserId}::smallint)
        FROM
          collect.loan_client LC
        WHERE
          LC.loan_client_id = ANY({LoanClientId}::bigint[]) AND
          {StatusId} IS NOT NULL;
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanClientUserUpdateSqlQuery">
      <Text>
        SELECT collect.loan_client_update(
          LC.loan_client_id,
          LC.client_id,
          LC.surety_number,
          LC.role_id,
          LC.is_main,
          {SelectedUserId}::smallint,
          LC.status_id,
          LC.status2_id,
          LC.status3_id,
          LC.court_sum,
          LC.court_date,
          LC.debt_base,
          LC.debt_percent,
          LC.debt_penalty,
          LC.debt_tax,
          LC.repayment_date,
          LC.repayment_sum,
          LC.repayment_number,
          LC.surety_duty,
          LC.surety_sum,
          LC.unique_id,
          LC.close_date,
          LC.sale_date,
          {UserId}::smallint)
        FROM
          collect.loan_client LC
        WHERE
          LC.loan_client_id = ANY({LoanClientId}::bigint[]) AND
          {SelectedUserId} IS NOT NULL;
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanArchiveSqlQuery">
      <Text>
        SELECT collect.insert_history(
          'update',
          L.loan_id,
          null,
          'loan',
          'Сведения о займе',
          L.loan_id,
          ARRAY['archive'],
          ARRAY['В архиве'],
          ARRAY[COALESCE(L.archive, false)::character varying],
          ARRAY[COALESCE({Archive}::boolean, false)::character varying],
          ARRAY[CASE WHEN L.archive THEN 'Да' ELSE 'Нет' END],
          ARRAY[CASE WHEN {Archive} THEN 'Да' ELSE 'Нет' END],
          {UserId}::smallint,
          false)
        FROM
          collect.loan L
        WHERE
          L.loan_id = ANY({LoanId}::bigint[]) AND
          collect.not_equals(COALESCE(L.archive, false)::character varying, COALESCE({Archive}::boolean, false)::character varying);

        UPDATE
          collect.loan
        SET
          archive = COALESCE({Archive}, false)
        WHERE
          loan_id = ANY({LoanId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanDeleteSqlQuery">
      <Text>
        SELECT collect.loan_try_delete({LoanId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanSimpleSelectSqlQuery">
      <Text>
        SELECT
          L.loan_id AS "LoanId",
          L.credit_number AS "CreditNumber",
          L.archive AS "Archive"
        FROM
          collect.loan L
        WHERE
          NOT L.deleted;
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanClientSimpleSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), loan_users AS (
          SELECT
            LC.loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client LC
          WHERE
            LC.user_id IS NOT NULL
          GROUP BY LC.loan_id
        ), allowed_loan AS (
          SELECT
            L.loan_id,
            true AS loan_is_allowed
          FROM
            collect.loan L
            LEFT JOIN loan_users LU USING(loan_id)
            LEFT JOIN current_user_info CUI ON true
          WHERE
            CUI.user_is_administrator OR
            (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
            {UserId} = ANY(LU.user_ids)
        )
        SELECT
          LC.loan_client_id AS "LoanClientId",
          LC.loan_id AS "LoanId",
          LC.client_id AS "ClientId",
          'Номер КД: ' || COALESCE(L.credit_number, '') AS "CreditNumber",
          L.archive AS "Archive",
          COALESCE(AL.loan_is_allowed, false) AS "CanEditLoan"
        FROM
          collect.loan_client LC
          JOIN collect.loan L USING(loan_id)
          LEFT JOIN allowed_loan AL USING(loan_id)
        WHERE
          NOT L.deleted;
      </Text>
    </SqlQuery>

    <!-- сведения о займе -->
    <SqlQuery Name="LoanByIdSelectSqlQuery">
      <Text>
        SELECT
          credit_number AS "CreditNumber",
          cession_id AS "CessionId",
          credit_date AS "CreditDate",
          credit_end_date AS "CreditEndDate",
          credit_sum AS "CreditSum",
          credit_rate AS "CreditRate",
          is_floating_credit_rate AS "IsFloatingCreditRate",
          credit_type_id AS "CreditTypeId",
          credit_line_type_id AS "CreditLineTypeId",
          credit_purpose_id AS "CreditPurposeId",
          credit_get_type_id AS "CreditGetTypeId",
          first_claimant_id AS "FirstClaimantId",
          debt_base AS "DebtBase",
          debt_percent AS "DebtPercent",
          debt_penalty AS "DebtPenalty",
          debt_tax AS "DebtTax",
          fssp_debt AS "FsspDebt",
          account_number AS "AccountNumber",
          full_price AS "FullPrice",
          full_price_percent AS "FullPricePercent",
          overdue_date AS "OverdueDate"
        FROM
          collect.loan
        WHERE
          loan_id = {LoanId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanByClientIdSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), loan_users AS (
          SELECT
            LC.loan_id,
            array_agg(DISTINCT LC.user_id) AS user_ids
          FROM
            collect.loan_client LC
          WHERE
            LC.user_id IS NOT NULL AND
            LC.client_id = ANY({ClientId}::bigint[]) AND
            LC.loan_id != {LoanId}
          GROUP BY loan_id
        )
        SELECT
          L.loan_id AS "LoanId",
          LC.client_id AS "ClientId",
          LC.loan_client_id AS "LoanClientId",
          L.credit_number AS "CreditNumber",
          R.title AS "RoleTitle",
          L.credit_sum AS "CreditSum"
        FROM
          collect.loan_client LC
          JOIN collect.loan L USING(loan_id)
          LEFT JOIN collect.role R USING(role_id)
          LEFT JOIN loan_users LU USING(loan_id)
          LEFT JOIN current_user_info CUI ON true
        WHERE
          LC.client_id = ANY({ClientId}::bigint[]) AND
          LC.loan_id != {LoanId} AND
          (CUI.user_is_administrator OR
          (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
          {UserId} = ANY(LU.user_ids));
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientForLoanSelectSqlQuery">
      <Text>
        WITH property_movable AS (
          SELECT
            DISTINCT client_id,
            true AS property_exists
          FROM
            collect.client_property
            JOIN collect.client_property_movable USING(client_property_id)
          WHERE
            client_id = ANY({ClientId}::bigint[])
        ), property_real AS (
          SELECT
            DISTINCT client_id,
            true AS property_exists
          FROM
            collect.client_property
            JOIN collect.client_property_real USING(client_property_id)
          WHERE
            client_id = ANY({ClientId}::bigint[])
        ), property_company AS (
          SELECT
            DISTINCT client_id,
            true AS property_exists
          FROM
            collect.client_property
            JOIN collect.client_property_company USING(client_property_id)
          WHERE
            client_id = ANY({ClientId}::bigint[])
        ), arrest AS (
          SELECT
            string_agg(A.arrest, E'\r\n') AS arrest_info,
            client_id
          FROM (
            SELECT
              'Имущество: ' || COALESCE(CP.title,'') || ', дата ареста: ' || to_char(COALESCE(CPM.arrest_result_date, CPR.arrest_result_date), 'dd.MM.yyyy') || '.' AS arrest,
              CP.client_id
            FROM
              collect.client_property CP
              LEFT JOIN collect.client_property_movable CPM USING(client_property_id)
              LEFT JOIN collect.client_property_real CPR USING(client_property_id)
            WHERE
              client_id = ANY({ClientId}::bigint[]) AND
              ((CPM.arrest_result_date IS NOT NULL AND CPM.unarrest_date IS NULL) OR
              (CPR.arrest_result_date IS NOT NULL AND CPR.unarrest_date IS NULL))

            UNION ALL

            SELECT
              'Банковский счет №: ' || COALESCE(account,'') || ', дата ареста: ' || to_char(arrest_date, 'dd.MM.yyyy') || '.' AS arrest,
              client_id
            FROM
              collect.client_account
            WHERE
              client_id = ANY({ClientId}::bigint[]) AND
              arrest_date IS NOT NULL
          ) A
          GROUP BY client_id
        ), client_main_phone AS (
          SELECT
            DISTINCT ON(client_id)
            client_id,
            phone_number
          FROM
            collect.client_phone
          WHERE
            client_id = ANY({ClientId}::bigint[]) AND
            is_main
          ORDER BY client_id, client_phone_id
        ), client_person_info AS (
          SELECT
            CP.client_id,
            collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS client_title,
            CASE
              WHEN COALESCE(CP.passport_series, '') = '' THEN '—'::character varying
              ELSE CP.passport_series
            END AS passport_series,
            CASE
              WHEN COALESCE(CP.passport_number, '') = '' THEN '—'::character varying
              ELSE CP.passport_number
            END AS passport_number,
            CASE
              WHEN COALESCE(CP.passport_given_by, '') = '' THEN '—'::character varying
              ELSE CP.passport_given_by
            END AS passport_given_by,
            COALESCE(to_char(CP.passport_given_date, 'dd.MM.yyyy'), '—') AS passport_given_date,
            CP.birth_date,
            CP.birth_place,
            CASE
              WHEN COALESCE(CP.work_company_title,'') = ''
              THEN ''
              ELSE
                CASE
                  WHEN COALESCE(CP.work_post, '') = ''
                  THEN CP.work_company_title
                  ELSE CP.work_company_title || ', должность: ' || CP.work_post
                END
            END AS work_place,
            CMP.phone_number,
            CP.email
          FROM
            collect.client_person CP
            LEFT JOIN client_main_phone CMP USING(client_id)
          WHERE
            client_id = ANY({ClientId}::bigint[])
        )
        SELECT
          C.client_id AS "ClientId",
          CPI.client_title AS "Title",
          CPI.birth_date AS "BirthDate",
          'Серия: ' || CPI.passport_series || ', номер: ' || CPI.passport_number || ', выдан: ' || CPI.passport_given_by || ', дата выдачи: ' || CPI.passport_given_date AS "Passport",
          CPI.birth_place AS "BirthPlace",
          CPI.work_place "WorkPlace",
          CPI.phone_number AS "PhoneNumber",
          CPI.email AS "Email",
          COALESCE(property_movable.property_exists, false) AS "MovablePropertyExists",
          COALESCE(property_real.property_exists, false) AS "RealPropertyExists",
          COALESCE(property_company.property_exists, false) AS "CompanyPropertyExists",
          arrest.arrest_info AS "ArrestInfo"
        FROM
          collect.client C
          LEFT JOIN client_person_info CPI USING(client_id)
          LEFT JOIN property_movable USING(client_id)
          LEFT JOIN property_real USING(client_id)
          LEFT JOIN property_company USING(client_id)
          LEFT JOIN arrest USING(client_id)
        WHERE
          client_id = ANY({ClientId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientAddressForLoanSelectSqlQuery">
      <Text>
        WITH all_address AS (
          SELECT
            GAS.address_id,
            GAS.address_string
          FROM
            collect.client C
            LEFT JOIN collect.get_address_string(p_client_id => C.client_id) GAS USING(client_id)
          WHERE
            C.client_id = ANY({ClientId}::bigint[])
        )
        SELECT
          CA.client_id AS "ClientId",
          CA.address_type_id AS "AddressTypeId",
          CASE WHEN ATP.title = 'Другой' AND COALESCE(CA.address_type,'') != '' THEN CA.address_type ELSE ATP.title END AS "AddressTypeTitle",
          CASE WHEN COALESCE(A.address_string,'') = '' THEN ADR.address_string ELSE A.address_string END AS "Address"
        FROM
          collect.client_address CA
          JOIN collect.address A USING(address_id)
          LEFT JOIN collect.address_type ATP USING(address_type_id)
          LEFT JOIN all_address ADR USING(address_id)
        WHERE
          CA.client_id = ANY({ClientId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientPhoneForLoanSelectSqlQuery">
      <Text>
        SELECT
          P.client_id AS "ClientId",
          P.phone_number AS "PhoneNumber",
          CASE WHEN PT.title = 'Другой' AND COALESCE(P.phone_type,'') != '' THEN P.phone_type ELSE PT.title END AS "PhoneTypeTitle",
          CASE WHEN CPT.title = 'Другой' AND COALESCE(P.contact_person_type,'') != '' THEN P.contact_person_type ELSE CPT.title END AS "ContactPersonTypeTitle",
          P.contact_person AS "ContactPerson",
          CASE WHEN client_id = ANY({ClientIdWithMainPhone}::bigint[]) THEN false ELSE P.is_main END AS "IsMain"
        FROM
          collect.client_phone P
          LEFT JOIN collect.phone_type PT USING(phone_type_id)
          LEFT JOIN collect.contact_person_type CPT USING(contact_person_type_id)
        WHERE
          P.client_id = ANY({ClientId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="CessionHistoryByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          loan_cession_history_id AS "LoanCessionHistoryId",
          date AS "Date",
          sum AS "Sum",
          claimant_title AS "ClaimantTitle",
          inner_org_title AS "InnerOrgTitle",
          cession_title AS "CessionTitle"
        FROM
          collect.loan_cession_history
        WHERE
          loan_id = {LoanId}
        ORDER BY date DESC, loan_cession_history_id DESC;
      </Text>
    </SqlQuery>

    <!-- ошибки БКИ-->
    <SqlQuery Name="BkiErrorCountByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          count(DISTINCT BE.bki_error_id) AS "BkiErrorCount"
        FROM
          collect.loan_client LC
          LEFT JOIN collect.bki_error BE ON BE.loan_id = LC.loan_id OR BE.client_id = LC.client_id
        WHERE
          LC.loan_id = {LoanId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="BkiErrorByLoanIdSelectSqlQuery">
      <Text>
        WITH client AS (
          SELECT
            DISTINCT ON (client_id)
            client_id,
            collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS client_title
          FROM
            collect.loan_client
            LEFT JOIN collect.client_person CP USING(client_id)
          WHERE
            loan_id = {LoanId}
        )
        SELECT
          BT.title AS "BkiTitle",
          CASE
            WHEN COALESCE(C.client_title, '') = '' THEN BE.error
            ELSE 'Должник: ' || C.client_title || E'.\r\n' || COALESCE(BE.error, '')
          END AS "BkiError"
        FROM
          collect.bki_error BE
          LEFT JOIN client C USING(client_id)
          LEFT JOIN collect.bki_type BT USING(bki_type_id)
        WHERE
          BE.loan_id = {LoanId} OR
          BE.client_id IN (SELECT client_id FROM client)
        ORDER BY BE.bki_type_id, BE.bki_error_id;
      </Text>
    </SqlQuery>

    <!-- уведомление должников -->
    <SqlQuery Name="NotificationByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LCN.loan_client_notification_id AS "LoanClientNotificationId",
          LCN.loan_client_id AS "LoanClientId",
          LCN.number AS "Number",
          LCN.date AS "Date",
          LCN.send_date AS "SendDate",
          LCN.post_number AS "PostNumber",
          LCN.delivery_info AS "DeliveryInfo",
          LCN.is_actual AS "IsActual"
        FROM
          collect.loan_client_notification LCN
          JOIN collect.loan_client LC USING(loan_client_id)
        WHERE
          LC.loan_id = {LoanId}
        ORDER BY NOT LCN.is_actual, LCN.date DESC, LCN.loan_client_notification_id DESC;
      </Text>
    </SqlQuery>

    <!-- учет взаимодействия -->
    <SqlQuery Name="InteractionByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LCI.loan_client_interaction_id AS "LoanClientInteractionId",
          LCI.loan_client_id AS "LoanClientId",
          LCI.interaction_type_id AS "InteractionTypeId",
          LCI.contact_person_type_id AS "ContactPersonTypeId",
          LCI.date AS "Date",
          LCI.notification_date AS "TsNotificationDate",
          LCI.user_id AS "UserId",
          LCI.user_phone_id AS "UserPhoneId",
          LCI.description AS "Description"
        FROM
          collect.loan_client_interaction LCI
          JOIN collect.loan_client LC USING(loan_client_id)
        WHERE
          LC.loan_id = {LoanId}
          OR LC.client_id = (SELECT MIN(client_id) FROM collect.loan_client WHERE loan_id = {LoanId})
        ORDER BY LCI.date DESC, LCI.loan_client_interaction_id DESC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="InteractionLimitByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LCIL.loan_client_interaction_limit_id AS "LoanClientInteractionLimitId",
          LCIL.loan_client_id AS "LoanClientId",
          LCIL.concent_date AS "ConcentDate",
          LCIL.agent_concent_date AS "AgentConcentDate",
          LCIL.agent_title AS "AgentTitle",
          LCIL.agent_birth_date AS "AgentBirthDate",
          LCIL.agent_phone AS "AgentPhone",
          LCIL.agent_address AS "AgentAddress",
          LCIL.agent_email AS "AgentEmail",
          LCIL.agent_lawyer AS "AgentLawyer",
          LCIL.reject_date AS "RejectDate",
          LCIL.agent_reject_date AS "AgentRejectDate",
          LCIL.reject_cancel_date AS "RejectCancelDate",
          LCIL.other_agent_date AS "OtherAgentDate",
          LCIL.request AS "Request",
          LCIL.request_response AS "RequestResponse"
        FROM
          collect.loan_client_interaction_limit LCIL
          JOIN collect.loan_client LC USING(loan_client_id)
        WHERE
          LC.loan_id = {LoanId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="InteractionTypeSelectSqlQuery">
      <Text>
        SELECT
          interaction_type_id AS "InteractionTypeId",
          title AS "Title"
        FROM
          collect.interaction_type IT
        ORDER BY title;
      </Text>
    </SqlQuery>

    <!-- аудиозаписи -->
    <SqlQuery Name="AudioFileByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LAF.loan_audio_file_id AS "LoanAudioFileId",
          LAF.record_id AS "RecordId",
          LAF.create_date AS "CreateDate",
          LAF.author_id as "AuthorId",
          LAF.call_time AS "CallTime",
          LAF.call_direction AS "CallDirection",
          LAF.call_duration AS "CallDuration",
          LAF.client_phone_number AS "ClientPhoneNumber",
          LAF.user_phone_number AS "UserPhoneNumber",
          F.guid AS "Guid",
          substr(F.path, length(F.path) - strpos(reverse(F.path),'\') + 2) AS "FileName",
          LAF.description AS "Description"
        FROM
          collect.loan_audio_file LAF
          LEFT JOIN public.file F USING(file_id)
        WHERE
          LAF.loan_id = {LoanId}
        ORDER BY LAF.call_time DESC, LAF.loan_audio_file_id DESC;
      </Text>
    </SqlQuery>

    <!-- файлы -->
    <SqlQuery Name="FileByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LF.loan_file_id AS "LoanFileId",
          LF.loan_id AS "LoanId",
          LF.loan_client_id AS "LoanClientId",
          LF.title AS "Title",
          LF.description AS "Description",
          LF.author_id AS "AuthorId",
          LF.create_date AS "CreateDate"
        FROM
          collect.loan_file LF
          LEFT JOIN collect.loan_client LC USING(loan_client_id)
        WHERE
          LF.loan_id = {LoanId} OR
          LC.loan_id = {LoanId}
        ORDER BY LF.create_date DESC, LF.loan_file_id DESC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="FileFileByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LFF.loan_file_file_id AS "LoanFileFileId",
          LFF.loan_file_id AS "LoanFileId",
          F.guid AS "Guid",
          substr(F.path, length(F.path) - strpos(reverse(F.path),'\') + 2) AS "FileName"
        FROM
          collect.loan_file_file LFF
          JOIN collect.loan_file LF USING(loan_file_id)
          LEFT JOIN collect.loan_client LC USING(loan_client_id)
          LEFT JOIN public.file F USING(file_id)
        WHERE
          LF.loan_id = {LoanId} OR
          LC.loan_id = {LoanId}
        ORDER BY LFF.loan_file_file_id ASC;
      </Text>
    </SqlQuery>

    <!-- оплаты -->
    <SqlQuery Name="PaymentByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LCP.loan_client_payment_id AS "LoanClientPaymentId",
          LCP.loan_client_id AS "LoanClientId",
          LCP.payer_client_id AS "PayerClientId",
          LCP.from_file AS "FromFile",
          LCP.payer AS "Payer",
          LCP.date AS "Date",
          LCP.sum AS "Sum",
          LCP.comment AS "Comment",
          CASE
            WHEN LCP.payer_client_id IS NULL THEN LCP.payer
            ELSE collect.get_client_title(CP_P.first_name, CP_P.second_name, CP_P.third_name)
          END AS "PayerTitle",
          LCP.number AS "Number",
          LCP.author_id AS "AuthorId",
          LCP.create_date AS "CreateDate"
        FROM
          collect.loan_client_payment LCP
          LEFT JOIN collect.client_person CP_P ON CP_P.client_id = payer_client_id
          JOIN collect.loan_client LC USING(loan_client_id)
        WHERE
          LC.loan_id = {LoanId}
        ORDER BY LCP.date DESC, LCP.loan_client_payment_id DESC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="PaymentByClientIdSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), loan_users AS (
          SELECT
            loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client
          WHERE
            user_id IS NOT NULL AND
            client_id = {ClientId}
          GROUP BY loan_id
        )
        SELECT
          LCP.loan_client_payment_id AS "LoanClientPaymentId",
          LCP.loan_client_id AS "LoanClientId",
          LCP.payer_client_id AS "PayerClientId",
          LCP.from_file AS "FromFile",
          LCP.payer AS "Payer",
          LCP.date AS "Date",
          LCP.sum AS "Sum",
          LCP.comment AS "Comment",
          CASE
            WHEN LCP.payer_client_id IS NULL THEN LCP.payer
            ELSE collect.get_client_title(CP_P.first_name, CP_P.second_name, CP_P.third_name)
          END AS "PayerTitle",
          LCP.number AS "Number",
          LCP.author_id AS "AuthorId",
          LCP.create_date AS "CreateDate",
          UI.user_full_name AS "AuthorTitle"
        FROM
          collect.loan_client_payment LCP
          LEFT JOIN collect.client_person CP_P ON CP_P.client_id = payer_client_id
          JOIN collect.loan_client LC USING(loan_client_id)
          JOIN collect.loan L USING(loan_id)
          LEFT JOIN loan_users LU USING(loan_id)
          LEFT JOIN collect.user_info UI ON LCP.author_id = UI.user_id
          LEFT JOIN current_user_info CUI ON true
        WHERE
          {ClientId} IS NOT NULL AND
          LC.client_id = {ClientId} AND
          NOT L.deleted AND
          NOT L.archive AND
          (CUI.user_is_administrator OR
          (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
          {UserId} = ANY(LU.user_ids))
        ORDER BY LCP.date DESC, LCP.loan_client_payment_id DESC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="PaymentByPaymentIdSelectSqlQuery">
      <Text>
        SELECT
          LCP.loan_client_id AS "LoanClientId",
          LC.client_id AS "ClientId",
          LCP.payer_client_id AS "PayerClientId",
          LCP.payer AS "Payer",
          LCP.date AS "Date",
          LCP.sum AS "Sum",
          LCP.comment AS "Comment",
          LCP.number AS "Number"
        FROM
          collect.loan_client_payment LCP
          JOIN collect.loan_client LC USING(loan_client_id)
        WHERE
          LCP.loan_client_payment_id = {LoanClientPaymentId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="PaymentInsertSqlQuery">
      <Text>
        SELECT collect.loan_client_payment_insert(
          {LoanClientId}::bigint,
          {PayerClientId}::bigint,
          {Payer}::character varying,
          {Date}::date,
          {Sum}::numeric,
          {Number}::character varying,
          {Comment}::character varying,
          {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PaymentUpdateSqlQuery">
      <Text>
        SELECT collect.loan_client_payment_update(
          {LoanClientPaymentId}::bigint,
          {LoanClientId}::bigint,
          {PayerClientId}::bigint,
          {Payer}::character varying,
          {Date}::date,
          {Sum}::numeric,
          {Number}::character varying,
          {Comment}::character varying,
          {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PaymentDeleteSqlQuery">
      <Text>
        SELECT collect.loan_client_payment_delete(
          T.loan_client_payment_id,
          {UserId}::smallint)
        FROM (
          SELECT
            unnest({LoanClientPaymentId}::bigint[]) AS loan_client_payment_id
        ) T;
      </Text>
    </SqlQuery>

    <!-- поиск счетов и имущества -->
    <SqlQuery Name="PropertySearchByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LCPS.loan_client_property_search_id AS "LoanClientPropertySearchId",
          LCPS.loan_client_id AS "LoanClientId",
          LCPS.destination AS "Destination",
          LCPS.send_date AS "SendDate",
          LCPS.response AS "Response"
        FROM
          collect.loan_client_property_search LCPS
          JOIN collect.loan_client LC USING(loan_client_id)
        WHERE
          LC.loan_id = {LoanId}
        ORDER BY LCPS.send_date DESC, LCPS.loan_client_property_search_id DESC;
      </Text>
    </SqlQuery>

    <!-- мировое соглашение -->
    <SqlQuery Name="RepaymentByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LCR.loan_client_repayment_id AS "LoanClientRepaymentId",
          LCR.loan_client_id AS "LoanClientId",
          LCR.date AS "RepaymentDate",
          LCR.sum AS "RepaymentSum"
        FROM
          collect.loan_client_repayment LCR
          JOIN collect.loan_client LC USING(loan_client_id)
        WHERE
          LC.loan_id = {LoanId}
        ORDER BY LCR.loan_client_id, LCR.date;
      </Text>
    </SqlQuery>

    <!-- История -->
    <SqlQuery Name="HistoryByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          H.out_history_id AS "HistoryId",
          H.out_loan_id AS "LoanId",
          H.out_user_id AS "UserId",
          UI.user_full_name AS "AuthorTitle",
          H.out_history_date AS "HistoryDate",
          H.out_text AS "HistoryText"
        FROM
          collect.get_history(NULL::bigint, {LoanId}::bigint, {FilterTable}::character varying[]) H
          LEFT JOIN collect.user_info UI ON UI.user_id = H.out_user_id
        WHERE
          {LoanId} IS NOT NULL
        ORDER BY H.out_history_date DESC, H.out_history_id DESC;
      </Text>
    </SqlQuery>

    <!-- список наименований суд. документов -->
    <SqlQuery Name="CourtDocumentSelectSqlQuery">
      <Text>
        SELECT
          court_document_id AS "CourtDocumentId",
          title AS "Title",
          court_document_type AS "CourtDocumentType"
        FROM
          collect.court_document
        ORDER BY title;
      </Text>
    </SqlQuery>

    <!-- список решений суда -->
    <SqlQuery Name="CourtResultSelectSqlQuery">
      <Text>
        SELECT
          court_result_id AS "CourtResultId",
          title AS "Title"
        FROM
          collect.court_result
        ORDER BY court_result_id;
      </Text>
    </SqlQuery>

    <!-- процессуальное правопреемство -->
    <SqlQuery Name="SuccessionByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LCS.loan_client_succession_id AS "LoanClientSuccessionId",
          LCS.loan_client_id AS "LoanClientId",
          LCS.court_id AS "CourtId",
          LCS.court_document_id AS "CourtDocumentId",
          LCS.document_number AS "DocumentNumber",
          LCS.document_date AS "DocumentDate",
          LCS.document_is_duplicate AS "DocumentIsDuplicate",
          LCS.duplicate_get_date AS "DuplicateGetDate",
          LCS.duplicate_court_date AS "DuplicateCourtDate",
          LCS.document_info AS "DocumentInfo",
          LCS.case_number AS "CaseNumber",
          LCS.appeal_send_date AS "AppealSendDate",
          LCS.appeal_date AS "AppealDate",
          LCS.appeal_result AS "AppealResult",
          LCS.cassation_send_date AS "CassationSendDate",
          LCS.cassation_date AS "CassationDate",
          LCS.cassation_result AS "CassationResult",
          LCS.document_sum AS "DocumentSum",
          LCS.tax_sum AS "TaxSum",
          LCS.send_date AS "SendDate",
          LCS.court_date AS "CourtDate",
          LCS.result AS "Result",
          LCS.comment AS "Comment",
          LCS.cancel_date AS "CancelDate"
        FROM
          collect.loan_client_succession LCS
          JOIN collect.loan_client LC USING(loan_client_id)
        WHERE
          LC.loan_id = {LoanId}
        ORDER BY LCS.loan_client_id, LCS.loan_client_succession_id;
      </Text>
    </SqlQuery>

    <!-- взыскание в судебном порядке -->
    <SqlQuery Name="CollectionByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LCC.loan_client_collection_id AS "LoanClientCollectionId",
          LCC.loan_client_id AS "LoanClientId",
          LCC.court_document_id AS "CourtDocumentId",
          LCC.court_document_number AS "CourtDocumentNumber",
          LCC.court_document_date AS "CourtDocumentDate",
          LCC.court_id AS "CourtId",
          LCC.send_date AS "SendDate",
          LCC.case_number AS "CaseNumber",
          LCC.judge AS "Judge",
          LCC.contact_date AS "ContactDate",
          LCC.court_date AS "CourtDate",
          LCC.result_date AS "ResultDate",
          LCC.court_result_id AS "CourtResultId",
          LCC.sum AS "Sum",
          LCC.is_main AS "IsMain",
          LCC.is_recieved AS "IsRecieved",
          LCC.legal_date AS "LegalDate",
          LCC.document_get_date AS "DocumentGetDate",
          LCC.cancel_date AS "CancelDate",
          LCC.appeal_send_date AS "AppealSendDate",
          LCC.appeal_date AS "AppealDate",
          LCC.appeal_result AS "AppealResult",
          LCC.cassation_send_date AS "CassationSendDate",
          LCC.cassation_date AS "CassationDate",
          LCC.cassation_result AS "CassationResult",
          LCC.application_type_id AS "ApplicationTypeId",
          LCC.application_sum AS "ApplicationSum",
          LCC.application_tax AS "ApplicationTax",
          ATPE.date AS "ApplicationTaxPaymentExportDate",
          ATPE.number AS "ApplicationTaxPaymentExportNumber",
          LCC.previous_loan_client_collection_id AS "PreviousLoanClientCollectionId"
        FROM
          collect.loan_client_collection LCC
          JOIN collect.loan_client LC USING(loan_client_id)
          LEFT JOIN collect.application_tax_payment_export ATPE USING(application_tax_payment_export_id)
        WHERE
          LC.loan_id = {LoanId}
        ORDER BY LCC.loan_client_id, LCC.loan_client_collection_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ApplicationTaxCalcSqlQuery">
      <Text>
        SELECT collect.calc_application_tax({LoanClientId},{ApplicationTypeId});
      </Text>
    </SqlQuery>

    <!-- исполнительное производство -->
    <SqlQuery Name="ExecutiveByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LCE.loan_client_executive_id AS "LoanClientExecutiveId",
          LCE.loan_client_collection_id AS "LoanClientCollectionId",
          LCE.document_info AS "DocumentInfo",
          LCE.osp_id AS "OspId",
          LCE.bailiff_title AS "BailiffTitle",
          LCE.bailiff_phone AS "BailiffPhone",
          LCE.send_date AS "SendDate",
          LCE.start_date AS "StartDate",
          LCE.number AS "Number",
          LCE.replacement_send_date AS "ReplacementSendDate",
          LCE.replacement_date AS "ReplacementDate",
          LCE.request AS "Request",
          LCE.request_response AS "RequestResponse",
          LCE.other_info AS "OtherInfo",
          LCE.end_date AS "EndDate",
          LCE.end_reason AS "EndReason",
          LCE.resend_date AS "ResendDate",
          LCE.restrict_date AS "RestrictDate",
          LCE.restrict_end_date AS "RestrictEndDate",
          LCE.appeal_send_date AS "AppealSendDate",
          LCE.appeal_date AS "AppealDate",
          LCE.appeal_result AS "AppealResult"
        FROM
          collect.loan_client_executive LCE
          JOIN collect.loan_client_collection LCC USING(loan_client_collection_id)
          JOIN collect.loan_client LC USING(loan_client_id)
        WHERE
          LC.loan_id = {LoanId}
        ORDER BY LCC.loan_client_id, LCE.loan_client_executive_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="RoleSelectSqlQuery">
      <Text>
        SELECT
          role_id AS "RoleId",
          title AS "Title"
        FROM
          collect.role
        ORDER BY role_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanClientByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LC.loan_client_id AS "LoanClientId",
          LC.client_id AS "ClientId",
          LC.surety_number AS "SuretyNumber",
          LC.role_id AS "RoleId",
          LC.is_main AS "IsMain",
          LC.user_id AS "UserId",
          LC.status_id AS "StatusId",
          LC.status2_id AS "Status2Id",
          LC.status3_id AS "Status3Id",
          LC.court_sum AS "CourtSum",
          LC.court_date AS "CourtDate",
          LC.debt_base AS "DebtBase",
          LC.debt_percent AS "DebtPercent",
          LC.debt_penalty AS "DebtPenalty",
          LC.debt_tax AS "DebtTax",
          LC.repayment_date AS "RepaymentDate",
          LC.repayment_sum AS "RepaymentSum",
          LC.repayment_number AS "RepaymentNumber",
          LC.surety_duty AS "SuretyDuty",
          LC.surety_sum AS "SuretySum",
          LC.unique_id AS "UniqueId",
          LC.close_date AS "CloseDate",
          LC.sale_date AS "SaleDate"
        FROM
          collect.loan_client LC
        WHERE
          LC.loan_id = {LoanId}
        ORDER BY NOT LC.is_main, LC.role_id;
      </Text>
    </SqlQuery>

    <!-- комментарии -->
    <SqlQuery Name="CommentByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LC.loan_comment_id AS "LoanCommentId",
          LC.loan_id AS "LoanId",
          LC.loan_client_id AS "LoanClientId",
          LC.task_type_id AS "TaskTypeId",
          COALESCE(TT.title,'Комментарий') AS "CommentTypeTitle",
          LC.edit_user_id AS "EditUserId",
          LC.create_date AS "CreateDate",
          LC.notification_date AS "NotificationDate",
          LC.execution_date AS "ExecutionDate",
          LC.comment AS "Comment"
        FROM
          collect.loan_comment LC
          LEFT JOIN collect.loan_client LCL USING(loan_client_id)
          LEFT JOIN collect.task_type TT USING(task_type_id)
        WHERE
          LC.loan_id = {LoanId} OR
          LCL.loan_id = {LoanId} OR
          LCL.client_id = (SELECT MIN(client_id) FROM collect.loan_client WHERE loan_id={LoanId})
        ORDER BY LC.create_date DESC, LC.loan_comment_id DESC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="CommentFileByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LCF.loan_comment_file_id AS "LoanCommentFileId",
          LCF.loan_comment_id AS "LoanCommentId",
          F.guid AS "Guid",
          substr(F.path, length(F.path) - strpos(reverse(F.path),'\') + 2) AS "FileName"
        FROM
          collect.loan_comment LC
          LEFT JOIN collect.loan_client LCL USING(loan_client_id)
          JOIN collect.loan_comment_file LCF USING(loan_comment_id)
          LEFT JOIN public.file F USING(file_id)
        WHERE
          LC.loan_id = {LoanId} OR
          LCL.loan_id = {LoanId}
        ORDER BY LCF.loan_comment_file_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="CommentByIdSelectSqlQuery">
      <Text>
        SELECT
          LC.loan_client_id AS "LoanClientId",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "LoanClientTitle",
          LC.task_type_id AS "TaskTypeId",
          LC.notification_date AS "NotificationDate",
          LC.execution_date AS "ExecutionDate",
          LC.comment AS "Comment"
        FROM
          collect.loan_comment LC
          LEFT JOIN collect.loan_client LCL USING(loan_client_id)
          LEFT JOIN collect.client_person CP USING(client_id)
        WHERE
          LC.loan_comment_id = {LoanCommentId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="CommentFileByCommentIdSelectSqlQuery">
      <Text>
        SELECT
          F.guid AS "Guid",
          substr(F.path, length(F.path) - strpos(reverse(F.path),'\') + 2) AS "FileName"
        FROM
          collect.loan_comment_file LCF
          JOIN collect.loan_comment LC USING(loan_comment_id)
          LEFT JOIN public.file F USING(file_id)
        WHERE
          LCF.loan_comment_id = {LoanCommentId}
        ORDER BY LCF.loan_comment_file_id ASC;
      </Text>
    </SqlQuery>

    <!-- типы займов -->
    <SqlQuery Name="CreditTypeSelectSqlQuery">
      <Text>
        SELECT
          credit_type_id AS "CreditTypeId",
          title AS "Title",
          is_credit_line AS "IsCreditLine"
        FROM
          collect.credit_type
        ORDER BY credit_type_id;
      </Text>
    </SqlQuery>

    <!-- типы кредитных линий -->
    <SqlQuery Name="CreditLineTypeSelectSqlQuery">
      <Text>
        SELECT
          credit_line_type_id AS "CreditLineTypeId",
          title AS "Title"
        FROM
          collect.credit_line_type
        ORDER BY credit_line_type_id;
      </Text>
    </SqlQuery>

    <!-- цели займов -->
    <SqlQuery Name="CreditPurposeSelectSqlQuery">
      <Text>
        SELECT
          credit_purpose_id AS "CreditPurposeId",
          title AS "Title"
        FROM
          collect.credit_purpose
        ORDER BY credit_purpose_id;
      </Text>
    </SqlQuery>

    <!-- типы получения займов -->
    <SqlQuery Name="CreditGetTypeSelectSqlQuery">
      <Text>
        SELECT
          credit_get_type_id AS "CreditGetTypeId",
          title AS "Title"
        FROM
          collect.credit_get_type
        ORDER BY credit_get_type_id;
      </Text>
    </SqlQuery>

    <!-- сохранение -->
    <SqlQuery Name="LoanEditDateSelectSqlQuery">
      <Text>
        SELECT
          COALESCE((
            SELECT
              edit_date AS "EditDate"
            FROM
              collect.loan
            WHERE
              loan_id = {LoanId}
          ), 'infinity')::character varying AS "EditDate";
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanCheckBeforeSaveSelectSqlQuery">
      <Text>
        SELECT
          {FormEditDate}::timestamp != COALESCE((SELECT edit_date FROM collect.loan WHERE loan_id = {LoanId} AND {LoanId} IS NOT NULL), 'infinity'::timestamp) AS "LoanChanged",
          (SELECT user_full_name FROM collect.loan L LEFT JOIN collect.user_info UI ON L.edit_user_id = UI.user_id WHERE loan_id = {LoanId}) AS "UserTitle";
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanSaveSqlQuery">
      <Text>
        SELECT collect.ts_loan_save({Model}::json, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <!-- разрешения и текущий пользователь -->
    <SqlQuery Name="PermissionSelectSqlQuery">
      <Text>
        WITH settings AS (
          SELECT
            module_nbki_available,
            module_equifax_available,
            module_okb_available,
            module_autotask_available,
            module_fssp_available,
            module_email_enabled,
            module_email_available,
            module_pochtaru_available,
            module_pochtaru_enabled,
            module_debex_fssp_available,
            module_debex_fssp_enabled,
            module_debex_bankrupt_available,
            module_debex_bankrupt_enabled,
            module_debex_jurisdiction_available,
            module_debex_jurisdiction_enabled,
            module_application_tax_enabled,
            module_application_tax_available
          FROM
            collect.settings
          ORDER BY settings_id LIMIT 1
        )
        SELECT
          collect.is_administrator({UserId}::smallint) AS "UserIsAdministrator",
          collect.is_leading_specialist({UserId}::smallint) AS "UserIsLeadingSpecialist",
          --видимость пункта меню отчеты
          UI.report_payment OR UI.report_interaction OR UI.report_application_tax_payment AS "ReportPermission",
          --видимость отчетов
          UI.report_payment AS "ReportPaymentPermission",
          UI.report_interaction AS "ReportInteractionPermission",
          UI.report_debt as "ReportDebtPermission",
          UI.report_users as "ReportUsersPermission",
          --видимость пункта меню списки
          UI.list_claimant OR UI.list_inner_org OR UI.list_cession OR UI.list_client::text IN ('full', 'partial') OR
          UI.list_address OR
          UI.list_document OR
          UI.list_court OR list_osp OR
          UI.list_task_type OR
          UI.list_bankrupt_type AS "ListPermission",
          --видимость списков
          UI.list_claimant AS "ListClaimantPermission",
          UI.list_inner_org AS "ListInnerOrgPermission",
          UI.list_cession AS "ListCessionPermission",
          UI.list_client::text IN ('full', 'partial') AS "ListClientPermission",
          UI.list_address AS "ListAddressPermission",
          UI.list_document AS "ListDocumentPermission",
          UI.list_court AS "ListCourtPermission",
          UI.list_osp AS "ListOspPermission",
          UI.list_task_type AS "ListTaskTypePermission",
          UI.list_bankrupt_type AS "ListBankruptTypePermission",
          --видимость первого разделителя
          (UI.list_claimant OR UI.list_inner_org OR UI.list_cession OR UI.list_client::text IN ('full', 'partial')) AND
          (UI.list_address OR
          UI.list_document OR
          UI.list_court OR
          UI.list_osp OR
          UI.list_task_type OR
          UI.list_bankrupt_type OR
          (UI.list_application_tax_payment_export AND S.module_application_tax_enabled AND S.module_application_tax_available)) AS "ListMenuSeparator1Visible",
          --видимость второго разделителя
          UI.list_address AND
          ((UI.list_email AND S.module_email_enabled AND S.module_email_available) OR
          UI.list_document OR
          UI.list_court OR
          UI.list_osp OR
          UI.list_task_type OR 
          UI.list_bankrupt_type OR
          (UI.list_application_tax_payment_export AND S.module_application_tax_enabled AND S.module_application_tax_available)) AS "ListMenuSeparator2Visible",
          --видимость третьего разделителя
          (UI.list_email AND S.module_email_enabled AND S.module_email_available) AND
          (UI.list_document OR
          UI.list_court OR
          UI.list_osp OR
          UI.list_task_type OR
          UI.list_bankrupt_type OR
          (UI.list_application_tax_payment_export AND S.module_application_tax_enabled AND S.module_application_tax_available)) AS "ListMenuSeparator3Visible",
          --видимость четвертого разделителя
          UI.list_document AND
          (UI.list_court OR
          UI.list_osp OR
          UI.list_task_type OR
          UI.list_bankrupt_type OR
          (UI.list_application_tax_payment_export AND S.module_application_tax_enabled AND S.module_application_tax_available)) AS "ListMenuSeparator4Visible",
          --видимость пятого разделителя
          (UI.list_court OR
          UI.list_osp) AND
          (UI.list_task_type OR
          UI.list_bankrupt_type OR
          (UI.list_application_tax_payment_export AND S.module_application_tax_enabled AND S.module_application_tax_available)) AS "ListMenuSeparator5Visible",
          --видимость аудиозаписей
          UI.list_audio_file AS "ListAudioFilePermission",
          --видимость модулей БКИ
          S.module_nbki_available AS "NbkiPermission",
          S.module_equifax_available AS "EquifaxPermission",
          S.module_okb_available AS "OkbPermission",
          S.module_nbki_available OR module_equifax_available OR module_okb_available AS "BkiPermission",
          --видимость модуля автозадач
          S.module_autotask_available AS "ModuleAutotaskAvailable",
          --видимость модуля ФССП
          S.module_fssp_available AS "ModuleFsspAvailable",
          --видимость модуля Email
          S.module_email_enabled AND S.module_email_available AS "EmailPermission",
          UI.list_email AS "ListEmail",
          --Модуль "Почта России" виден, включен и доступен пользователю
          S.module_pochtaru_available AND S.module_pochtaru_enabled AS "ModulePochtaRuPermission",
          UI.list_pochtaru_orders AS "ListPochtaRuOrderPermission",
          --видимость модуля Debex(ФССП)
          UI.debex_fssp_check AND S.module_debex_fssp_available AND S.module_debex_fssp_enabled AS "ModuleDebexFsspPermission",
          --видимость модуля Debex(банкротство)
          UI.debex_bankrupt_check AND S.module_debex_bankrupt_available AND S.module_debex_bankrupt_enabled AS "ModuleDebexBankruptPermission",
          --видимость модуля Debex(подсудность)
          UI.debex_jurisdiction_check AND S.module_debex_jurisdiction_available AND S.module_debex_jurisdiction_enabled AS "ModuleDebexJurisdictionPermission",
          --видимость модуля госпошлины
          S.module_application_tax_enabled AND S.module_application_tax_available AS "ModuleApplicationTaxPermission",
          UI.report_application_tax_payment AS "ReportApplicationTaxPayment",
          UI.list_application_tax_payment_export AS "ListApplicationTaxPaymentExport"
        FROM
          collect.user_info UI
          LEFT JOIN settings S ON true
        WHERE
          user_id = {UserId};
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===КОРРЕСПОНДЕНЦИЯ==========================================-->
    <!--============================================================-->
    <SqlQuery Name="PostSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), dates AS (
          SELECT
            collect.convert_date_filter({CreateDateFrom}::timestamp) AS start_date,
            collect.convert_date_filter({CreateDateTo}::timestamp + interval '24h') AS finish_date
        ), post_table AS (
          SELECT
            LP.loan_post_id,
            L.loan_id
          FROM
            collect.loan_post LP
            LEFT JOIN dates D ON true
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN collect.loan L ON LP.loan_id = L.loan_id OR LC.loan_id = L.loan_id
          WHERE
            NOT L.deleted AND
            NOT L.archive AND
            ({CreateDateFrom} IS NULL OR LP.create_date >= D.start_date) AND
            ({CreateDateTo} IS NULL OR LP.create_date <![CDATA[<]]> D.finish_date) AND
            ({AuthorId}::smallint[] = ARRAY[NULL]::smallint[] OR LP.author_id = ANY({AuthorId}::smallint[])) AND
            ({Direction}::boolean[] = ARRAY[NULL]::boolean[] OR LP.direction = ANY({Direction}::boolean[])) AND
            ({RegisterDateFrom} IS NULL OR LP.register_date >= {RegisterDateFrom}::date) AND
            ({RegisterDateTo} IS NULL OR LP.register_date <![CDATA[<=]]> {RegisterDateTo}::date)
        ), email_settings AS (
          SELECT
            module_email_available
          FROM
            collect.settings
          LIMIT 1
        ), email_table AS (
          SELECT
            loan_client_mailing_email_id,
            loan_client_id,
            loan_id,
            client_title,
            mailing_email_id
          FROM
            collect.loan_client_mailing_email LCME
            LEFT JOIN dates D ON true
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN collect.loan L USING(loan_id)
            LEFT JOIN collect.mailing_email ME USING (mailing_email_id)
            LEFT JOIN collect.mailing M USING (mailing_id)
            CROSS JOIN email_settings
          WHERE
            NOT L.deleted AND
            NOT L.archive AND
            ({CreateDateFrom} IS NULL OR M.create_date >= D.start_date) AND
            ({CreateDateTo} IS NULL OR M.create_date <![CDATA[<]]> D.finish_date) AND
            ({AuthorId}::smallint[] = ARRAY[NULL]::smallint[] OR M.author_id = ANY({AuthorId}::smallint[])) AND
            ({Direction}::boolean[] = ARRAY[NULL]::boolean[] OR false = ANY({Direction}::boolean[])) AND
            ({RegisterDateFrom} IS NULL OR M.send_date >= {RegisterDateFrom}::date) AND
            ({RegisterDateTo} IS NULL OR M.send_date <![CDATA[<=]]> {RegisterDateTo}::date) AND
            module_email_available
        ), loan_users AS (
          SELECT
            LC.loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client LC
            JOIN post_table USING(loan_id)
          WHERE
            LC.user_id IS NOT NULL
          GROUP BY LC.loan_id
          UNION
          SELECT
            LC.loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client LC
            JOIN email_table USING(loan_id)
          WHERE
            LC.user_id IS NOT NULL
          GROUP BY LC.loan_id
        ), final_post AS (
          SELECT
            DISTINCT post_table.*
          FROM
            post_table
            LEFT JOIN loan_users LU USING(loan_id)
            LEFT JOIN current_user_info CUI ON true
          WHERE
            CUI.user_is_administrator OR
            (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
            {UserId} = ANY(LU.user_ids)
        ), final_email AS (
          SELECT
            DISTINCT email_table.*
          FROM
            email_table
            LEFT JOIN loan_users LU USING(loan_id)
            LEFT JOIN current_user_info CUI ON true
          WHERE
            CUI.user_is_administrator OR
            (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
            {UserId} = ANY(LU.user_ids)
        )
        SELECT
          LP.loan_post_id AS "ItemId",
          LP.direction AS "Direction",
          LP.participator_title AS "ParticipatorTitle",
          LP.inner_org_id AS "InnerOrgId",
          LP.create_date AS "CreateDate",
          LP.author_id AS "AuthorId",
          LP.number AS "Number",
          LP.register_date AS "RegisterDate",
          LP.date AS "Date",
          LPF.file_types AS "FileTypes",
          COALESCE(LPF.file_count, 0) > 0 AS "FileExists",
          false AS "IsEmail",
          NULL AS "MailingId"
        FROM
          final_post F
          LEFT JOIN collect.loan_post LP USING(loan_post_id)
          LEFT JOIN collect.loan_client LC USING(loan_client_id)
          LEFT JOIN collect.loan L ON LP.loan_id = L.loan_id OR LC.loan_id = L.loan_id
          LEFT JOIN (
            SELECT
              LPF.loan_post_id,
              string_agg(DISTINCT COALESCE(T.title, 'Другое'), ', ') AS file_types,
              count(loan_post_file_id) AS file_count
            FROM
              collect.loan_post_file LPF
              LEFT JOIN collect.template T USING(template_id)
            GROUP BY loan_post_id
          ) LPF USING(loan_post_id)

        UNION

        SELECT
          FE.loan_client_mailing_email_id,
          false,
          FE.client_title,
          ME.inner_org_id,
          M.create_date,
          M.author_id,
          '',
          M.send_date::date,
          M.send_date::date,
          MEF.file_types,
          COALESCE(MEF.file_count, 0) > 0,
          true,
          M.mailing_id AS "MailingId"
        FROM
          final_email FE
          LEFT JOIN collect.mailing_email ME USING (mailing_email_id)
          LEFT JOIN collect.mailing M USING (mailing_id)
          LEFT JOIN (
            SELECT
              ME.mailing_email_id,
              string_agg(DISTINCT COALESCE(T.title, 'Другое'), ', ') AS file_types,
              count(MEF.file_id) AS file_count
            FROM
              collect.mailing_email ME
              JOIN (SELECT DISTINCT mailing_email_id FROM collect.loan_client_mailing_email) D USING (mailing_email_id)
              JOIN 
              (
                SELECT mailing_id, mailing_email_id, file_id, template_id 
                FROM collect.mailing_email_file LEFT JOIN collect.mailing_email USING (mailing_email_id) 
              ) MEF ON ME.mailing_email_id = MEF.mailing_email_id OR (ME.mailing_id = MEF.mailing_id AND template_id ISNULL)
              LEFT JOIN collect.template T USING(template_id)
            GROUP BY ME.mailing_email_id
          ) MEF USING (mailing_email_id)
        ORDER BY "Date" DESC, "ItemId" DESC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="PostGuidSelectSqlQuery">
      <Text>
        SELECT
          DISTINCT F.guid AS "Guid"
        FROM
          collect.loan_post_file LPF
          JOIN public.file F USING(file_id)
        WHERE
          LPF.loan_post_id = ANY({LoanPostId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PostDeleteSqlQuery">
      <Text>
        SELECT
          collect.loan_post_file_delete(LPF.loan_post_file_id, {UserId}::smallint)
        FROM
          collect.loan_post_file LPF
        WHERE
          LPF.loan_post_id = ANY({LoanPostId}::bigint[]);

        SELECT
          collect.loan_post_delete(LP.loan_post_id, {UserId}::smallint)
        FROM
          collect.loan_post LP
        WHERE
          LP.loan_post_id = ANY({LoanPostId}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="PostByLoanIdSelectSqlQuery">
      <Text>
        WITH mass_mailing AS (
        SELECT
            mailing_email_id,
            COUNT(loan_client_mailing_email_id)>1 AS is_mass_mailing
        FROM
          collect.loan_client_mailing_email
          GROUP BY mailing_email_id
        ), email_settings AS (
          SELECT
            module_email_available
          FROM
            collect.settings
          LIMIT 1
        )
        SELECT
          LP.loan_post_id AS "ItemId",
          LP.loan_id AS "LoanId",
          LP.loan_client_id AS "LoanClientId",
          LP.direction AS "Direction",
          LP.number AS "Number",
          LP.register_date AS "RegisterDate",
          LP.date::timestamp without time zone AS "Date",
          LP.type AS "Type",
          LP.participator_title AS "ParticipatorTitle",
          LP.participator_address AS "ParticipatorAddress",
          LP.inner_org_id AS "InnerOrgId",
          LP.inner_org_address AS "InnerOrgAddress",
          LP.post_number AS "PostNumber",
          LP.description AS "Description",
          LP.create_date AS "CreateDate",
          LP.delivery_date AS "DeliveryDate",
          LP.author_id AS "AuthorId",
          LP.author_id = {UserId}::smallint OR collect.is_administrator({UserId}::smallint) AS "CurrentUserAccess",
          false AS "IsEmail",
          NULL AS "ClientEmail",
          NULL AS "MessageText",
          NULL AS "Sent",
          NULL AS "EmailSender",
          NULL AS "Subject",
          NULL AS "MailingTemplateId",
          NULL AS "MailingTemplateText",
          NULL AS "MailingEmailId",
          NULL AS "IsMassMailing",
          NULL AS "Special",
          NULL AS "MailingId"
        FROM
          collect.loan_post LP
          LEFT JOIN collect.loan_client LC USING(loan_client_id)
        WHERE
          LP.loan_id = {LoanId} OR
          LC.loan_id = {LoanId}

        UNION

        SELECT
          LCME.loan_client_mailing_email_id AS "ItemId",
          NULL AS "LoanId",
          LCME.loan_client_id AS "LoanClientId",
          false AS "Direction",
          NULL AS "Number",
          NULL AS "RegisterDate",
          send_date AS "Date",
          true AS "Type",
          client_title AS "ParticipatorTitle",
          NULL AS "ParticipatorAddress",
          ME.inner_org_id AS "InnerOrgId",
          NULL AS "InnerOrgAddress",
          NULL AS "PostNumber",
          ME.description AS "Description",
          M.create_date AS "CreateDate",
          null AS "DeliveryDate",
          M.author_id AS "AuthorId",
          M.author_id = {UserId}::smallint AS "AuthorIsCurrentUser",
          true AS "IsEmail",
          LCME.email_client AS "ClientEmail",
          LCME.message_text AS "MessageText",
          LCME.sent AS "Sent",
          ME.email_sender AS "EmailSender",
          ME.subject AS "Subject",
          M.mailing_template_id AS "MailingTemplateId",
          M.mailing_template_text AS "MailingTemplateText",
          ME.mailing_email_id AS "MailingEmailId",
          MM.is_mass_mailing AS "IsMassMailing",
          M.special AS "Special",
          M.mailing_id AS "MailingId"
        FROM
          collect.loan_client_mailing_email LCME
          LEFT JOIN collect.loan_client LC USING(loan_client_id)
          LEFT JOIN collect.mailing_email ME USING(mailing_email_id)
          LEFT JOIN collect.mailing M USING(mailing_id)
          LEFT JOIN mass_mailing MM USING(mailing_email_id)
          CROSS JOIN email_settings ES
        WHERE
          LC.loan_id = {LoanId} AND
          M.added AND
          ES.module_email_available
        ORDER BY "CreateDate" DESC, "ItemId" DESC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="PostFileByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          LPF.loan_post_file_id AS "LoanPostFileId",
          LP.loan_post_id AS "LoanPostId",
          F.guid AS "Guid",
          substr(F.path, length(F.path) - strpos(reverse(F.path),'\') + 2) AS "FileName",
          LPF.template_id AS "TemplateId",
          COALESCE(T.title,'Другое') AS "TemplateTitle",
          LPF.description AS "Description"
        FROM
          collect.loan_post_file LPF
          JOIN collect.loan_post LP USING(loan_post_id)
          LEFT JOIN collect.loan_client LCL USING(loan_client_id)
          LEFT JOIN public.file F USING(file_id)
          LEFT JOIN collect.template T USING(template_id)
        WHERE
          LP.loan_id = {LoanId} OR
          LCL.loan_id = {LoanId}
        ORDER BY LPF.loan_post_file_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="PostByIdSelectSqlQuery">
      <Text>
        SELECT
          COALESCE(LP.loan_id, LC.loan_id) AS "LoanId",
          LC.client_id AS "ClientId",
          LP.direction AS "Direction",
          LP.number AS "Number",
          LP.register_date AS "RegisterDate",
          LP.date AS "Date",
          LP.type AS "Type",
          LP.participator_title AS "ParticipatorTitle",
          LP.participator_address AS "ParticipatorAddress",
          LP.inner_org_id AS "InnerOrgId",
          LP.inner_org_address AS "InnerOrgAddress",
          LP.post_number AS "PostNumber",
          LP.description AS "Description",
          LP.delivery_date AS "DeliveryDate"
        FROM
          collect.loan_post LP
          LEFT JOIN collect.loan_client LC ON LC.loan_client_id = LP.loan_client_id
          LEFT JOIN collect.loan L ON L.loan_id = LP.loan_id
        WHERE
          LP.loan_post_id = {LoanPostId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="PostFileByPostIdSelectSqlQuery">
      <Text>
        SELECT
          LPF.loan_post_file_id AS "LoanPostFileId",
          F.guid AS "Guid",
          substr(F.path, length(F.path) - strpos(reverse(F.path),'\') + 2) AS "FileName",
          LPF.template_id AS "TemplateId",
          COALESCE(T.title,'Другое') AS "TemplateTitle",
          LPF.description AS "Description"
        FROM
          collect.loan_post_file LPF
          JOIN collect.loan_post LP USING(loan_post_id)
          LEFT JOIN collect.loan L USING(loan_id)
          LEFT JOIN collect.loan_client LCL USING(loan_client_id)
          LEFT JOIN public.file F USING(file_id)
          LEFT JOIN collect.template T USING(template_id)
        WHERE
          LPF.loan_post_id = {LoanPostId}
        ORDER BY LPF.loan_post_file_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientWithAddressSelectSqlQuery">
      <Text>
        SELECT
          DISTINCT ON ("FullTitle", C.client_id)
          C.client_id AS "ClientId",
          CASE WHEN COALESCE(A.address_string,'') = '' THEN ADR.address_string ELSE A.address_string END AS "Address",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "FullTitle",
          CP.email AS "Email",
          C.archive AS "Archive"
        FROM
          collect.client C
          LEFT JOIN collect.client_person CP USING(client_id)
          LEFT JOIN collect.client_address CA USING(client_id)
          LEFT JOIN collect.address A USING(address_id)
          LEFT JOIN collect.get_address_string() ADR USING(address_id)
        WHERE
          NOT C.deleted
        ORDER BY "FullTitle", C.client_id, CA.address_type_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="PostSaveSqlQuery">
      <Text>
        SELECT collect.loan_post_save({Model}::json, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===ЗАДАЧИ===================================================-->
    <!--============================================================-->
    <SqlQuery Name="TaskSelectSqlQuery">
      <Text>
        WITH loan_count_by_task AS (
          SELECT
            task_id,
            count(1) AS loan_count
          FROM
            collect.task_loan
          GROUP BY task_id
        --имя показывается для задач с одним фигурантом дела
        ), client_info AS (
          SELECT
            task_id,
            collect.get_title_from_array(
              array_agg(collect.get_client_title(CP.first_name, CP.second_name, CP.third_name)),
              'должник'::varchar) AS client_titles
          FROM
            collect.task_loan TL
            JOIN collect.client C USING (client_id)
            LEFT JOIN collect.client_person CP USING (client_id)
          GROUP BY task_id
        ), task_responsible_user_info AS (
          SELECT
            task_id,
            collect.get_title_from_array(
              array_agg(user_full_name),
              'исполнител'::varchar, 2::smallint, ARRAY['ь','я','ей']::varchar[]) AS responsible_user_titles,
            COUNT(user_id) AS count_user,
            array_agg(user_id) AS responsible_user_ids
          FROM
            collect.task_responsible_user TRU
            LEFT JOIN collect.user_info USING(user_id)
          GROUP BY
            task_id
        )
        SELECT
          T.task_id AS "TaskId",
          T.author_id AS "AuthorId",
          TRUI.responsible_user_titles  AS "ResponsibleUserTitles",
          COALESCE(LCBT.loan_count, 0) AS "LoanCount",
          T.create_date AS "CreateDate",
          T.deadline_date AS "DeadlineDate",
          T.execution_date AS "ExecutionDate",
          T.close_date AS "CloseDate",
          T.task_type_id AS "TaskTypeId",
          CI.client_titles AS "ClientTitles",
          T.task_status_id AS "TaskStatusId",
          T.description AS "Description",
          TC.comment AS "TaskLastComment",
          (T.deadline_date <![CDATA[<=]]> now()::date AND TS.name NOT IN ('executed','closed'))  AS "IsDeadline",
          collect.is_administrator({UserId}::smallint) OR {UserId} = T.author_id AS "UserIsAdmin",
          T.autotask_filter_id IS NULL AS "AuthorIsNotAutotask",
          TRUI.count_user AS "CountResponsibleUser"
        FROM
          collect.task T
          LEFT JOIN task_responsible_user_info TRUI USING(task_id)
          LEFT JOIN collect.task_status TS USING(task_status_id)
          LEFT JOIN loan_count_by_task LCBT USING(task_id)
          LEFT JOIN client_info CI USING(task_id)
          LEFT JOIN (
            SELECT
              DISTINCT ON (task_id)
              task_id,
              comment
            FROM
              collect.task_comment
            ORDER BY task_id, create_date DESC, task_comment_id DESC
          ) TC USING(task_id)
        WHERE
          (collect.is_administrator({UserId}::smallint) OR T.author_id = {UserId} OR {UserId} = ANY(responsible_user_ids)) AND
          ({AuthorId}::smallint[] = ARRAY[NULL]::smallint[] OR T.author_id = ANY({AuthorId}::smallint[])) AND
          ({ResponsibleUserId}::smallint[] = ARRAY[NULL]::smallint[] OR responsible_user_ids <![CDATA[&&]]> {ResponsibleUserId}::smallint[]) AND
          ({CreateDateFrom} IS NULL OR T.create_date >= {CreateDateFrom}::date) AND
          ({CreateDateTo} IS NULL OR T.create_date <![CDATA[<=]]> {CreateDateTo}::date) AND
          ({DeadlineDateFrom} IS NULL OR T.deadline_date >= {DeadlineDateFrom}::date) AND
          ({DeadlineDateTo} IS NULL OR T.deadline_date <![CDATA[<=]]> {DeadlineDateTo}::date) AND
          ({ExecutionDateFrom} IS NULL OR T.execution_date >= {ExecutionDateFrom}::date) AND
          ({ExecutionDateTo} IS NULL OR T.execution_date <![CDATA[<=]]> {ExecutionDateTo}::date) AND
          ({CloseDateFrom} IS NULL OR T.close_date >= {CloseDateFrom}::date) AND
          ({CloseDateTo} IS NULL OR T.close_date <![CDATA[<=]]> {CloseDateTo}::date) AND
          ({TaskTypeId}::bigint[] = ARRAY[NULL]::bigint[] OR T.task_type_id = ANY({TaskTypeId}::bigint[])) AND
          ({TaskStatusId}::integer[] = ARRAY[NULL]::integer[] OR T.task_status_id = ANY({TaskStatusId}::integer[]))
        ORDER BY deadline_date DESC, task_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TaskByIdSelectSqlQuery">
      <Text>
        SELECT
          T.task_type_id AS "TaskTypeId",
          T.create_date AS "CreateDate",
          T.deadline_date AS "DeadlineDate",
          T.execution_date AS "ExecutionDate",
          T.close_date AS "CloseDate",
          T.task_status_id AS "TaskStatusId",
          T.author_id AS "AuthorId",
          T.description AS "Description",
          collect.is_administrator({UserId}::smallint) OR {UserId} = T.author_id AS "UserIsAdmin",
          T.autotask_filter_id IS NOT NULL AS "IsAutotask"
        FROM
          collect.task T
        WHERE
          T.task_id = {TaskId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ResponsibleUserIdByTaskIdSelectSqlQuery">
      <Text>
        SELECT
          user_id AS "ResponsibleUserId"
        FROM
          collect.task_responsible_user
        WHERE
          task_id = {TaskId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanAllowedForUserSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids,
            (SELECT list_client FROM collect.user_info WHERE user_id = {UserId}) AS list_client
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}
        ), loan_users AS (
          SELECT
            LC.loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client LC
          WHERE
            LC.user_id IS NOT NULL
          GROUP BY LC.loan_id
        )

        SELECT
          DISTINCT L.loan_id AS "LoanId",
          CUI.user_is_administrator OR
          (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
          {UserId} = ANY(LU.user_ids) AS "LoanAllowed"
        FROM
          collect.loan L
          LEFT JOIN loan_users LU USING(loan_id)
          LEFT JOIN current_user_info CUI ON true
        WHERE
          NOT L.deleted;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientAllowedForUserSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids,
            (SELECT list_client FROM collect.user_info WHERE user_id = {UserId}) AS list_client
          FROM
            collect.user_user
            WHERE
            parent_user_id = {UserId}
        ), loan_users AS (
          SELECT
            LC.loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client LC
          WHERE
            LC.user_id IS NOT NULL
          GROUP BY LC.loan_id
        )

        SELECT
          C.client_id AS "ClientId",
          bool_or(
            NOT (list_client = 'none') AND
            (
              list_client = 'full' OR
              (
                list_client = 'partial' AND
                COALESCE(
                  (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
                  {UserId} = ANY(LU.user_ids),
                  false
                )
              )
            )
          ) AS "ClientAllowed"
        FROM
          collect.client C
          LEFT JOIN collect.loan_client LC USING(client_id)
          LEFT JOIN collect.loan L USING(loan_id)
          LEFT JOIN loan_users LU USING(loan_id)
          LEFT JOIN current_user_info CUI ON true
        WHERE
          NOT C.deleted AND
          NOT L.deleted
        GROUP BY
          C.client_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TaskLoanByTaskIdSelectSqlQuery">
      <Text>
        SELECT
          TL.task_loan_id AS "TaskLoanId",
          TL.loan_id AS "LoanId",
          TL.client_id AS "ClientId"
        FROM
          collect.task_loan TL
        WHERE
          task_id = {TaskId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="TaskCommentByTaskIdSelectSqlQuery">
      <Text>
        SELECT
          TC.task_comment_id AS "TaskCommentId",
          TC.author_id AS "AuthorId",
          TC.create_date AS "CreateDate",
          TC.comment AS "Comment"
        FROM
          collect.task_comment TC
        WHERE
          TC.task_id = {TaskId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="TaskSaveSqlQuery">
      <Text>
        SELECT collect.task_save({Model}::json, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="TaskStatusUpdateSqlQuery">
      <Text>
        SELECT collect.task_status_update({TaskId}::bigint[], {TaskStatusId}::integer, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="TaskDeleteSqlQuery">
      <Text>
        SELECT collect.task_delete({TaskId}::bigint[], {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="TaskStatusSelectSqlQuery">
      <Text>
        SELECT
          task_status_id AS "TaskStatusId",
          name AS "Name",
          title AS "Title"
        FROM
          collect.task_status
        ORDER BY task_status_id;
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===ЗАГРУЗКА АУДИОЗАПИСЕЙ====================================-->
    <!--============================================================-->
    <SqlQuery Name="TempAudioFileSelectSqlQuery">
      <Text>
        UPDATE
          collect.temp_audio_file TAF
        SET
          client_id = T.client_id,
          loan_id = T.loan_id,
          manual_input = false
        FROM
        (
          WITH client_phones AS (
            SELECT
              CP.client_phone_id,
              CP.client_id,
              LC.loan_id,
              CASE
                WHEN substr(CP.phone_number,1,2) = '+7' THEN substr(CP.phone_number,3)
                WHEN substr(CP.phone_number,1,1) = '8' THEN substr(CP.phone_number,2)
                ELSE CP.phone_number
              END AS client_phone_number
            FROM
              collect.client_phone CP
              LEFT JOIN collect.loan_client LC USING(client_id)
              JOIN collect.client C USING(client_id)
            WHERE
              NOT C.deleted AND
              COALESCE(CP.phone_number,'') != ''
        ), temp_phones AS (
            SELECT
              temp_audio_file_id,
              CASE
                WHEN substr(client_phone_number,1,2) = '+7' THEN substr(client_phone_number,3)
                WHEN substr(client_phone_number,1,1) = '8' THEN substr(client_phone_number,2)
                ELSE client_phone_number
              END AS temp_phone_number
            FROM
              collect.temp_audio_file
            WHERE
              loan_id IS NULL OR
              loan_id = ARRAY[NULL]::bigint[] OR
              loan_id = ARRAY[]::bigint[]
        ), result AS (
            SELECT
              client_id,
              loan_id,
              temp_audio_file_id
            FROM
              client_phones, temp_phones
            WHERE
              (temp_phone_number ilike '%'||client_phone_number||'%' OR client_phone_number ilike '%'||temp_phone_number||'%') AND
              length(client_phone_number) > 6 AND
              length(temp_phone_number) > 6
          )
          SELECT
            temp_audio_file_id,
            array_agg(client_id) AS client_id,
            array_agg(loan_id) AS loan_id
          FROM
            result
          GROUP BY temp_audio_file_id
        ) T
        WHERE
          T.temp_audio_file_id = TAF.temp_audio_file_id AND
          {UpdateData};

        UPDATE
          collect.temp_audio_file
        SET
          to_save = false
        WHERE
          {UpdateData};

        SELECT
          TAF.to_save AS "ToSave",
          TAF.temp_audio_file_id AS "TempAudioFileId",
          F.guid AS "Guid",
          TAF.client_phone_number AS "ClientPhoneNumber",
          TAF.user_phone_number AS "UserPhoneNumber",
          TAF.call_time AS "CallTime",
          CASE
            WHEN TAF.call_direction THEN 'Входящий'
            WHEN NOT TAF.call_direction THEN 'Исходящий'
            ELSE NULL::character varying
          END AS "CallDirection",
          TAF.call_duration AS "CallDuration",
          CASE
            WHEN CC.client_count > 0 AND (TAF.loan_id = ARRAY[NULL]::bigint[] OR TAF.loan_id = ARRAY[]::bigint[] OR TAF.loan_id IS NULL) THEN 'has_client_no_loan'
            WHEN (TAF.loan_id = ARRAY[NULL]::bigint[] OR TAF.loan_id = ARRAY[]::bigint[] OR TAF.loan_id IS NULL) THEN 'no_loan'
            WHEN TAF.manual_input THEN 'manual_input'
            WHEN CC.client_count > 1 THEN 'multiple_client'
            ELSE 'match'
          END AS "Status",
          array_to_string((
            SELECT
              array_agg(cp_data.full_title || COALESCE(', КД: ' || loan_data.credit_number,''))
            FROM
              collect.client C
              JOIN (
                SELECT
                  CP.client_id,
                  collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS full_title
                FROM
                  collect.client_person CP
                WHERE
                  client_id = ANY(TAF.client_id)
              ) cp_data USING(client_id)
              LEFT JOIN (
                SELECT
                  LC.client_id,
                  string_agg(L.credit_number,', ') as credit_number
                FROM
                  collect.loan_client LC
                  LEFT JOIN collect.loan L USING(loan_id)
                  JOIN (
                    SELECT
                     unnest(TAF.client_id) AS client_id,
                     unnest(TAF.loan_id) AS loan_id
                  ) T ON LC.client_id = T.client_id AND LC.loan_id = T.loan_id
                GROUP BY LC.client_id
              ) loan_data USING (client_id)
          ), E'\r\n') AS "MatchString"
        FROM
          collect.temp_audio_file TAF
          LEFT JOIN (
            SELECT
              temp_audio_file_id,
              count(DISTINCT client_id) AS client_count
            FROM (
              SELECT
                temp_audio_file_id,
                unnest(client_id) AS client_id
              FROM
                collect.temp_audio_file
            ) T
            GROUP BY temp_audio_file_id
          ) CC USING(temp_audio_file_id)
          LEFT JOIN public.file F USING(file_id)
        ORDER BY call_time;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempAudioFileByIdSelectSqlQuery">
      <Text>
        SELECT
          unnest(client_id) AS "ClientId",
          unnest(loan_id) AS "LoanId"
        FROM
          collect.temp_audio_file TAF
        WHERE
          TAF.temp_audio_file_id = {TempAudioFileId}
        ORDER BY "ClientId";
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempAudioFileUpdateSqlQuery">
      <Text>
        UPDATE
          collect.temp_audio_file
        SET
          client_id = {ClientId}::bigint[],
          loan_id = {LoanId}::bigint[],
          manual_input = CASE WHEN {ChangedManually} THEN true ELSE manual_input END
        WHERE
          temp_audio_file_id = {TempAudioFileId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempAudioFileToSaveUpdateSqlQuery">
      <Text>
        UPDATE
          collect.temp_audio_file TAF
        SET
          to_save = COALESCE(T.to_save,false)
        FROM (
          SELECT
            unnest({ToSave}::boolean[]) AS to_save,
            unnest({TempAudioFileId}::bigint[]) AS temp_audio_file_id
          ) T
        WHERE
          TAF.temp_audio_file_id = T.temp_audio_file_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempAudioFileSaveSqlQuery">
      <Text>
        UPDATE
          collect.temp_audio_file TAF
        SET
          to_save = COALESCE(T.to_save,false)
        FROM (
          SELECT
            unnest({ToSave}::boolean[]) AS to_save,
            unnest({TempAudioFileId}::bigint[]) AS temp_audio_file_id
          ) T
        WHERE
          TAF.temp_audio_file_id = T.temp_audio_file_id;

        WITH A AS (
          SELECT
            unnest(loan_id) AS loan_id,
            file_id,
            record_id,
            call_time,
            call_direction,
            call_duration,
            client_phone_number,
            user_phone_number
          FROM
            collect.temp_audio_file
          WHERE
            to_save
        ), B AS (
          SELECT
            DISTINCT loan_id,
            file_id,
            record_id,
            call_time,
            call_direction,
            call_duration,
            client_phone_number,
            user_phone_number
          FROM
            A
        )
        SELECT
          collect.loan_audio_file_insert(
            loan_id,
            file_id,
            record_id,
            call_time,
            call_direction,
            call_duration,
            client_phone_number,
            user_phone_number,
            'Добавлено из загруженных аудиозаписей'::character varying,
            {UserId}::smallint)
        FROM
          B;

        DELETE FROM collect.temp_audio_file WHERE to_save OR {DeleteAll};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ClientPhoneFromTempAudioInsertSqlQuery">
      <Text>
        WITH client_phone_number AS (
          SELECT
            CASE
              WHEN substr(phone_number,1,2) = '+7' THEN substr(phone_number,3)
              WHEN substr(phone_number,1,1) = '8' THEN substr(phone_number,2)
              ELSE replace(phone_number, '+', '')
            END AS phone_number
          FROM
            collect.client_phone
          WHERE
            client_id = {ClientId}
        ), new_phone_number AS (
          SELECT
            CASE
              WHEN COALESCE({ClientPhoneNumber},'') = '' THEN NULL::character varying
              WHEN substr({ClientPhoneNumber},1,2) = '+7' THEN substr({ClientPhoneNumber},3)
              WHEN substr({ClientPhoneNumber},1,1) = '8' THEN substr({ClientPhoneNumber},2)
              ELSE replace({ClientPhoneNumber}, '+', '')
            END AS phone_number
        )
        SELECT
          collect.client_phone_insert(
            {ClientId}::bigint,
            {ClientPhoneNumber},
            (SELECT phone_type_id FROM collect.phone_type WHERE title = 'Другой'),
            NULL::character varying,
            NULL::integer,
            NULL::character varying,
            NULL::character varying,
            'Добавлено из загруженных аудиозаписей',
            false,
            {UserId}::smallint
            )
        WHERE
          NOT EXISTS (SELECT 1 FROM client_phone_number CPN, new_phone_number NPN WHERE CPN.phone_number = NPN.phone_number);
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempAudioFileDeleteSqlQuery">
      <Text>
        DELETE FROM
          collect.temp_audio_file
        WHERE
          temp_audio_file_id = ANY({TempAudioFileId}::bigint[]);
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===КАТЕГОРИИ ПЕЧАТНЫХ ФОРМ (ШАБЛОНОВ)=======================-->
    <!--============================================================-->
    <SqlQuery Name="TemplateCategorySelectSqlQuery">
      <Text>
        SELECT
          template_category_id AS "TemplateCategoryId",
          title AS "Title",
          archive AS "Archive"
        FROM
          collect.template_category TC
        ORDER BY title, template_category_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TemplateCategoryByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title"
        FROM
          collect.template_category
        WHERE
          template_category_id = {TemplateCategoryId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="TemplateCategoryInsertSqlQuery">
      <Text>
        INSERT INTO collect.template_category(title)
        VALUES({Title})
        RETURNING template_category_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TemplateCategoryUpdateSqlQuery">
      <Text>
        UPDATE
          collect.template_category
        SET
          title = {Title}
        WHERE
          template_category_id = {TemplateCategoryId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="TemplateCategoryArchiveSqlQuery">
      <Text>
        UPDATE
          collect.template_category
        SET
          archive = {Archive}
        WHERE
          template_category_id = {TemplateCategoryId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="TemplateCategoryDeleteSqlQuery">
      <Text>
        SELECT collect.template_category_try_delete({TemplateCategoryId}::bigint);
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===ПЕЧАТНЫЕ ФОРМЫ (ШАБЛОНЫ)=================================-->
    <!--============================================================-->
    <SqlQuery Name="TemplateSelectSqlQuery">
      <Text>
        SELECT
          T.template_id AS "TemplateId",
          T.title AS "Title",
          T.name AS "Name",
          T.name IS NOT NULL AS "System",
          T.archive AS "Archive",
          COALESCE((substr(F.path, length(F.path) - strpos(reverse(F.path),'\') + 2)), T.title) AS "FileName",
          F.guid AS "Guid",
          COALESCE(F.path, T.system_path) AS "Path",
          COALESCE(TC.title, '[Без категории]') AS "TemplateCategoryTitle"
        FROM
          collect.template T
          LEFT JOIN public.file F USING(file_id)
          LEFT JOIN collect.template_category TC USING(template_category_id)
        ORDER BY T.title;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TemplateForContextMenuSelectSqlQuery">
      <Text>
        WITH TC AS (
          SELECT
            DISTINCT ON (TC.title, TC.template_category_id)
            TC.title AS item_title,
            TC.template_category_id AS template_category_id,
            null::bigint AS template_id,
            null::character varying AS guid,
            null::character varying AS path,
            'MenuItem' AS type
          FROM
            collect.template_category TC
            JOIN collect.template T USING(template_category_id)
          WHERE
            NOT T.archive
          ORDER BY TC.title, TC.template_category_id
        ), T AS (
          SELECT
            T.title AS item_title,
            T.template_category_id AS template_category_id,
            T.template_id AS template_id,
            F.guid AS guid,
            COALESCE(F.path, T.system_path) AS path,
            'MenuItem' AS type
          FROM
            collect.template T
            LEFT JOIN public.file F USING(file_id)
          WHERE
            NOT T.archive
          ORDER BY T.title
        ), A AS(
          SELECT
            'Любой файл'::character varying AS item_title,
            null::bigint AS template_category_id,
            null::bigint AS template_id,
            null::character varying AS guid,
            null::character varying AS path,
            'MenuItem'::character varying AS type
          WHERE
            {IncludeOther}

          UNION ALL

          SELECT
            null AS item_title,
            null AS template_category_id,
            null AS template_id,
            null AS guid,
            null AS path,
            'Separator' AS type
          WHERE
            {IncludeOther}

          UNION ALL

          SELECT
            *
          FROM
            TC

          UNION ALL

          SELECT
            null AS item_title,
            null AS template_category_id,
            null AS template_id,
            null AS guid,
            null AS path,
            'Separator' AS type
          WHERE
            EXISTS (SELECT 1 FROM collect.template WHERE template_category_id IS NOT NULL AND NOT archive) AND
            EXISTS (SELECT 1 FROM collect.template WHERE template_category_id IS NULL AND NOT archive)

          UNION ALL

          SELECT
            *
          FROM
            T
          ), S AS (
            SELECT
            row_number() OVER() AS id,
            *
            FROM
              A
          )
        SELECT
          item_title AS "Title",
          template_id AS "TemplateId",
          id AS "Id",
          CASE WHEN template_id IS NOT NULL AND template_category_id IS NOT NULL THEN
          (SELECT id FROM S S1 WHERE template_id IS NULL AND S1.template_category_id = S.template_category_id) ELSE NULL::bigint END AS "ParentId",
          type AS "Type",
          guid AS "Guid",
          path AS "Path"
        FROM
          S;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TemplateByIdSelectSqlQuery">
      <Text>
        SELECT
          T.title AS "Title",
          COALESCE((substr(F.path, length(F.path) - strpos(reverse(F.path),'\') + 2)), T.title) AS "FileName",
          F.guid AS "Guid",
          T.system_path AS "SystemPath",
          T.template_category_id AS "TemplateCategoryId",
          T.name IS NOT NULL AS "System",
          T.update_fields_on_mail_sent AS "UpdateFieldsOnMailSent",
          T.update_fields_on_mail_arrival AS "UpdateFieldsOnMailArrival"
        FROM
          collect.template T
          LEFT JOIN public.file F USING(file_id)
        WHERE
          template_id = {TemplateId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="FieldsSelectSqlQuery">
      <Text>
        SELECT
          field_id AS "FieldId",
          description AS "Description"
        FROM
          collect.field;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TemlplateUpdateFieldsSelectSqlQuery">
      <Text>
        SELECT
          field_id AS "FieldId",
          on_mail_sent AS "UpdateOnMailSent",
          on_mail_arrival AS "UpdateOnMailArrival"
        FROM
          collect.template_update_field
        WHERE
          template_id = {TemplateId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="TemplateInsertSqlQuery">
      <Text>
        INSERT INTO collect.template (
          title,
          template_category_id,
          update_fields_on_mail_sent,
          update_fields_on_mail_arrival,
          file_id)
        SELECT
          {Title},
          {TemplateCategoryId},
          {UpdateFieldsOnMailSent},
          {UpdateFieldsOnMailArrival},
          file_id
        FROM
          public.file
        WHERE
          guid = {Guid}
        RETURNING template_id;

        INSERT INTO collect.template_update_field (
          template_id,
          field_id,
          on_mail_sent,
          on_mail_arrival)
        SELECT
          currval('collect.template_id_seq'),
          field_id,
          field_id = ANY({UpdateOnMailSentFieldIds}::bigint[]),
          field_id = ANY({UpdateOnMailArrivalFieldIds}::bigint[])
        FROM
          collect.field;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TemplateUpdateSqlQuery">
      <Text>
        UPDATE
          collect.template
        SET
          title = {Title},
          template_category_id = {TemplateCategoryId},
          update_fields_on_mail_sent = {UpdateFieldsOnMailSent},
          update_fields_on_mail_arrival = {UpdateFieldsOnMailArrival},
          file_id = (SELECT file_id FROM public.file WHERE guid = {Guid})
        WHERE
          template_id = {TemplateId};

        DELETE FROM
          collect.template_update_field
        WHERE
          template_id = {TemplateId};

        INSERT INTO collect.template_update_field (
          template_id,
          field_id,
          on_mail_sent,
          on_mail_arrival)
        SELECT
          {TemplateId},
          field_id,
          field_id = ANY({UpdateOnMailSentFieldIds}::bigint[]),
          field_id = ANY({UpdateOnMailArrivalFieldIds}::bigint[])
        FROM
          collect.field;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TemplateArchiveSqlQuery">
      <Text>
        UPDATE
          collect.template
        SET
          archive = {Archive}
        WHERE
          template_id = {TemplateId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="TemplateDeleteSqlQuery">
      <Text>
        SELECT collect.template_try_delete({TemplateId});
      </Text>
    </SqlQuery>

    <SqlQuery Name="TemplateVariableSelectSqlQuery">
      <Text>
        WITH RECURSIVE tree(
          template_variable_id,
          template_variable_category_id,
          title,
          name,
          description,
          path,
          tmp_order
          ) AS (
            SELECT
              template_variable_id,
              template_variable_category_id,
              title,
              name,
              description,
              ARRAY[template_variable_id]::bigint[] AS path,
              ARRAY[row_number]
            FROM
              T
            WHERE
              template_variable_category_id IS NULL

            UNION

            SELECT
              T.template_variable_id,
              T.template_variable_category_id,
              T.title, T.name, T.description,
              tree.path || T.template_variable_id::bigint AS path,
              tree.tmp_order || T.row_number
            FROM
              T
              JOIN tree ON tree.template_variable_id = T.template_variable_category_id
          ), T AS (
            SELECT
              *,
              ROW_NUMBER() OVER(PARTITION BY template_variable_category_id ORDER BY title IS NULL, order_number)
            FROM
              collect.template_variable
          ), closed_category AS (
            SELECT
              temp_tree_id AS id,
              item_path AS path
            FROM
              collect.temp_tree
            WHERE
              user_id = {UserId} AND
              form_name = 'TemplateVariableList'
          ), tree_final AS (
            SELECT
              closed1.path IS NOT NULL childred_closed,
              closed2.path IS NOT NULL closed,
              (LEAD(tree.path, 1, ARRAY[]::bigint[]) OVER(ORDER BY tree.path))[1:array_length(tree.path, 1)] = tree.path AS has_child,
              closed2.id state_id,
              tree.*
            FROM
              tree
              LEFT JOIN closed_category closed1 ON tree.path[1:array_length(closed1.path, 1)] = closed1.path AND tree.path != closed1.path
              LEFT JOIN closed_category closed2 ON closed2.path = tree.path
          )
        SELECT
          T.closed AS "Closed",
          T.template_variable_category_id IS NULL AS "Main",
          CASE WHEN T.template_variable_id <![CDATA[<]]> 0 THEN false ELSE T.has_child END AS "HasChildren",
          T.state_id AS "TreeStateId",
          T.path::varchar AS "ItemPath",
          T.title AS "VariableTitle",
          CASE WHEN array_length(T.path, 1) > 1 THEN COALESCE(repeat('  ', (array_length(T.path, 1)-1)*2) || ' ', '') ELSE '' END || description AS "Description"
        FROM
          tree_final T
        WHERE
          NOT T.childred_closed
        ORDER BY T.tmp_order;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TreeStateInsertSqlQuery">
      <Text>
        INSERT INTO collect.temp_tree(
          user_id,
          item_path,
          form_name)
        VALUES(
          {UserId},
          {ItemPath}::bigint[],
          {FormName});
      </Text>
    </SqlQuery>

    <SqlQuery Name="TreeStateDeleteSqlQuery">
      <Text>
        DELETE FROM
          collect.temp_tree
        WHERE
          temp_tree_id = {TreeStateId} AND
          user_id = {UserId};
      </Text>
    </SqlQuery>


<!--============================================================-->
<!--===СТАТУСЫ==================================================-->
<!--============================================================-->
    <SqlQuery Name="StatusSelectSqlQuery">
      <Text>
        SELECT
          S.status_id AS "StatusId",
          S.order_number AS "OrderNumber",
          S.title AS "Title",
          COALESCE(C.html_code, '#FFFFFF') AS "ColorHtmlCode",
          S.is_start_status AS "IsStartStatus",
          S.is_finish_status AS "IsFinishStatus",
          S.is_sold_status AS "IsSoldStatus",
          S.is_bankrupt_status AS "IsBankruptStatus",
          S.archive AS "Archive"
        FROM
          collect.status S
          LEFT JOIN collect.color C USING(color_id)
        ORDER BY S.order_number, S.status_id, S.title;
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status2SelectSqlQuery">
      <Text>
        SELECT
          S.status_id AS "StatusId",
          S.order_number AS "OrderNumber",
          S.title AS "Title",
          COALESCE(C.html_code, '#FFFFFF') AS "ColorHtmlCode",
          S.is_start_status AS "IsStartStatus",
          S.is_finish_status AS "IsFinishStatus",
          S.is_sold_status AS "IsSoldStatus",
          S.is_bankrupt_status AS "IsBankruptStatus",
          S.archive AS "Archive"
        FROM
          collect.status2 S
          LEFT JOIN collect.color C USING(color_id)
        ORDER BY S.order_number, S.status_id, S.title;
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status3SelectSqlQuery">
      <Text>
        SELECT
          S.status_id AS "StatusId",
          S.order_number AS "OrderNumber",
          S.title AS "Title",
          COALESCE(C.html_code, '#FFFFFF') AS "ColorHtmlCode",
          S.is_start_status AS "IsStartStatus",
          S.is_finish_status AS "IsFinishStatus",
          S.is_sold_status AS "IsSoldStatus",
          S.is_bankrupt_status AS "IsBankruptStatus",
          S.archive AS "Archive"
        FROM
          collect.status3 S
          LEFT JOIN collect.color C USING(color_id)
        ORDER BY S.order_number, S.status_id, S.title;
      </Text>
    </SqlQuery>

    <SqlQuery Name="StatusByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title",
          is_start_status AS "IsStartStatus",
          is_finish_status AS "IsFinishStatus",
          is_bankrupt_status AS "IsBankruptStatus",
          is_sold_status AS "IsSoldStatus",
          color_id AS "ColorId",
          close_reason_id AS "CloseReasonId"
        FROM
          collect.status
        WHERE
          status_id = {StatusId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status2ByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title",
          is_start_status AS "IsStartStatus",
          is_finish_status AS "IsFinishStatus",
          is_bankrupt_status AS "IsBankruptStatus",
          is_sold_status AS "IsSoldStatus",
          color_id AS "ColorId",
          close_reason_id AS "CloseReasonId"
        FROM
          collect.status2
        WHERE
          status_id = {StatusId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status3ByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title",
          is_start_status AS "IsStartStatus",
          is_finish_status AS "IsFinishStatus",
          is_bankrupt_status AS "IsBankruptStatus",
          is_sold_status AS "IsSoldStatus",
          color_id AS "ColorId",
          close_reason_id AS "CloseReasonId"
        FROM
          collect.status3
        WHERE
          status_id = {StatusId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="StatusInsertSqlQuery">
      <Text>
        UPDATE
          collect.status
        SET
          is_start_status = false
        WHERE
          {IsStartStatus} AND
          is_start_status;

        UPDATE
          collect.status
        SET
          is_bankrupt_status = false
        WHERE
          {IsBankruptStatus} AND
          is_bankrupt_status;

        INSERT INTO collect.status(
          title,
          color_id,
          is_start_status,
          is_finish_status,
          order_number,
          is_sold_status,
          is_bankrupt_status,
          close_reason_id
          )
        SELECT
          {Title},
          {ColorId},
          {IsStartStatus},
          {IsFinishStatus},
          COALESCE(MAX(order_number), 0) + 1,
          {IsSoldStatus},
          {IsBankruptStatus},
          {CloseReasonId}
        FROM
          collect.status
        RETURNING status_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status2InsertSqlQuery">
      <Text>
        UPDATE
          collect.status2
        SET
          is_start_status = false
        WHERE
          {IsStartStatus} AND
          is_start_status;

        UPDATE
          collect.status2
        SET
          is_bankrupt_status = false
        WHERE
          {IsBankruptStatus} AND
          is_bankrupt_status;

        INSERT INTO collect.status2(
          title,
          color_id,
          is_start_status,
          is_finish_status,
          order_number,
          is_sold_status,
          is_bankrupt_status,
          close_reason_id
          )
        SELECT
          {Title},
          {ColorId},
          {IsStartStatus},
          {IsFinishStatus},
          COALESCE(MAX(order_number), 0) + 1,
          {IsSoldStatus},
          {IsBankruptStatus},
          {CloseReasonId}
        FROM
          collect.status2
        RETURNING status_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status3InsertSqlQuery">
      <Text>
        UPDATE
          collect.status3
        SET
          is_start_status = false
        WHERE
          {IsStartStatus} AND
          is_start_status;

        UPDATE
          collect.status3
        SET
          is_bankrupt_status = false
        WHERE
          {IsBankruptStatus} AND
          is_bankrupt_status;

        INSERT INTO collect.status3(
          title,
          color_id,
          is_start_status,
          is_finish_status,
          order_number,
          is_sold_status,
          is_bankrupt_status,
          close_reason_id
          )
        SELECT
          {Title},
          {ColorId},
          {IsStartStatus},
          {IsFinishStatus},
          COALESCE(MAX(order_number), 0) + 1,
          {IsSoldStatus},
          {IsBankruptStatus},
          {CloseReasonId}
        FROM
          collect.status3
        RETURNING status_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="StatusUpdateSqlQuery">
      <Text>
        UPDATE
          collect.status
        SET
          is_start_status = false
        WHERE
          {IsStartStatus} AND
          is_start_status;

        UPDATE
          collect.status
        SET
          is_bankrupt_status = false
        WHERE
          {IsBankruptStatus} AND
          is_bankrupt_status;

        UPDATE
          collect.status
        SET
          title = {Title},
          color_id = {ColorId},
          is_start_status = {IsStartStatus},
          is_finish_status = {IsFinishStatus},
          is_sold_status = {IsSoldStatus},
          is_bankrupt_status = {IsBankruptStatus},
          close_reason_id = {CloseReasonId}
        WHERE
          status_id = {StatusId};

        UPDATE
          collect.status
        SET
          is_start_status = true
        WHERE
          NOT EXISTS (SELECT 1 FROM collect.status WHERE NOT archive AND is_start_status) AND
          status_id = COALESCE((SELECT MIN(status_id) FROM collect.status WHERE status_id != {StatusId}), {StatusId});
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status2UpdateSqlQuery">
      <Text>
        UPDATE
          collect.status2
        SET
          is_start_status = false
        WHERE
          {IsStartStatus} AND
          is_start_status;

        UPDATE
          collect.status2
        SET
          is_bankrupt_status = false
        WHERE
          {IsBankruptStatus} AND
          is_bankrupt_status;

        UPDATE
          collect.status2
        SET
          title = {Title},
          color_id = {ColorId},
          is_start_status = {IsStartStatus},
          is_finish_status = {IsFinishStatus},
          is_sold_status = {IsSoldStatus},
          is_bankrupt_status = {IsBankruptStatus},
          close_reason_id = {CloseReasonId}
        WHERE
          status_id = {StatusId};

        UPDATE
          collect.status2
        SET
          is_start_status = true
        WHERE
          NOT EXISTS (SELECT 1 FROM collect.status2 WHERE NOT archive AND is_start_status) AND
          status_id = COALESCE((SELECT MIN(status_id) FROM collect.status2 WHERE status_id != {StatusId}), {StatusId});
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status3UpdateSqlQuery">
      <Text>
        UPDATE
          collect.status3
        SET
          is_start_status = false
        WHERE
          {IsStartStatus} AND
          is_start_status;

        UPDATE
          collect.status3
        SET
          is_bankrupt_status = false
        WHERE
          {IsBankruptStatus} AND
          is_bankrupt_status;

        UPDATE
          collect.status3
        SET
          title = {Title},
          color_id = {ColorId},
          is_start_status = {IsStartStatus},
          is_finish_status = {IsFinishStatus},
          is_sold_status = {IsSoldStatus},
          is_bankrupt_status = {IsBankruptStatus},
          close_reason_id = {CloseReasonId}
        WHERE
          status_id = {StatusId};

        UPDATE
          collect.status3
        SET
          is_start_status = true
        WHERE
          NOT EXISTS (SELECT 1 FROM collect.status3 WHERE NOT archive AND is_start_status) AND
          status_id = COALESCE((SELECT MIN(status_id) FROM collect.status3 WHERE status_id != {StatusId}), {StatusId});
      </Text>
    </SqlQuery>

    <SqlQuery Name="StatusArchiveSqlQuery">
      <Text>
        UPDATE
          collect.status
        SET
          archive = {Archive},
          order_number = CASE WHEN {Archive} THEN NULL ELSE COALESCE((SELECT MAX(order_number) FROM collect.status), 0) + 1 END
        WHERE
          status_id = {StatusId};

        SELECT collect.status_order_number_recount();
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status2ArchiveSqlQuery">
      <Text>
        UPDATE
          collect.status2
        SET
          archive = {Archive},
          order_number = CASE WHEN {Archive} THEN NULL ELSE COALESCE((SELECT MAX(order_number) FROM collect.status2), 0) + 1 END
        WHERE
          status_id = {StatusId};

        SELECT collect.status2_order_number_recount();
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status3ArchiveSqlQuery">
      <Text>
        UPDATE
          collect.status3
        SET
          archive = {Archive},
          order_number = CASE WHEN {Archive} THEN NULL ELSE COALESCE((SELECT MAX(order_number) FROM collect.status3), 0) + 1 END
        WHERE
          status_id = {StatusId};

        SELECT collect.status3_order_number_recount();
      </Text>
    </SqlQuery>

    <SqlQuery Name="StatusDeleteSqlQuery">
      <Text>
        SELECT collect.status_try_delete({StatusId});
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status2DeleteSqlQuery">
      <Text>
        SELECT collect.status2_try_delete({StatusId});
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status3DeleteSqlQuery">
      <Text>
        SELECT collect.status3_try_delete({StatusId});
      </Text>
    </SqlQuery>

    <SqlQuery Name="StatusOrderNumberIncreaseSqlQuery">
      <Text>
        SELECT
          collect.status_order_number_recount()
        FROM
          collect.status
        WHERE
          status_id = {StatusId} AND
          order_number IS NULL;

        UPDATE
          collect.status S
        SET
          order_number = CASE
            WHEN order_number = new_order_number THEN T.old_order_number
            WHEN status_id = {StatusId} THEN T.new_order_number
            ELSE order_number END
        FROM (
          SELECT
            order_number AS old_order_number,
            order_number + 1 AS new_order_number
          FROM
            collect.status
          WHERE
            status_id = {StatusId}) T;
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status2OrderNumberIncreaseSqlQuery">
      <Text>
        SELECT
          collect.status2_order_number_recount()
        FROM
          collect.status2
        WHERE
          status_id = {StatusId} AND
          order_number IS NULL;

        UPDATE
          collect.status2 S
        SET
          order_number = CASE
            WHEN order_number = new_order_number THEN T.old_order_number
            WHEN status_id = {StatusId} THEN T.new_order_number
            ELSE order_number END
        FROM (
          SELECT
            order_number AS old_order_number,
            order_number + 1 AS new_order_number
          FROM
            collect.status2
          WHERE
            status_id = {StatusId}) T;
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status3OrderNumberIncreaseSqlQuery">
      <Text>
        SELECT
          collect.status3_order_number_recount()
        FROM
          collect.status3
        WHERE
          status_id = {StatusId} AND
          order_number IS NULL;

        UPDATE
          collect.status3 S
        SET
          order_number = CASE
            WHEN order_number = new_order_number THEN T.old_order_number
            WHEN status_id = {StatusId} THEN T.new_order_number
            ELSE order_number END
        FROM (
          SELECT
            order_number AS old_order_number,
            order_number + 1 AS new_order_number
          FROM
            collect.status3
          WHERE
            status_id = {StatusId}) T;
      </Text>
    </SqlQuery>

    <SqlQuery Name="StatusOrderNumberDecreaseSqlQuery">
      <Text>
        SELECT
          collect.status_order_number_recount()
        FROM
          collect.status
        WHERE
          status_id = {StatusId} AND
          order_number IS NULL;

        UPDATE
          collect.status S
        SET
          order_number = CASE
            WHEN order_number = new_order_number THEN T.old_order_number
            WHEN status_id = {StatusId} THEN T.new_order_number
            ELSE order_number END
        FROM (
          SELECT
            order_number AS old_order_number,
            order_number - 1 AS new_order_number
          FROM
            collect.status
          WHERE
            status_id = {StatusId}) T;
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status2OrderNumberDecreaseSqlQuery">
      <Text>
        SELECT
          collect.status2_order_number_recount()
        FROM
          collect.status2
        WHERE
          status_id = {StatusId} AND
          order_number IS NULL;

        UPDATE
          collect.status2 S
        SET
          order_number = CASE
            WHEN order_number = new_order_number THEN T.old_order_number
            WHEN status_id = {StatusId} THEN T.new_order_number
            ELSE order_number END
        FROM (
          SELECT
            order_number AS old_order_number,
            order_number - 1 AS new_order_number
          FROM
            collect.status2
          WHERE
            status_id = {StatusId}) T;
      </Text>
    </SqlQuery>

    <SqlQuery Name="Status3OrderNumberDecreaseSqlQuery">
      <Text>
        SELECT
          collect.status3_order_number_recount()
        FROM
          collect.status3
        WHERE
          status_id = {StatusId} AND
          order_number IS NULL;

        UPDATE
          collect.status3 S
        SET
          order_number = CASE
            WHEN order_number = new_order_number THEN T.old_order_number
            WHEN status_id = {StatusId} THEN T.new_order_number
            ELSE order_number END
        FROM (
          SELECT
            order_number AS old_order_number,
            order_number - 1 AS new_order_number
          FROM
            collect.status3
          WHERE
            status_id = {StatusId}) T;
      </Text>
    </SqlQuery>

    <!-- причины закрытия дел для бки -->
    <SqlQuery Name="CloseReasonSelectSqlQuery">
      <Text>
        SELECT
          close_reason_id AS "CloseReasonId",
          title AS "Title"
        FROM
          collect.close_reason
        ORDER BY bki_num ASC;
      </Text>
    </SqlQuery>


    <!--============================================================-->
    <!--===ЦВЕТА====================================================-->
    <!--============================================================-->
    <SqlQuery Name="ColorSelectSqlQuery">
      <Text>
        SELECT
          color_id AS "ColorId",
          title AS "Title",
          html_code AS "HtmlCode",
          archive AS "Archive"
        FROM
          collect.color
        ORDER BY title, color_id ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ColorByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title",
          html_code AS "HtmlCode"
        FROM
          collect.color
        WHERE
          color_id = {ColorId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ColorInsertSqlQuery">
      <Text>
        INSERT INTO collect.color(
          title,
          html_code)
        VALUES(
          {Title},
          {HtmlCode})
        RETURNING color_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ColorUpdateSqlQuery">
      <Text>
        UPDATE
          collect.color
        SET
          title = {Title},
          html_code = {HtmlCode}
        WHERE
          color_id = {ColorId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ColorArchiveSqlQuery">
      <Text>
        UPDATE
          collect.color
        SET
          archive = {Archive}
        WHERE
          color_id = {ColorId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ColorDeleteSqlQuery">
      <Text>
        SELECT collect.color_try_delete({ColorId});
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===ИМПОРТ ДЕЛ ИЗ EXCEL======================================-->
    <!--============================================================-->
    <SqlQuery Name="AddressShortDictionarySelectSqlQuery">
      <Text>
        SELECT
          address_part_name AS "AddressPartName",
          value AS "Value"
        FROM
          collect.address_short_dictionary

        UNION ALL

        SELECT
          'CityType',
          string_agg(alternative_values, ';')
        FROM
          collect.address_city_type

        UNION ALL

        SELECT
          'City',
          string_agg(alternative_values, ';')
        FROM
          collect.address_city_type

        UNION ALL

        SELECT
          'StreetType',
          string_agg(alternative_values, ';')
        FROM
          collect.address_street_type

        UNION ALL

        SELECT
          'Street',
          string_agg(alternative_values, ';')
        FROM
          collect.address_street_type;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AddressDictionarySelectSqlQuery">
      <Text>
        SELECT
          'StreetType' AS "AddressPartName",
          title AS "Value",
          alternative_values AS "AlternativeValues"
        FROM
          collect.address_street_type

        UNION ALL

        SELECT
          'CityType',
          title,
          alternative_values
        FROM
          collect.address_city_type;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempLoanAddressSelectSqlQuery">
      <Text>
        WITH address_index_position AS (
          SELECT
            temp_loan_id,
            COALESCE(position(substring(client_registration_address, '\m\d{6}') in client_registration_address), 0) AS reg_index_position,
            COALESCE(position(substring(client_actual_address, '\m\d{6}') in client_actual_address), 0) AS act_index_position,
            client_registration_address,
            client_actual_address
          FROM
            collect.temp_loan
        ), address_string_formatted AS (
          SELECT
            temp_loan_id,
            CASE
              WHEN reg_index_position > 0
              THEN
                CASE
                  WHEN length(client_registration_address) = reg_index_position + 5
                  THEN client_registration_address
                  ELSE
                    CASE
                      WHEN substr(client_registration_address, reg_index_position + 6, 1) = ','
                      THEN client_registration_address
                      ELSE substr(client_registration_address, 1, reg_index_position + 5) || ',' || substr(client_registration_address, reg_index_position + 6)
                    END
                END
              ELSE client_registration_address
            END AS client_registration_address,
            CASE
              WHEN act_index_position > 0
              THEN
                CASE
                  WHEN length(client_actual_address) = act_index_position + 5
                  THEN client_actual_address
                  ELSE
                    CASE
                      WHEN substr(client_actual_address, act_index_position + 6, 1) = ','
                      THEN client_actual_address
                      ELSE substr(client_actual_address, 1, act_index_position + 5) || ',' || substr(client_actual_address, act_index_position + 6)
                    END
                END
              ELSE client_actual_address
            END AS client_actual_address
          FROM
            address_index_position
        )
        SELECT
          temp_loan_id AS "TempId",
          CASE
            WHEN {AddressType} = 'registration_address' THEN client_registration_address
            WHEN {AddressType} = 'actual_address' THEN client_actual_address
          END AS "AddressString"
        FROM
          address_string_formatted;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempLoanAddressUpdateSqlQuery">
      <Text>
        UPDATE
          collect.temp_loan TL
        SET
          client_registration_address_index = CASE WHEN COALESCE(client_registration_address_index, '') = '' THEN trim(T.index) ELSE client_registration_address_index END,
          client_registration_address_region = CASE WHEN COALESCE(client_registration_address_region, '') = '' THEN trim(T.region) ELSE client_registration_address_region END,
          client_registration_address_district = CASE WHEN COALESCE(client_registration_address_district, '') = '' THEN trim(T.district) ELSE client_registration_address_district END,
          client_registration_address_city = CASE WHEN COALESCE(client_registration_address_city, '') = '' THEN trim(T.city) ELSE client_registration_address_city END,
          client_registration_address_city_type = CASE WHEN COALESCE(client_registration_address_city_type, '') = '' THEN trim(T.city_type) ELSE client_registration_address_city_type END,
          client_registration_address_street = CASE WHEN COALESCE(client_registration_address_street, '') = '' THEN trim(T.street) ELSE client_registration_address_street END,
          client_registration_address_street_type = CASE WHEN COALESCE(client_registration_address_street_type, '') = '' THEN trim(T.street_type) ELSE client_registration_address_street_type END,
          client_registration_address_building = CASE WHEN COALESCE(client_registration_address_building, '') = '' THEN trim(T.house) ELSE client_registration_address_building END,
          client_registration_address_flat = CASE WHEN COALESCE(client_registration_address_flat, '') = '' THEN trim(T.flat) ELSE client_registration_address_flat END,
          client_registration_address_block = CASE WHEN COALESCE(client_registration_address_block, '') = '' THEN trim(T.block) ELSE client_registration_address_block END,
          client_registration_address_structure = CASE WHEN COALESCE(client_registration_address_structure, '') = '' THEN trim(T.structure) ELSE client_registration_address_structure END
        FROM (
          SELECT
            unnest({TempId}::bigint[]) AS temp_loan_id,
            unnest({Index}::character varying[]) AS index,
            unnest({Region}::character varying[]) AS region,
            unnest({District}::character varying[]) AS district,
            unnest({City}::character varying[]) AS city,
            unnest({CityType}::character varying[]) AS city_type,
            unnest({Street}::character varying[]) AS street,
            unnest({StreetType}::character varying[]) AS street_type,
            unnest({House}::character varying[]) AS house,
            unnest({Flat}::character varying[]) AS flat,
            unnest({Block}::character varying[]) AS block,
            unnest({Structure}::character varying[]) AS structure
        ) T
        WHERE
          {AddressType} = 'registration_address' AND
          T.temp_loan_id = TL.temp_loan_id;

        UPDATE
          collect.temp_loan TL
        SET
          client_actual_address_index = CASE WHEN COALESCE(client_actual_address_index, '') = '' THEN trim(T.index) ELSE client_actual_address_index END,
          client_actual_address_region = CASE WHEN COALESCE(client_actual_address_region, '') = '' THEN trim(T.region) ELSE client_actual_address_region END,
          client_actual_address_district = CASE WHEN COALESCE(client_actual_address_district, '') = '' THEN trim(T.district) ELSE client_actual_address_district END,
          client_actual_address_city = CASE WHEN COALESCE(client_actual_address_city, '') = '' THEN trim(T.city) ELSE client_actual_address_city END,
          client_actual_address_city_type = CASE WHEN COALESCE(client_actual_address_city_type, '') = '' THEN trim(T.city_type) ELSE client_actual_address_city_type END,
          client_actual_address_street = CASE WHEN COALESCE(client_actual_address_street, '') = '' THEN trim(T.street) ELSE client_actual_address_street END,
          client_actual_address_street_type = CASE WHEN COALESCE(client_actual_address_street_type, '') = '' THEN trim(T.street_type) ELSE client_actual_address_street_type END,
          client_actual_address_building = CASE WHEN COALESCE(client_actual_address_building, '') = '' THEN trim(T.house) ELSE client_actual_address_building END,
          client_actual_address_flat = CASE WHEN COALESCE(client_actual_address_flat, '') = '' THEN trim(T.flat) ELSE client_actual_address_flat END,
          client_actual_address_block = CASE WHEN COALESCE(client_actual_address_block, '') = '' THEN trim(T.block) ELSE client_actual_address_block END,
          client_actual_address_structure = CASE WHEN COALESCE(client_actual_address_structure, '') = '' THEN trim(T.structure) ELSE client_actual_address_structure END
        FROM (
          SELECT
            unnest({TempId}::bigint[]) AS temp_loan_id,
            unnest({Index}::character varying[]) AS index,
            unnest({Region}::character varying[]) AS region,
            unnest({District}::character varying[]) AS district,
            unnest({City}::character varying[]) AS city,
            unnest({CityType}::character varying[]) AS city_type,
            unnest({Street}::character varying[]) AS street,
            unnest({StreetType}::character varying[]) AS street_type,
            unnest({House}::character varying[]) AS house,
            unnest({Flat}::character varying[]) AS flat,
            unnest({Block}::character varying[]) AS block,
            unnest({Structure}::character varying[]) AS structure
        ) T
        WHERE
          {AddressType} = 'actual_address' AND
          T.temp_loan_id = TL.temp_loan_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ExcelImportColumnListSelectSqlQuery">
      <Text>
        WITH RECURSIVE tree (
          excel_import_column_id,
          excel_import_column_category_id,
          title,
          name,
          description,
          is_mandatory,
          path,
          tmp_order) AS (
            SELECT
              excel_import_column_id,
              excel_import_column_category_id,
              title,
              name,
              description,
              is_mandatory,
              ARRAY[excel_import_column_id]::bigint[] AS path,
              ARRAY[row_number]
            FROM
              T
            WHERE
              excel_import_column_category_id IS NULL

            UNION

            SELECT
              T.excel_import_column_id,
              T.excel_import_column_category_id,
              T.title,
              T.name,
              T.description,
              T.is_mandatory,
              tree.path || T.excel_import_column_id::bigint AS path,
              tree.tmp_order || T.row_number
            FROM
              T
              JOIN tree ON tree.excel_import_column_id = T.excel_import_column_category_id
        ), T AS (
          SELECT
            *,
            ROW_NUMBER() OVER(PARTITION BY excel_import_column_category_id ORDER BY order_number)
          FROM
            collect.excel_import_column
          WHERE
            import_type = {ImportType}::collect.import_type
        ), closed_category AS (
          SELECT
            temp_tree_id AS id,
            item_path AS path
          FROM
            collect.temp_tree
          WHERE
            user_id = {UserId} AND
            form_name = 'ExcelImportColumnList'
        ), tree_final AS (
          SELECT
            closed1.path IS NOT NULL childred_closed,
            closed2.path IS NOT NULL closed,
            (LEAD(tree.path, 1, ARRAY[]::bigint[]) OVER(ORDER BY tree.path))[1:array_length(tree.path, 1)] = tree.path AS has_child,
            closed2.id state_id,
            tree.*
          FROM
            tree
            LEFT JOIN closed_category closed1 ON tree.path[1:array_length(closed1.path, 1)] = closed1.path AND tree.path != closed1.path
            LEFT JOIN closed_category closed2 ON closed2.path = tree.path
        )
        SELECT
          T.excel_import_column_id AS "ExcelImportColumnId",
          T.title IS NOT NULL AS "CanEdit",
          T.closed AS "Closed",
          T.excel_import_column_category_id IS NULL AS "Main",
          CASE WHEN T.excel_import_column_id <![CDATA[<]]> 0 THEN false ELSE T.has_child END AS "HasChildren",
          T.state_id AS "TreeStateId",
          T.path::varchar AS "ItemPath",
          T.title AS "ExcelImportColumnTitle",
          CASE WHEN array_length(T.path, 1) > 1 THEN COALESCE(repeat('  ', (array_length(T.path, 1)-1)*2) || ' ', '') ELSE '' END || description AS "Description",
          CASE WHEN T.has_child AND T.is_mandatory THEN true ELSE false END AS "CategoryMandatory",
          CASE WHEN NOT T.has_child AND T.is_mandatory THEN true ELSE false END AS "ColumnMandatory"
        FROM
          tree_final T
        WHERE
          NOT T.childred_closed
        ORDER BY T.tmp_order;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TxtImportColumnSelectSqlQuery">
      <Text>
        SELECT
          name AS "ColumnName",
          title AS "Title",
          data_type AS "DataType"
        FROM
          collect.txt_import_column;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ExcelImportColumnSelectSqlQuery">
      <Text>
        SELECT
          excel_import_column_id AS "ExcelImportColumnId",
          column_name AS "ColumnName",
          title AS "Title",
          data_type AS "DataType",
          false AS "IsArray",
          need_to_parse AS "NeedToParse",
          name AS "Name",
          auto_parse AS "AutoParse",
          excel_import_delimeter_id AS "ExcelImportDelimeterId",
          result_column_names AS "ResultColumnNames"
        FROM
          collect.excel_import_column
          LEFT JOIN (
            SELECT
              PT.to_parse_excel_import_column_id AS excel_import_column_id,
              array_agg(EIC_R.name ORDER BY PT.order_number) AS result_column_names
            FROM
              collect.excel_import_parse_type PT
              JOIN collect.excel_import_column EIC_R ON EIC_R.excel_import_column_id = result_excel_import_column_id
            GROUP BY PT.to_parse_excel_import_column_id
          ) EIPT USING(excel_import_column_id)
        WHERE
          column_name IS NOT NULL AND
          import_type = {ImportType}::collect.import_type
        ORDER BY excel_import_column_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ExcelImportColumnByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title",
          description AS "Description"
        FROM
          collect.excel_import_column
        WHERE
          excel_import_column_id = {ExcelImportColumnId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ExcelImportColumnUpdateSqlQuery">
      <Text>
        UPDATE
          collect.excel_import_column
        SET
          title = {Title}
        WHERE
          excel_import_column_id = {ExcelImportColumnId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ExcelImportParseTypeSelectSqlQuery">
      <Text>
        SELECT
          EIPT.excel_import_parse_type_id AS "ExcelImportParseTypeId",
          EIPT.to_parse_excel_import_column_id AS "ToParseExcelImportColumnId",
          EIPT.result_excel_import_column_id AS "ResultExcelImportColumnId",
          EIPT.order_number AS "OrderNumber",
          EIPT.is_mandatory AS "IsMandatory",
          EIPT.enabled AS "Enabled"
        FROM
          collect.excel_import_parse_type EIPT
          LEFT JOIN collect.excel_import_column EIC ON EIC.excel_import_column_id = EIPT.to_parse_excel_import_column_id
        WHERE
          EIC.import_type = {ImportType}
        ORDER BY EIPT.to_parse_excel_import_column_id, EIPT.order_number, EIPT.result_excel_import_column_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ExcelImportDelimeterSelectSqlQuery">
      <Text>
        SELECT
          excel_import_delimeter_id AS "ExcelImportDelimeterId",
          '"' || title || '"' AS "FormattedTitle",
          title AS "Title",
          type AS "Type"
        FROM
          collect.excel_import_delimeter
        ORDER BY excel_import_delimeter_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ExcelImportColumnParseUpdateSqlQuery">
      <Text>
        SELECT collect.excel_import_column_parse_update({Model}::json);
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempLoanClearSqlQuery">
      <Text>
        DELETE FROM
          collect.temp_loan;

        ALTER SEQUENCE
          collect.temp_loan_id_seq
        RESTART WITH 1;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempLoanInsertSqlQuery">
      <Text>
        INSERT INTO collect.temp_loan(
          client_title,
          client_first_name,
          client_second_name,
          client_third_name,
          client_gender,
          client_birth_date,
          client_birth_place,
          client_passport,
          client_passport_series,
          client_passport_number,
          client_passport_given_by,
          client_passport_given_date,
          client_passport_code,
          client_inn,
          client_is_special_tax_regime,
          client_snils,
          client_email,
          client_work_company_title,
          client_work_post,
          client_work_salary,
          client_work_hired_date,
          client_work_fired_date,
          client_social_website,
          client_social_link,
          client_phone_number,
          client_phone_type,
          client_phone_contact_person_type,
          client_phone_contact_person,
          client_phone_comment,
          client_phone_is_main,
          client_registration_address,
          client_registration_address_okato,
          client_registration_address_index,
          client_registration_address_region,
          client_registration_address_district,
          client_registration_address_city_type,
          client_registration_address_city,
          client_registration_address_city_district,
          client_registration_address_street_type,
          client_registration_address_street,
          client_registration_address_building,
          client_registration_address_block,
          client_registration_address_structure,
          client_registration_address_flat,
          client_actual_address,
          client_actual_address_okato,
          client_actual_address_index,
          client_actual_address_region,
          client_actual_address_district,
          client_actual_address_city_type,
          client_actual_address_city,
          client_actual_address_city_district,
          client_actual_address_street_type,
          client_actual_address_street,
          client_actual_address_building,
          client_actual_address_block,
          client_actual_address_structure,
          client_actual_address_flat,
          client_property_movable_title,
          client_property_movable_price,
          client_property_movable_share,
          client_property_movable_is_pledged,
          client_property_movable_pledge_date,
          client_property_movable_pledge_price,
          client_property_movable_description,
          client_property_movable_model,
          client_property_movable_year,
          client_property_movable_color,
          client_property_movable_buy_date,
          client_property_movable_number,
          client_property_movable_vin,
          client_property_movable_ban_raise_date,
          client_property_movable_ban_result_date,
          client_property_movable_unban_date,
          client_property_movable_ban_result,
          client_property_movable_arrest_raise_date,
          client_property_movable_arrest_result_date,
          client_property_movable_unarrest_date,
          client_property_movable_arrest_result,
          client_property_movable_wanted_raise_date,
          client_property_movable_wanted_result_date,
          client_property_movable_unwanted_date,
          client_property_movable_wanted_result,
          client_property_movable_sell_date,
          client_property_movable_sell_result,
          client_property_real_title,
          client_property_real_price,
          client_property_real_share,
          client_property_real_is_pledged,
          client_property_real_pledge_date,
          client_property_real_pledge_price,
          client_property_real_description,
          client_property_real_address,
          client_property_real_cadastral_number,
          client_property_real_cadastral_price,
          client_property_real_area,
          client_property_real_ban_raise_date,
          client_property_real_ban_result_date,
          client_property_real_unban_date,
          client_property_real_ban_result,
          client_property_real_arrest_raise_date,
          client_property_real_arrest_result_date,
          client_property_real_unarrest_date,
          client_property_real_arrest_result,
          client_property_real_sell_date,
          client_property_real_sell_result,
          client_property_company_title,
          client_property_company_price,
          client_property_company_share,
          client_property_company_is_pledged,
          client_property_company_pledge_date,
          client_property_company_pledge_price,
          client_property_company_description,
          client_property_company_company_title,
          client_property_company_inn,
          client_property_company_address,
          client_property_company_contact,
          client_property_company_ban_raise_date,
          client_property_company_ban_result_date,
          client_property_company_unban_date,
          client_property_company_ban_result,
          client_account_bank_title,
          client_account_bank_requisite,
          client_account,
          client_account_description,
          client_account_arrest_date,
          client_salary_account_bank_title,
          client_salary_account_bank_requisite,
          client_salary_account,
          client_salary_account_description,
          client_salary_account_arrest_date,
          cession_title,
          cession_type,
          cession_date,
          cession_agreement_number,
          inner_org_title,
          inner_org_short_title,
          inner_org_leader_post,
          inner_org_document,
          inner_org_leader_title,
          inner_org_leader_genitive,
          inner_org_leader_initials,
          inner_org_legal_address,
          inner_org_actual_address,
          inner_org_city,
          inner_org_inn,
          inner_org_kpp,
          inner_org_ogrn,
          inner_org_payment_account,
          inner_org_bank,
          inner_org_bank_city,
          inner_org_correspondent_account,
          inner_org_bik,
          inner_org_phone,
          inner_org_fax,
          inner_org_email,
          inner_org_website,
          inner_org_create_date,
          claimant_title,
          claimant_short_title,
          claimant_branch,
          claimant_representative,
          claimant_representative_post,
          claimant_document,
          claimant_inn,
          claimant_address,
          claimant_title_genitive,
          claimant_branch_genitive,
          claimant_representative_genitive,
          claimant_representative_post_genitive,
          claimant_document_genitive,
          cession_region,
          loan_credit_number,
          loan_credit_date,
          loan_credit_end_date,
          loan_credit_sum,
          loan_credit_rate,
          loan_is_floating_credit_rate,
          loan_credit_type,
          loan_credit_line_type,
          loan_credit_purpose,
          loan_credit_get_type,
          first_claimant_title,
          first_claimant_short_title,
          first_claimant_branch,
          first_claimant_representative,
          first_claimant_representative_post,
          first_claimant_document,
          first_claimant_inn,
          first_claimant_address,
          first_claimant_title_genitive,
          first_claimant_branch_genitive,
          first_claimant_representative_genitive,
          first_claimant_representative_post_genitive,
          first_claimant_document_genitive,
          loan_debt_base,
          loan_debt_percent,
          loan_debt_penalty,
          loan_debt_tax,
          loan_client_role,
          loan_client_is_main,
          loan_client_unique_id,
          loan_client_surety_number,
          loan_client_user,
          loan_client_status,
          loan_client_close_date,
          loan_client_sale_date,
          loan_client_court_sum,
          loan_client_court_date,
          loan_client_debt_base,
          loan_client_debt_percent,
          loan_client_debt_penalty,
          loan_client_debt_tax,
          notification_number,
          notification_date,
          notification_send_date,
          notification_post_number,
          notification_delivery_info,
          notification_is_actual,
          succession_court_title,
          succession_court_title_genitive,
          succession_court_region,
          succession_court_address,
          succession_court_receiver,
          succession_court_receiver_bank,
          succession_court_receiver_bank_city,
          succession_court_inn,
          succession_court_kpp,
          succession_court_correspondent_account,
          succession_court_account,
          succession_court_bik,
          succession_court_oktmo,
          succession_court_kbk,
          succession_court_phone,
          succession_court_email,
          succession_court_site,
          succession_court_document,
          succession_document_number,
          succession_document_date,
          succession_document_is_duplicate,
          succession_duplicate_get_date,
          succession_duplicate_court_date,
          succession_document_info,
          succession_case_number,
          succession_document_sum,
          succession_tax_sum,
          succession_send_date,
          succession_court_date,
          succession_result,
          succession_comment,
          succession_cancel_date,
          succession_appeal_send_date,
          succession_appeal_date,
          succession_appeal_result,
          succession_cassation_send_date,
          succession_cassation_date,
          succession_cassation_result,
          collection_court_document,
          collection_court_document_number,
          collection_court_document_date,
          collection_court_title,
          collection_court_title_genitive,
          collection_court_region,
          collection_court_address,
          collection_court_receiver,
          collection_court_receiver_bank,
          collection_court_receiver_bank_city,
          collection_court_inn,
          collection_court_kpp,
          collection_court_correspondent_account,
          collection_court_account,
          collection_court_bik,
          collection_court_oktmo,
          collection_court_kbk,
          collection_court_phone,
          collection_court_email,
          collection_court_site,
          collection_send_date,
          collection_case_number,
          collection_judge,
          collection_contact_date,
          collection_court_date,
          collection_result_date,
          collection_court_result,
          collection_sum,
          collection_is_main,
          collection_is_recieved,
          collection_legal_date,
          collection_document_get_date,
          collection_cancel_date,
          collection_appeal_send_date,
          collection_appeal_date,
          collection_appeal_result,
          collection_cassation_send_date,
          collection_cassation_date,
          collection_cassation_result,
          collection_application_type_title,
          collection_application_sum,
          collection_application_tax,
          executive_document_info,
          executive_osp_title,
          executive_osp_address,
          executive_osp_ufssp_title,
          executive_osp_phone,
          executive_bailiff_title,
          executive_bailiff_phone,
          executive_send_date,
          executive_start_date,
          executive_number,
          executive_other_info,
          executive_replacement_send_date,
          executive_replacement_date,
          executive_request,
          executive_request_response,
          executive_end_date,
          executive_resend_date,
          executive_end_reason,
          executive_restrict_date,
          executive_restrict_end_date,
          executive_appeal_send_date,
          executive_appeal_date,
          executive_appeal_result,
          client_bankrupt_court_title,
          client_bankrupt_court_title_genitive,
          client_bankrupt_court_region,
          client_bankrupt_court_address,
          client_bankrupt_court_receiver,
          client_bankrupt_court_receiver_bank,
          client_bankrupt_court_receiver_bank_city,
          client_bankrupt_court_inn,
          client_bankrupt_court_kpp,
          client_bankrupt_court_correspondent_account,
          client_bankrupt_court_account,
          client_bankrupt_court_bik,
          client_bankrupt_court_oktmo,
          client_bankrupt_court_kbk,
          client_bankrupt_court_phone,
          client_bankrupt_court_email,
          client_bankrupt_court_site,
          client_bankrupt_case_number,
          client_bankrupt_out_court_bankrupt_end_date,
          client_bankrupt_next_session_date,
          client_bankrupt_recognition_date,
          client_bankrupt_sale_property_date,
          client_bankrupt_work_state_date,
          client_bankrupt_description,
          client_bankrupt_type,
          client_bankrupt_efrsb_number,
          client_bankrupt_efrsb_link,
          client_jurisdiction_court_title,
          client_jurisdiction_court_title_genitive,
          client_jurisdiction_court_region,
          client_jurisdiction_court_address,
          client_jurisdiction_court_receiver,
          client_jurisdiction_court_receiver_bank,
          client_jurisdiction_court_receiver_bank_city,
          client_jurisdiction_court_inn,
          client_jurisdiction_court_kpp,
          client_jurisdiction_court_correspondent_account,
          client_jurisdiction_court_account,
          client_jurisdiction_court_bik,
          client_jurisdiction_court_oktmo,
          client_jurisdiction_court_kbk,
          client_jurisdiction_court_phone,
          client_jurisdiction_court_email,
          client_jurisdiction_court_site,
          client_jurisdiction_osp_title,
          client_jurisdiction_osp_address,
          client_jurisdiction_osp_ufssp_title,
          client_jurisdiction_osp_phone,
          comment_comment,
          interaction_limit_concent_date,
          interaction_limit_agent_concent_date,
          interaction_limit_agent_title,
          interaction_limit_agent_phone,
          interaction_limit_agent_birth_date,
          interaction_limit_agent_address,
          interaction_limit_agent_email,
          interaction_limit_agent_lawyer,
          interaction_limit_reject_date,
          interaction_limit_agent_reject_date,
          interaction_limit_reject_cancel_date,
          interaction_limit_other_agent_date,
          interaction_limit_request,
          interaction_limit_request_response,
          claimant_type,
          first_claimant_type,
          loan_account_number,
          loan_full_price,
          loan_full_price_percent,
          loan_overdue_date,
          loan_client_surety_duty,
          loan_client_surety_sum)
        SELECT
          trim(client_title),
          trim(client_first_name),
          trim(client_second_name),
          trim(client_third_name),
          trim(client_gender),
          client_birth_date,
          trim(client_birth_place),
          trim(client_passport),
          substr(regexp_replace(client_passport_series, '[^0-9]', '', 'g'), 1, 4),
          substr(regexp_replace(client_passport_number, '[^0-9]', '', 'g'), 1, 6),
          trim(client_passport_given_by),
          client_passport_given_date,
          CASE WHEN length(regexp_replace(client_passport_code, '[^0-9]', '', 'g')) > 3
            THEN substr(regexp_replace(client_passport_code, '[^0-9]', '', 'g'), 1, 3) || '-' || substr(regexp_replace(client_passport_code, '[^0-9]', '', 'g'), 4, 3)
            ELSE regexp_replace(client_passport_code, '[^0-9]', '', 'g')
          END,
          substr(regexp_replace(client_inn, '[^0-9]', '', 'g'), 1, 12),
          client_is_special_tax_regime,
          substr(regexp_replace(client_snils, '[^0-9]', '', 'g'), 1, 11),
          trim(client_email),
          trim(client_work_company_title),
          trim(client_work_post),
          ROUND(CASE WHEN client_work_salary >= 0 THEN client_work_salary ELSE null END, 2),
          client_work_hired_date,
          client_work_fired_date,
          trim(client_social_website),
          trim(client_social_link),
          CASE WHEN substr(regexp_replace(client_phone_number, '[^0-9+]', '', 'g'), 1, 1) = '+'
            THEN substr(regexp_replace(client_phone_number, '[^0-9+]', '', 'g'), 1, 12)
            ELSE substr(regexp_replace(client_phone_number, '[^0-9+]', '', 'g'), 1, 11)
          END,
          trim(client_phone_type),
          trim(client_phone_contact_person_type),
          trim(client_phone_contact_person),
          trim(client_phone_comment),
          client_phone_is_main,
          trim(client_registration_address),
          trim(client_registration_address_okato),
          trim(client_registration_address_index),
          trim(client_registration_address_region),
          trim(client_registration_address_district),
          trim(regexp_replace(client_registration_address_city_type, '[^А-Яа-я ]', '', 'g')),
          trim(client_registration_address_city),
          trim(client_registration_address_city_district),
          trim(regexp_replace(client_registration_address_street_type, '[^А-Яа-я ]', '', 'g')),
          trim(client_registration_address_street),
          trim(client_registration_address_building),
          trim(client_registration_address_block),
          trim(client_registration_address_structure),
          trim(client_registration_address_flat),
          trim(client_actual_address),
          trim(client_actual_address_okato),
          trim(client_actual_address_index),
          trim(client_actual_address_region),
          trim(client_actual_address_district),
          trim(regexp_replace(client_actual_address_city_type, '[^А-Яа-я ]', '', 'g')),
          trim(client_actual_address_city),
          trim(client_actual_address_city_district),
          trim(regexp_replace(client_actual_address_street_type, '[^А-Яа-я ]', '', 'g')),
          trim(client_actual_address_street),
          trim(client_actual_address_building),
          trim(client_actual_address_block),
          trim(client_actual_address_structure),
          trim(client_actual_address_flat),
          trim(client_property_movable_title),
          ROUND(CASE WHEN client_property_movable_price >= 0 THEN client_property_movable_price ELSE null END, 2),
          trim(client_property_movable_share),
          client_property_movable_is_pledged,
          client_property_movable_pledge_date,
          ROUND(CASE WHEN client_property_movable_pledge_price >= 0 THEN client_property_movable_pledge_price ELSE null END, 2),
          trim(client_property_movable_description),
          trim(client_property_movable_model),
          substr(regexp_replace(client_property_movable_year, '[^0-9]', '', 'g'), 1, 4),
          trim(client_property_movable_color),
          client_property_movable_buy_date,
          trim(client_property_movable_number),
          trim(client_property_movable_vin),
          client_property_movable_ban_raise_date,
          client_property_movable_ban_result_date,
          client_property_movable_unban_date,
          trim(client_property_movable_ban_result),
          client_property_movable_arrest_raise_date,
          client_property_movable_arrest_result_date,
          client_property_movable_unarrest_date,
          trim(client_property_movable_arrest_result),
          client_property_movable_wanted_raise_date,
          client_property_movable_wanted_result_date,
          client_property_movable_unwanted_date,
          trim(client_property_movable_wanted_result),
          client_property_movable_sell_date,
          trim(regexp_replace(client_property_movable_sell_result, '[^А-Яа-я ]', '', 'g')),
          trim(client_property_real_title),
          ROUND(CASE WHEN client_property_real_price >= 0 THEN client_property_real_price ELSE null END, 2),
          trim(client_property_real_share),
          client_property_real_is_pledged,
          client_property_real_pledge_date,
          ROUND(CASE WHEN client_property_real_pledge_price >= 0 THEN client_property_real_pledge_price ELSE null END, 2),
          trim(client_property_real_description),
          trim(client_property_real_address),
          trim(client_property_real_cadastral_number),
          ROUND(CASE WHEN client_property_real_cadastral_price >= 0 THEN client_property_real_cadastral_price ELSE null END, 2),
          ROUND(CASE WHEN client_property_real_area >= 0 THEN client_property_real_area ELSE null END, 2),
          client_property_real_ban_raise_date,
          client_property_real_ban_result_date,
          client_property_real_unban_date,
          trim(client_property_real_ban_result),
          client_property_real_arrest_raise_date,
          client_property_real_arrest_result_date,
          client_property_real_unarrest_date,
          trim(client_property_real_arrest_result),
          client_property_real_sell_date,
          trim(regexp_replace(client_property_real_sell_result, '[^А-Яа-я ]', '', 'g')),
          trim(client_property_company_title),
          ROUND(CASE WHEN client_property_company_price >= 0 THEN client_property_company_price ELSE null END, 2),
          trim(client_property_company_share),
          client_property_company_is_pledged,
          client_property_company_pledge_date,
          ROUND(CASE WHEN client_property_company_pledge_price >= 0 THEN client_property_company_pledge_price ELSE null END, 2),
          trim(client_property_company_description),
          trim(client_property_company_company_title),
          substr(regexp_replace(client_property_company_inn, '[^0-9]', '', 'g'), 1, 12),
          trim(client_property_company_address),
          trim(client_property_company_contact),
          client_property_company_ban_raise_date,
          client_property_company_ban_result_date,
          client_property_company_unban_date,
          trim(client_property_company_ban_result),
          trim(client_account_bank_title),
          trim(client_account_bank_requisite),
          trim(client_account),
          trim(client_account_description),
          client_account_arrest_date,
          trim(client_salary_account_bank_title),
          trim(client_salary_account_bank_requisite),
          trim(client_salary_account),
          trim(client_salary_account_description),
          client_salary_account_arrest_date,
          trim(cession_title),
          trim(regexp_replace(cession_type, '[^А-Яа-я ]', '', 'g')),
          cession_date,
          trim(cession_agreement_number),
          trim(inner_org_title),
          trim(inner_org_short_title),
          trim(inner_org_leader_post),
          trim(inner_org_document),
          trim(inner_org_leader_title),
          trim(inner_org_leader_genitive),
          trim(inner_org_leader_initials),
          trim(inner_org_legal_address),
          trim(inner_org_actual_address),
          trim(inner_org_city),
          inner_org_create_date,
          substr(regexp_replace(inner_org_inn, '[^0-9]', '', 'g'), 1, 12),
          trim(inner_org_kpp),
          trim(inner_org_ogrn),
          trim(inner_org_payment_account),
          trim(inner_org_bank),
          trim(inner_org_bank_city),
          trim(inner_org_correspondent_account),
          trim(inner_org_bik),
          CASE WHEN substr(regexp_replace(inner_org_phone, '[^0-9+]', '', 'g'), 1, 1) = '+'
            THEN substr(regexp_replace(inner_org_phone, '[^0-9+]', '', 'g'), 1, 12)
            ELSE substr(regexp_replace(inner_org_phone, '[^0-9+]', '', 'g'), 1, 11)
          END,
          trim(inner_org_fax),
          trim(inner_org_email),
          trim(inner_org_website),
          trim(claimant_title),
          trim(claimant_short_title),
          trim(claimant_branch),
          trim(claimant_representative),
          trim(claimant_representative_post),
          trim(claimant_document),
          substr(regexp_replace(claimant_inn, '[^0-9]', '', 'g'), 1, 12),
          trim(claimant_address),
          trim(claimant_title_genitive),
          trim(claimant_branch_genitive),
          trim(claimant_representative_genitive),
          trim(claimant_representative_post_genitive),
          trim(claimant_document_genitive),
          trim(cession_region),
          trim(loan_credit_number),
          loan_credit_date,
          loan_credit_end_date,
          ROUND(CASE WHEN loan_credit_sum >= 0 THEN loan_credit_sum ELSE null END, 2),
          ROUND(CASE WHEN loan_credit_rate >= 0 THEN loan_credit_rate ELSE null END, 2),
          loan_is_floating_credit_rate,
          trim(regexp_replace(loan_credit_type, '[^А-Яа-я \(\)\«\»]', '', 'g')),
          trim(regexp_replace(loan_credit_line_type, '[^А-Яа-я ]', '', 'g')),
          trim(loan_credit_purpose),
          trim(regexp_replace(loan_credit_get_type, '[^А-Яа-я ]', '', 'g')),
          trim(first_claimant_title),
          trim(first_claimant_short_title),
          trim(first_claimant_branch),
          trim(first_claimant_representative),
          trim(first_claimant_representative_post),
          trim(first_claimant_document),
          substr(regexp_replace(first_claimant_inn, '[^0-9]', '', 'g'), 1, 12),
          trim(first_claimant_address),
          trim(first_claimant_title_genitive),
          trim(first_claimant_branch_genitive),
          trim(first_claimant_representative_genitive),
          trim(first_claimant_representative_post_genitive),
          trim(first_claimant_document_genitive),
          ROUND(CASE WHEN loan_debt_base >= 0 THEN loan_debt_base ELSE null END, 2),
          ROUND(CASE WHEN loan_debt_percent >= 0 THEN loan_debt_percent ELSE null END, 2),
          ROUND(CASE WHEN loan_debt_penalty >= 0 THEN loan_debt_penalty ELSE null END, 2),
          ROUND(CASE WHEN loan_debt_tax >= 0 THEN loan_debt_tax ELSE null END, 2),
          trim(regexp_replace(loan_client_role, '[^А-Яа-я ]', '', 'g')),
          loan_client_is_main,
          trim(loan_client_unique_id),
          trim(loan_client_surety_number),
          trim(loan_client_user),
          trim(loan_client_status),
          loan_client_close_date,
          loan_client_sale_date,
          ROUND(CASE WHEN loan_client_court_sum >= 0 THEN loan_client_court_sum ELSE null END, 2),
          loan_client_court_date,
          ROUND(CASE WHEN loan_client_debt_base >= 0 THEN loan_client_debt_base ELSE null END, 2),
          ROUND(CASE WHEN loan_client_debt_percent >= 0 THEN loan_client_debt_percent ELSE null END, 2),
          ROUND(CASE WHEN loan_client_debt_penalty >= 0 THEN loan_client_debt_penalty ELSE null END, 2),
          ROUND(CASE WHEN loan_client_debt_tax >= 0 THEN loan_client_debt_tax ELSE null END, 2),
          trim(notification_number),
          notification_date,
          notification_send_date,
          trim(notification_post_number),
          trim(notification_delivery_info),
          notification_is_actual,
          trim(succession_court_title),
          trim(succession_court_title_genitive),
          trim(succession_court_region),
          trim(succession_court_address),
          trim(succession_court_receiver),
          trim(succession_court_receiver_bank),
          trim(succession_court_receiver_bank_city),
          substr(regexp_replace(succession_court_inn, '[^0-9]', '', 'g'), 1, 12),
          trim(succession_court_kpp),
          trim(succession_court_correspondent_account),
          trim(succession_court_account),
          trim(succession_court_bik),
          trim(succession_court_oktmo),
          trim(succession_court_kbk),
          CASE WHEN substr(regexp_replace(succession_court_phone, '[^0-9+]', '', 'g'), 1, 1) = '+'
            THEN substr(regexp_replace(succession_court_phone, '[^0-9+]', '', 'g'), 1, 12)
            ELSE substr(regexp_replace(succession_court_phone, '[^0-9+]', '', 'g'), 1, 11)
          END,
          trim(succession_court_email),
          trim(succession_court_site),
          trim(regexp_replace(succession_court_document, '[^А-Яа-я ]', '', 'g')),
          trim(succession_document_number),
          succession_document_date,
          succession_document_is_duplicate,
          succession_duplicate_get_date,
          succession_duplicate_court_date,
          trim(succession_document_info),
          trim(succession_case_number),
          ROUND(CASE WHEN succession_document_sum >= 0 THEN succession_document_sum ELSE null END, 2),
          ROUND(CASE WHEN succession_tax_sum >= 0 THEN succession_tax_sum ELSE null END, 2),
          succession_send_date,
          succession_court_date,
          trim(succession_result),
          trim(succession_comment),
          succession_cancel_date,
          succession_appeal_send_date,
          succession_appeal_date,
          trim(succession_appeal_result),
          succession_cassation_send_date,
          succession_cassation_date,
          trim(succession_cassation_result),
          trim(regexp_replace(collection_court_document, '[^А-Яа-я ]', '', 'g')),
          trim(collection_court_document_number),
          collection_court_document_date,
          trim(collection_court_title),
          trim(collection_court_title_genitive),
          trim(collection_court_region),
          trim(collection_court_address),
          trim(collection_court_receiver),
          trim(collection_court_receiver_bank),
          trim(collection_court_receiver_bank_city),
          substr(regexp_replace(collection_court_inn, '[^0-9]', '', 'g'), 1, 12),
          trim(collection_court_kpp),
          trim(collection_court_correspondent_account),
          trim(collection_court_account),
          trim(collection_court_bik),
          trim(collection_court_oktmo),
          trim(collection_court_kbk),
          CASE WHEN substr(regexp_replace(collection_court_phone, '[^0-9+]', '', 'g'), 1, 1) = '+'
            THEN substr(regexp_replace(collection_court_phone, '[^0-9+]', '', 'g'), 1, 12)
            ELSE substr(regexp_replace(collection_court_phone, '[^0-9+]', '', 'g'), 1, 11)
          END,
          trim(collection_court_email),
          trim(collection_court_site),
          collection_send_date,
          trim(collection_case_number),
          trim(collection_judge),
          collection_contact_date,
          collect.convert_date_filter(collection_court_date),
          collection_result_date,
          trim(regexp_replace(collection_court_result, '[^А-Яа-я ]', '', 'g')),
          ROUND(CASE WHEN collection_sum >= 0 THEN collection_sum ELSE null END, 2),
          collection_is_main,
          collection_is_recieved,
          collection_legal_date,
          collection_document_get_date,
          collection_cancel_date,
          collection_appeal_send_date,
          collection_appeal_date,
          trim(collection_appeal_result),
          collection_cassation_send_date,
          collection_cassation_date,
          trim(collection_cassation_result),
          trim(collection_application_type_title),
          ROUND(CASE WHEN collection_application_sum >= 0 THEN collection_application_sum ELSE null END, 2),
          ROUND(CASE WHEN collection_application_tax >= 0 THEN collection_application_tax ELSE null END, 2),
          trim(executive_document_info),
          trim(executive_osp_title),
          trim(executive_osp_address),
          trim(executive_osp_ufssp_title),
          CASE WHEN substr(regexp_replace(executive_osp_phone, '[^0-9+]', '', 'g'), 1, 1) = '+'
            THEN substr(regexp_replace(executive_osp_phone, '[^0-9+]', '', 'g'), 1, 12)
            ELSE substr(regexp_replace(executive_osp_phone, '[^0-9+]', '', 'g'), 1, 11)
          END,
          trim(executive_bailiff_title),
          trim(executive_bailiff_phone),
          executive_send_date,
          executive_start_date,
          trim(executive_number),
          trim(executive_other_info),
          executive_replacement_send_date,
          executive_replacement_date,
          trim(executive_request),
          trim(executive_request_response),
          executive_end_date,
          executive_resend_date,
          trim(executive_end_reason),
          executive_restrict_date,
          executive_restrict_end_date,
          executive_appeal_send_date,
          executive_appeal_date,
          trim(executive_appeal_result),
          trim(client_bankrupt_court_title),
          trim(client_bankrupt_court_title_genitive),
          trim(client_bankrupt_court_region),
          trim(client_bankrupt_court_address),
          trim(client_bankrupt_court_receiver),
          trim(client_bankrupt_court_receiver_bank),
          trim(client_bankrupt_court_receiver_bank_city),
          substr(regexp_replace(client_bankrupt_court_inn, '[^0-9]', '', 'g'), 1, 12),
          trim(client_bankrupt_court_kpp),
          trim(client_bankrupt_court_correspondent_account),
          trim(client_bankrupt_court_account),
          trim(client_bankrupt_court_bik),
          trim(client_bankrupt_court_oktmo),
          trim(client_bankrupt_court_kbk),
          CASE WHEN substr(regexp_replace(client_bankrupt_court_phone, '[^0-9+]', '', 'g'), 1, 1) = '+'
            THEN substr(regexp_replace(client_bankrupt_court_phone, '[^0-9+]', '', 'g'), 1, 12)
            ELSE substr(regexp_replace(client_bankrupt_court_phone, '[^0-9+]', '', 'g'), 1, 11)
          END,
          trim(client_bankrupt_court_email),
          trim(client_bankrupt_court_site),
          trim(client_bankrupt_case_number),
          client_bankrupt_out_court_bankrupt_end_date,
          client_bankrupt_next_session_date,
          client_bankrupt_recognition_date,
          client_bankrupt_sale_property_date,
          client_bankrupt_work_state_date,
          trim(client_bankrupt_description),
		  trim(client_bankrupt_type),
          trim(client_bankrupt_efrsb_number),
          trim(client_bankrupt_efrsb_link),
          trim(client_jurisdiction_court_title),
          trim(client_jurisdiction_court_title_genitive),
          trim(client_jurisdiction_court_region),
          trim(client_jurisdiction_court_address),
          trim(client_jurisdiction_court_receiver),
          trim(client_jurisdiction_court_receiver_bank),
          trim(client_jurisdiction_court_receiver_bank_city),
          substr(regexp_replace(client_jurisdiction_court_inn, '[^0-9]', '', 'g'), 1, 12),
          trim(client_jurisdiction_court_kpp),
          trim(client_jurisdiction_court_correspondent_account),
          trim(client_jurisdiction_court_account),
          trim(client_jurisdiction_court_bik),
          trim(client_jurisdiction_court_oktmo),
          trim(client_jurisdiction_court_kbk),
          CASE WHEN substr(regexp_replace(client_jurisdiction_court_phone, '[^0-9+]', '', 'g'), 1, 1) = '+'
            THEN substr(regexp_replace(client_jurisdiction_court_phone, '[^0-9+]', '', 'g'), 1, 12)
            ELSE substr(regexp_replace(client_jurisdiction_court_phone, '[^0-9+]', '', 'g'), 1, 11)
          END,
          trim(client_jurisdiction_court_email),
          trim(client_jurisdiction_court_site),
          trim(client_jurisdiction_osp_title),
          trim(client_jurisdiction_osp_address),
          trim(client_jurisdiction_osp_ufssp_title),
          CASE WHEN substr(regexp_replace(client_jurisdiction_osp_phone, '[^0-9+]', '', 'g'), 1, 1) = '+'
            THEN substr(regexp_replace(client_jurisdiction_osp_phone, '[^0-9+]', '', 'g'), 1, 12)
            ELSE substr(regexp_replace(client_jurisdiction_osp_phone, '[^0-9+]', '', 'g'), 1, 11)
          END,
          trim(comment_comment),
          interaction_limit_concent_date,
          interaction_limit_agent_concent_date,
          trim(interaction_limit_agent_title),
          CASE WHEN substr(regexp_replace(interaction_limit_agent_phone, '[^0-9+]', '', 'g'), 1, 1) = '+'
            THEN substr(regexp_replace(interaction_limit_agent_phone, '[^0-9+]', '', 'g'), 1, 12)
            ELSE substr(regexp_replace(interaction_limit_agent_phone, '[^0-9+]', '', 'g'), 1, 11)
          END,
          interaction_limit_agent_birth_date,
          trim(interaction_limit_agent_address),
          trim(interaction_limit_agent_email),
          trim(interaction_limit_agent_lawyer),
          interaction_limit_reject_date,
          interaction_limit_agent_reject_date,
          interaction_limit_reject_cancel_date,
          interaction_limit_other_agent_date,
          trim(interaction_limit_request),
          trim(interaction_limit_request_response),
          trim(claimant_type),
          trim(first_claimant_type),
          trim(loan_account_number),
          ROUND(CASE WHEN loan_full_price >= 0 THEN loan_full_price ELSE null END, 2),
          ROUND(CASE WHEN loan_full_price_percent >= 0 THEN loan_full_price_percent ELSE null END, 3),
          loan_overdue_date,
          trim(loan_client_surety_duty),
          ROUND(CASE WHEN loan_client_surety_sum >= 0 THEN loan_client_surety_sum ELSE null END, 2)
        FROM (
          SELECT
            unnest({ClientTitle}::character varying[]) AS client_title,
            unnest({ClientFirstName}::character varying[]) AS client_first_name,
            unnest({ClientSecondName}::character varying[]) AS client_second_name,
            unnest({ClientThirdName}::character varying[]) AS client_third_name,
            unnest({ClientGender}::character varying[]) AS client_gender,
            unnest({ClientBirthDate}::date[]) AS client_birth_date,
            unnest({ClientBirthPlace}::character varying[]) AS client_birth_place,
            unnest({ClientPassport}::character varying[]) AS client_passport,
            unnest({ClientPassportSeries}::character varying[]) AS client_passport_series,
            unnest({ClientPassportNumber}::character varying[]) AS client_passport_number,
            unnest({ClientPassportGivenBy}::character varying[]) AS client_passport_given_by,
            unnest({ClientPassportGivenDate}::date[]) AS client_passport_given_date,
            unnest({ClientPassportCode}::character varying[]) AS client_passport_code,
            unnest({ClientInn}::character varying[]) AS client_inn,
            unnest({ClientIsSpecialTaxRegime}::boolean[]) AS client_is_special_tax_regime,
            unnest({ClientSnils}::character varying[]) AS client_snils,
            unnest({ClientEmail}::character varying[]) AS client_email,
            unnest({ClientWorkCompanyTitle}::character varying[]) AS client_work_company_title,
            unnest({ClientWorkPost}::character varying[]) AS client_work_post,
            unnest({ClientWorkSalary}::numeric[]) AS client_work_salary,
            unnest({ClientWorkHiredDate}::date[]) AS client_work_hired_date,
            unnest({ClientWorkFiredDate}::date[]) AS client_work_fired_date,
            unnest({ClientSocialWebsite}::character varying[]) AS client_social_website,
            unnest({ClientSocialLink}::character varying[]) AS client_social_link,
            unnest({ClientPhoneNumber}::character varying[]) AS client_phone_number,
            unnest({ClientPhoneType}::character varying[]) AS client_phone_type,
            unnest({ClientPhoneContactPersonType}::character varying[]) AS client_phone_contact_person_type,
            unnest({ClientPhoneContactPerson}::character varying[]) AS client_phone_contact_person,
            unnest({ClientPhoneComment}::character varying[]) AS client_phone_comment,
            unnest({ClientPhoneIsMain}::boolean[]) AS client_phone_is_main,
            unnest({ClientRegistrationAddress}::character varying[]) AS client_registration_address,
            unnest({ClientRegistrationAddressOkato}::character varying[]) AS client_registration_address_okato,
            unnest({ClientRegistrationAddressIndex}::character varying[]) AS client_registration_address_index,
            unnest({ClientRegistrationAddressRegion}::character varying[]) AS client_registration_address_region,
            unnest({ClientRegistrationAddressDistrict}::character varying[]) AS client_registration_address_district,
            unnest({ClientRegistrationAddressCityType}::character varying[]) AS client_registration_address_city_type,
            unnest({ClientRegistrationAddressCity}::character varying[]) AS client_registration_address_city,
            unnest({ClientRegistrationAddressCityDistrict}::character varying[]) AS client_registration_address_city_district,
            unnest({ClientRegistrationAddressStreetType}::character varying[]) AS client_registration_address_street_type,
            unnest({ClientRegistrationAddressStreet}::character varying[]) AS client_registration_address_street,
            unnest({ClientRegistrationAddressBuilding}::character varying[]) AS client_registration_address_building,
            unnest({ClientRegistrationAddressBlock}::character varying[]) AS client_registration_address_block,
            unnest({ClientRegistrationAddressStructure}::character varying[]) AS client_registration_address_structure,
            unnest({ClientRegistrationAddressFlat}::character varying[]) AS client_registration_address_flat,
            unnest({ClientActualAddress}::character varying[]) AS client_actual_address,
            unnest({ClientActualAddressOkato}::character varying[]) AS client_actual_address_okato,
            unnest({ClientActualAddressIndex}::character varying[]) AS client_actual_address_index,
            unnest({ClientActualAddressRegion}::character varying[]) AS client_actual_address_region,
            unnest({ClientActualAddressDistrict}::character varying[]) AS client_actual_address_district,
            unnest({ClientActualAddressCityType}::character varying[]) AS client_actual_address_city_type,
            unnest({ClientActualAddressCity}::character varying[]) AS client_actual_address_city,
            unnest({ClientActualAddressCityDistrict}::character varying[]) AS client_actual_address_city_district,
            unnest({ClientActualAddressStreetType}::character varying[]) AS client_actual_address_street_type,
            unnest({ClientActualAddressStreet}::character varying[]) AS client_actual_address_street,
            unnest({ClientActualAddressBuilding}::character varying[]) AS client_actual_address_building,
            unnest({ClientActualAddressBlock}::character varying[]) AS client_actual_address_block,
            unnest({ClientActualAddressStructure}::character varying[]) AS client_actual_address_structure,
            unnest({ClientActualAddressFlat}::character varying[]) AS client_actual_address_flat,
            unnest({ClientPropertyMovableTitle}::character varying[]) AS client_property_movable_title,
            unnest({ClientPropertyMovablePrice}::numeric[]) AS client_property_movable_price,
            unnest({ClientPropertyMovableShare}::character varying[]) AS client_property_movable_share,
            unnest({ClientPropertyMovableIsPledged}::boolean[]) AS client_property_movable_is_pledged,
            unnest({ClientPropertyMovablePledgeDate}::date[]) AS client_property_movable_pledge_date,
            unnest({ClientPropertyMovablePledgePrice}::numeric[]) AS client_property_movable_pledge_price,
            unnest({ClientPropertyMovableDescription}::character varying[]) AS client_property_movable_description,
            unnest({ClientPropertyMovableModel}::character varying[]) AS client_property_movable_model,
            unnest({ClientPropertyMovableYear}::character varying[]) AS client_property_movable_year,
            unnest({ClientPropertyMovableColor}::character varying[]) AS client_property_movable_color,
            unnest({ClientPropertyMovableBuyDate}::date[]) AS client_property_movable_buy_date,
            unnest({ClientPropertyMovableNumber}::character varying[]) AS client_property_movable_number,
            unnest({ClientPropertyMovableVin}::character varying[]) AS client_property_movable_vin,
            unnest({ClientPropertyMovableBanRaiseDate}::date[]) AS client_property_movable_ban_raise_date,
            unnest({ClientPropertyMovableBanResultDate}::date[]) AS client_property_movable_ban_result_date,
            unnest({ClientPropertyMovableUnBanDate}::date[]) AS client_property_movable_unban_date,
            unnest({ClientPropertyMovableBanResult}::character varying[]) AS client_property_movable_ban_result,
            unnest({ClientPropertyMovableArrestRaiseDate}::date[]) AS client_property_movable_arrest_raise_date,
            unnest({ClientPropertyMovableArrestResultDate}::date[]) AS client_property_movable_arrest_result_date,
            unnest({ClientPropertyMovableUnArrestDate}::date[]) AS client_property_movable_unarrest_date,
            unnest({ClientPropertyMovableArrestResult}::character varying[]) AS client_property_movable_arrest_result,
            unnest({ClientPropertyMovableWantedRaiseDate}::date[]) AS client_property_movable_wanted_raise_date,
            unnest({ClientPropertyMovableWantedResultDate}::date[]) AS client_property_movable_wanted_result_date,
            unnest({ClientPropertyMovableUnWantedDate}::date[]) AS client_property_movable_unwanted_date,
            unnest({ClientPropertyMovableWantedResult}::character varying[]) AS client_property_movable_wanted_result,
            unnest({ClientPropertyMovableSellDate}::date[]) AS client_property_movable_sell_date,
            unnest({ClientPropertyMovableSellResult}::character varying[]) AS client_property_movable_sell_result,
            unnest({ClientPropertyRealTitle}::character varying[]) AS client_property_real_title,
            unnest({ClientPropertyRealPrice}::numeric[]) AS client_property_real_price,
            unnest({ClientPropertyRealShare}::character varying[]) AS client_property_real_share,
            unnest({ClientPropertyRealIsPledged}::boolean[]) AS client_property_real_is_pledged,
            unnest({ClientPropertyRealPledgeDate}::date[]) AS client_property_real_pledge_date,
            unnest({ClientPropertyRealPledgePrice}::numeric[]) AS client_property_real_pledge_price,
            unnest({ClientPropertyRealDescription}::character varying[]) AS client_property_real_description,
            unnest({ClientPropertyRealAddress}::character varying[]) AS client_property_real_address,
            unnest({ClientPropertyRealCadastralNumber}::character varying[]) AS client_property_real_cadastral_number,
            unnest({ClientPropertyRealCadastralPrice}::numeric[]) AS client_property_real_cadastral_price,
            unnest({ClientPropertyRealArea}::numeric[]) AS client_property_real_area,
            unnest({ClientPropertyRealBanRaiseDate}::date[]) AS client_property_real_ban_raise_date,
            unnest({ClientPropertyRealBanResultDate}::date[]) AS client_property_real_ban_result_date,
            unnest({ClientPropertyRealUnBanDate}::date[]) AS client_property_real_unban_date,
            unnest({ClientPropertyRealBanResult}::character varying[]) AS client_property_real_ban_result,
            unnest({ClientPropertyRealArrestRaiseDate}::date[]) AS client_property_real_arrest_raise_date,
            unnest({ClientPropertyRealArrestResultDate}::date[]) AS client_property_real_arrest_result_date,
            unnest({ClientPropertyRealUnArrestDate}::date[]) AS client_property_real_unarrest_date,
            unnest({ClientPropertyRealArrestResult}::character varying[]) AS client_property_real_arrest_result,
            unnest({ClientPropertyRealSellDate}::date[]) AS client_property_real_sell_date,
            unnest({ClientPropertyRealSellResult}::character varying[]) AS client_property_real_sell_result,
            unnest({ClientPropertyCompanyTitle}::character varying[]) AS client_property_company_title,
            unnest({ClientPropertyCompanyPrice}::numeric[]) AS client_property_company_price,
            unnest({ClientPropertyCompanyShare}::character varying[]) AS client_property_company_share,
            unnest({ClientPropertyCompanyIsPledged}::boolean[]) AS client_property_company_is_pledged,
            unnest({ClientPropertyCompanyPledgeDate}::date[]) AS client_property_company_pledge_date,
            unnest({ClientPropertyCompanyPledgePrice}::numeric[]) AS client_property_company_pledge_price,
            unnest({ClientPropertyCompanyDescription}::character varying[]) AS client_property_company_description,
            unnest({ClientPropertyCompanyCompanyTitle}::character varying[]) AS client_property_company_company_title,
            unnest({ClientPropertyCompanyInn}::character varying[]) AS client_property_company_inn,
            unnest({ClientPropertyCompanyAddress}::character varying[]) AS client_property_company_address,
            unnest({ClientPropertyCompanyContact}::character varying[]) AS client_property_company_contact,
            unnest({ClientPropertyCompanyBanRaiseDate}::date[]) AS client_property_company_ban_raise_date,
            unnest({ClientPropertyCompanyBanResultDate}::date[]) AS client_property_company_ban_result_date,
            unnest({ClientPropertyCompanyUnBanDate}::date[]) AS client_property_company_unban_date,
            unnest({ClientPropertyCompanyBanResult}::character varying[]) AS client_property_company_ban_result,
            unnest({ClientAccountBankTitle}::character varying[]) AS client_account_bank_title,
            unnest({ClientAccountBankRequisite}::character varying[]) AS client_account_bank_requisite,
            unnest({ClientAccount}::character varying[]) AS client_account,
            unnest({ClientAccountDescription}::character varying[]) AS client_account_description,
            unnest({ClientAccountArrestDate}::date[]) AS client_account_arrest_date,
            unnest({ClientSalaryAccountBankTitle}::character varying[]) AS client_salary_account_bank_title,
            unnest({ClientSalaryAccountBankRequisite}::character varying[]) AS client_salary_account_bank_requisite,
            unnest({ClientSalaryAccount}::character varying[]) AS client_salary_account,
            unnest({ClientSalaryAccountDescription}::character varying[]) AS client_salary_account_description,
            unnest({ClientSalaryAccountArrestDate}::date[]) AS client_salary_account_arrest_date,
            unnest({CessionTitle}::character varying[]) AS cession_title,
            unnest({CessionType}::character varying[]) AS cession_type,
            unnest({CessionDate}::date[]) AS cession_date,
            unnest({CessionAgreementNumber}::character varying[]) AS cession_agreement_number,
            unnest({InnerOrgTitle}::character varying[]) AS inner_org_title,
            unnest({InnerOrgShortTitle}::character varying[]) AS inner_org_short_title,
            unnest({InnerOrgLeaderPost}::character varying[]) AS inner_org_leader_post,
            unnest({InnerOrgDocument}::character varying[]) AS inner_org_document,
            unnest({InnerOrgLeaderTitle}::character varying[]) AS inner_org_leader_title,
            unnest({InnerOrgLeaderGenitive}::character varying[]) AS inner_org_leader_genitive,
            unnest({InnerOrgLeaderInitials}::character varying[]) AS inner_org_leader_initials,
            unnest({InnerOrgLegalAddress}::character varying[]) AS inner_org_legal_address,
            unnest({InnerOrgActualAddress}::character varying[]) AS inner_org_actual_address,
            unnest({InnerOrgCity}::character varying[]) AS inner_org_city,
            unnest({InnerOrgCreateDate}::date[]) AS inner_org_create_date,
            unnest({InnerOrgInn}::character varying[]) AS inner_org_inn,
            unnest({InnerOrgKpp}::character varying[]) AS inner_org_kpp,
            unnest({InnerOrgOgrn}::character varying[]) AS inner_org_ogrn,
            unnest({InnerOrgPaymentAccount}::character varying[]) AS inner_org_payment_account,
            unnest({InnerOrgBank}::character varying[]) AS inner_org_bank,
            unnest({InnerOrgBankCity}::character varying[]) AS inner_org_bank_city,
            unnest({InnerOrgCorrespondentAccount}::character varying[]) AS inner_org_correspondent_account,
            unnest({InnerOrgBIK}::character varying[]) AS inner_org_bik,
            unnest({InnerOrgPhone}::character varying[]) AS inner_org_phone,
            unnest({InnerOrgFax}::character varying[]) AS inner_org_fax,
            unnest({InnerOrgEmail}::character varying[]) AS inner_org_email,
            unnest({InnerOrgWebsite}::character varying[]) AS inner_org_website,
            unnest({ClaimantTitle}::character varying[]) AS claimant_title,
            unnest({ClaimantShortTitle}::character varying[]) AS claimant_short_title,
            unnest({ClaimantBranch}::character varying[]) AS claimant_branch,
            unnest({ClaimantRepresentative}::character varying[]) AS claimant_representative,
            unnest({ClaimantRepresentativePost}::character varying[]) AS claimant_representative_post,
            unnest({ClaimantDocument}::character varying[]) AS claimant_document,
            unnest({ClaimantInn}::character varying[]) AS claimant_inn,
            unnest({ClaimantAddress}::character varying[]) AS claimant_address,
            unnest({ClaimantTitleGenitive}::character varying[]) AS claimant_title_genitive,
            unnest({ClaimantBranchGenitive}::character varying[]) AS claimant_branch_genitive,
            unnest({ClaimantRepresentativeGenitive}::character varying[]) AS claimant_representative_genitive,
            unnest({ClaimantRepresentativePostGenitive}::character varying[]) AS claimant_representative_post_genitive,
            unnest({ClaimantDocumentGenitive}::character varying[]) AS claimant_document_genitive,
            unnest({CessionRegion}::character varying[]) AS cession_region,
            unnest({LoanCreditNumber}::character varying[]) AS loan_credit_number,
            unnest({LoanCreditDate}::date[]) AS loan_credit_date,
            unnest({LoanCreditEndDate}::date[]) AS loan_credit_end_date,
            unnest({LoanCreditSum}::numeric[]) AS loan_credit_sum,
            unnest({LoanCreditRate}::numeric[]) AS loan_credit_rate,
            unnest({LoanIsFloatingCreditRate}::boolean[]) AS loan_is_floating_credit_rate,
            unnest({LoanCreditType}::character varying[]) AS loan_credit_type,
            unnest({LoanCreditLineType}::character varying[]) AS loan_credit_line_type,
            unnest({LoanCreditPurpose}::character varying[]) AS loan_credit_purpose,
            unnest({LoanCreditGetType}::character varying[]) AS loan_credit_get_type,
            unnest({FirstClaimantTitle}::character varying[]) AS first_claimant_title,
            unnest({FirstClaimantShortTitle}::character varying[]) AS first_claimant_short_title,
            unnest({FirstClaimantBranch}::character varying[]) AS first_claimant_branch,
            unnest({FirstClaimantRepresentative}::character varying[]) AS first_claimant_representative,
            unnest({FirstClaimantRepresentativePost}::character varying[]) AS first_claimant_representative_post,
            unnest({FirstClaimantDocument}::character varying[]) AS first_claimant_document,
            unnest({FirstClaimantInn}::character varying[]) AS first_claimant_inn,
            unnest({FirstClaimantAddress}::character varying[]) AS first_claimant_address,
            unnest({FirstClaimantTitleGenitive}::character varying[]) AS first_claimant_title_genitive,
            unnest({FirstClaimantBranchGenitive}::character varying[]) AS first_claimant_branch_genitive,
            unnest({FirstClaimantRepresentativeGenitive}::character varying[]) AS first_claimant_representative_genitive,
            unnest({FirstClaimantRepresentativePostGenitive}::character varying[]) AS first_claimant_representative_post_genitive,
            unnest({FirstClaimantDocumentGenitive}::character varying[]) AS first_claimant_document_genitive,
            unnest({LoanDebtBase}::numeric[]) AS loan_debt_base,
            unnest({LoanDebtPercent}::numeric[]) AS loan_debt_percent,
            unnest({LoanDebtPenalty}::numeric[]) AS loan_debt_penalty,
            unnest({LoanDebtTax}::numeric[]) AS loan_debt_tax,
            unnest({LoanClientRole}::character varying[]) AS loan_client_role,
            unnest({LoanClientIsMain}::boolean[]) AS loan_client_is_main,
            unnest({LoanClientUniqueId}::character varying[]) AS loan_client_unique_id,
            unnest({LoanClientSuretyNumber}::character varying[]) AS loan_client_surety_number,
            unnest({LoanClientUser}::character varying[]) AS loan_client_user,
            unnest({LoanClientStatus}::character varying[]) AS loan_client_status,
            unnest({LoanClientCloseDate}::date[]) AS loan_client_close_date,
            unnest({LoanClientSaleDate}::date[]) AS loan_client_sale_date,
            unnest({LoanClientCourtSum}::numeric[]) AS loan_client_court_sum,
            unnest({LoanClientCourtDate}::date[]) AS loan_client_court_date,
            unnest({LoanClientDebtBase}::numeric[]) AS loan_client_debt_base,
            unnest({LoanClientDebtPercent}::numeric[]) AS loan_client_debt_percent,
            unnest({LoanClientDebtPenalty}::numeric[]) AS loan_client_debt_penalty,
            unnest({LoanClientDebtTax}::numeric[]) AS loan_client_debt_tax,
            unnest({NotificationNumber}::character varying[]) AS notification_number,
            unnest({NotificationDate}::date[]) AS notification_date,
            unnest({NotificationSendDate}::date[]) AS notification_send_date,
            unnest({NotificationPostNumber}::character varying[]) AS notification_post_number,
            unnest({NotificationDeliveryInfo}::character varying[]) AS notification_delivery_info,
            unnest({NotificationIsActual}::boolean[]) AS notification_is_actual,
            unnest({SuccessionCourtTitle}::character varying[]) AS succession_court_title,
            unnest({SuccessionCourtTitleGenitive}::character varying[]) AS succession_court_title_genitive,
            unnest({SuccessionCourtRegion}::character varying[]) AS succession_court_region,
            unnest({SuccessionCourtAddress}::character varying[]) AS succession_court_address,
            unnest({SuccessionCourtReceiver}::character varying[]) AS succession_court_receiver,
            unnest({SuccessionCourtReceiverBank}::character varying[]) AS succession_court_receiver_bank,
            unnest({SuccessionCourtReceiverBankCity}::character varying[]) AS succession_court_receiver_bank_city,
            unnest({SuccessionCourtInn}::character varying[]) AS succession_court_inn,
            unnest({SuccessionCourtKpp}::character varying[]) AS succession_court_kpp,
            unnest({SuccessionCourtCorrespondentAccount}::character varying[]) AS succession_court_correspondent_account,
            unnest({SuccessionCourtAccount}::character varying[]) AS succession_court_account,
            unnest({SuccessionCourtBik}::character varying[]) AS succession_court_bik,
            unnest({SuccessionCourtOktmo}::character varying[]) AS succession_court_oktmo,
            unnest({SuccessionCourtKbk}::character varying[]) AS succession_court_kbk,
            unnest({SuccessionCourtPhone}::character varying[]) AS succession_court_phone,
            unnest({SuccessionCourtEmail}::character varying[]) AS succession_court_email,
            unnest({SuccessionCourtSite}::character varying[]) AS succession_court_site,
            unnest({SuccessionCourtDocument}::character varying[]) AS succession_court_document,
            unnest({SuccessionDocumentNumber}::character varying[]) AS succession_document_number,
            unnest({SuccessionDocumentDate}::date[]) AS succession_document_date,
            unnest({SuccessionDocumentIsDuplicate}::boolean[]) AS succession_document_is_duplicate,
            unnest({SuccessionDuplicateGetDate}::date[]) AS succession_duplicate_get_date,
            unnest({SuccessionDuplicateCourtDate}::date[]) AS succession_duplicate_court_date,
            unnest({SuccessionDocumentInfo}::character varying[]) AS succession_document_info,
            unnest({SuccessionCaseNumber}::character varying[]) AS succession_case_number,
            unnest({SuccessionDocumentSum}::numeric[]) AS succession_document_sum,
            unnest({SuccessionTaxSum}::numeric[]) AS succession_tax_sum,
            unnest({SuccessionSendDate}::date[]) AS succession_send_date,
            unnest({SuccessionCourtDate}::date[]) AS succession_court_date,
            unnest({SuccessionResult}::character varying[]) AS succession_result,
            unnest({SuccessionComment}::character varying[]) AS succession_comment,
            unnest({SuccessionCancelDate}::date[]) AS succession_cancel_date,
            unnest({SuccessionAppealSendDate}::date[]) AS succession_appeal_send_date,
            unnest({SuccessionAppealDate}::date[]) AS succession_appeal_date,
            unnest({SuccessionAppealResult}::character varying[]) AS succession_appeal_result,
            unnest({SuccessionCassationSendDate}::date[]) AS succession_cassation_send_date,
            unnest({SuccessionCassationDate}::date[]) AS succession_cassation_date,
            unnest({SuccessionCassationResult}::character varying[]) AS succession_cassation_result,
            unnest({CollectionCourtDocument}::character varying[]) AS collection_court_document,
            unnest({CollectionCourtDocumentNumber}::character varying[]) AS collection_court_document_number,
            unnest({CollectionCourtDocumentDate}::date[]) AS collection_court_document_date,
            unnest({CollectionCourtTitle}::character varying[]) AS collection_court_title,
            unnest({CollectionCourtTitleGenitive}::character varying[]) AS collection_court_title_genitive,
            unnest({CollectionCourtRegion}::character varying[]) AS collection_court_region,
            unnest({CollectionCourtAddress}::character varying[]) AS collection_court_address,
            unnest({CollectionCourtReceiver}::character varying[]) AS collection_court_receiver,
            unnest({CollectionCourtReceiverBank}::character varying[]) AS collection_court_receiver_bank,
            unnest({CollectionCourtReceiverBankCity}::character varying[]) AS collection_court_receiver_bank_city,
            unnest({CollectionCourtInn}::character varying[]) AS collection_court_inn,
            unnest({CollectionCourtKpp}::character varying[]) AS collection_court_kpp,
            unnest({CollectionCourtCorrespondentAccount}::character varying[]) AS collection_court_correspondent_account,
            unnest({CollectionCourtAccount}::character varying[]) AS collection_court_account,
            unnest({CollectionCourtBik}::character varying[]) AS collection_court_bik,
            unnest({CollectionCourtOktmo}::character varying[]) AS collection_court_oktmo,
            unnest({CollectionCourtKbk}::character varying[]) AS collection_court_kbk,
            unnest({CollectionCourtPhone}::character varying[]) AS collection_court_phone,
            unnest({CollectionCourtEmail}::character varying[]) AS collection_court_email,
            unnest({CollectionCourtSite}::character varying[]) AS collection_court_site,
            unnest({CollectionSendDate}::date[]) AS collection_send_date,
            unnest({CollectionCaseNumber}::character varying[]) AS collection_case_number,
            unnest({CollectionJudge}::character varying[]) AS collection_judge,
            unnest({CollectionContactDate}::date[]) AS collection_contact_date,
            unnest({CollectionCourtDate}::timestamp[]) AS collection_court_date,
            unnest({CollectionResultDate}::date[]) AS collection_result_date,
            unnest({CollectionCourtResult}::character varying[]) AS collection_court_result,
            unnest({CollectionSum}::numeric[]) AS collection_sum,
            unnest({CollectionIsMain}::boolean[]) AS collection_is_main,
            unnest({CollectionIsRecieved}::boolean[]) AS collection_is_recieved,
            unnest({CollectionLegalDate}::date[]) AS collection_legal_date,
            unnest({CollectionDocumentGetDate}::date[]) AS collection_document_get_date,
            unnest({CollectionCancelDate}::date[]) AS collection_cancel_date,
            unnest({CollectionAppealSendDate}::date[]) AS collection_appeal_send_date,
            unnest({CollectionAppealDate}::date[]) AS collection_appeal_date,
            unnest({CollectionAppealResult}::character varying[]) AS collection_appeal_result,
            unnest({CollectionCassationSendDate}::date[]) AS collection_cassation_send_date,
            unnest({CollectionCassationDate}::date[]) AS collection_cassation_date,
            unnest({CollectionCassationResult}::character varying[]) AS collection_cassation_result,
            unnest({CollectionApplicationTypeTitle}::character varying[]) AS collection_application_type_title,
            unnest({CollectionApplicationSum}::numeric[]) AS collection_application_sum,
            unnest({CollectionApplicationTax}::numeric[]) AS collection_application_tax,
            unnest({ExecutiveDocumentInfo}::character varying[]) AS executive_document_info,
            unnest({ExecutiveOspTitle}::character varying[]) AS executive_osp_title,
            unnest({ExecutiveOspAddress}::character varying[]) AS executive_osp_address,
            unnest({ExecutiveOspUfsspTitle}::character varying[]) AS executive_osp_ufssp_title,
            unnest({ExecutiveOspPhone}::character varying[]) AS executive_osp_phone,
            unnest({ExecutiveBailiffTitle}::character varying[]) AS executive_bailiff_title,
            unnest({ExecutiveBailiffPhone}::character varying[]) AS executive_bailiff_phone,
            unnest({ExecutiveSendDate}::date[]) AS executive_send_date,
            unnest({ExecutiveStartDate}::date[]) AS executive_start_date,
            unnest({ExecutiveNumber}::character varying[]) AS executive_number,
            unnest({ExecutiveOtherInfo}::character varying[]) AS executive_other_info,
            unnest({ExecutiveReplacementSendDate}::date[]) AS executive_replacement_send_date,
            unnest({ExecutiveReplacementDate}::date[]) AS executive_replacement_date,
            unnest({ExecutiveRequest}::character varying[]) AS executive_request,
            unnest({ExecutiveRequestResponse}::character varying[]) AS executive_request_response,
            unnest({ExecutiveEndDate}::date[]) AS executive_end_date,
            unnest({ExecutiveReSendDate}::date[]) AS executive_resend_date,
            unnest({ExecutiveEndReason}::character varying[]) AS executive_end_reason,
            unnest({ExecutiveRestrictDate}::date[]) AS executive_restrict_date,
            unnest({ExecutiveRestrictEndDate}::date[]) AS executive_restrict_end_date,
            unnest({ExecutiveAppealSendDate}::date[]) AS executive_appeal_send_date,
            unnest({ExecutiveAppealDate}::date[]) AS executive_appeal_date,
            unnest({ExecutiveAppealResult}::character varying[]) AS executive_appeal_result,
            unnest({BankruptCourtTitle}::character varying[]) AS client_bankrupt_court_title,
            unnest({BankruptCourtTitleGenitive}::character varying[]) AS client_bankrupt_court_title_genitive,
            unnest({BankruptCourtRegion}::character varying[]) AS client_bankrupt_court_region,
            unnest({BankruptCourtAddress}::character varying[]) AS client_bankrupt_court_address,
            unnest({BankruptCourtReceiver}::character varying[]) AS client_bankrupt_court_receiver,
            unnest({BankruptCourtReceiverBank}::character varying[]) AS client_bankrupt_court_receiver_bank,
            unnest({BankruptCourtReceiverBankCity}::character varying[]) AS client_bankrupt_court_receiver_bank_city,
            unnest({BankruptCourtInn}::character varying[]) AS client_bankrupt_court_inn,
            unnest({BankruptCourtKpp}::character varying[]) AS client_bankrupt_court_kpp,
            unnest({BankruptCourtCorrespondentAccount}::character varying[]) AS client_bankrupt_court_correspondent_account,
            unnest({BankruptCourtAccount}::character varying[]) AS client_bankrupt_court_account,
            unnest({BankruptCourtBik}::character varying[]) AS client_bankrupt_court_bik,
            unnest({BankruptCourtOktmo}::character varying[]) AS client_bankrupt_court_oktmo,
            unnest({BankruptCourtKbk}::character varying[]) AS client_bankrupt_court_kbk,
            unnest({BankruptCourtPhone}::character varying[]) AS client_bankrupt_court_phone,
            unnest({BankruptCourtEmail}::character varying[]) AS client_bankrupt_court_email,
            unnest({BankruptCourtSite}::character varying[]) AS client_bankrupt_court_site,
            unnest({BankruptCaseNumber}::character varying[]) AS client_bankrupt_case_number,
            unnest({BankruptOutCourtBankruptEndDate}::date[]) AS client_bankrupt_out_court_bankrupt_end_date,
            unnest({BankruptNextSessionDate}::date[]) AS client_bankrupt_next_session_date,
            unnest({BankruptRecognitionDate}::date[]) AS client_bankrupt_recognition_date,
            unnest({BankruptSalePropertyDate}::date[]) AS client_bankrupt_sale_property_date,
            unnest({BankruptWorkStateDate}::date[]) AS client_bankrupt_work_state_date,
            unnest({BankruptDescription}::character varying[]) AS client_bankrupt_description,
            unnest({BankruptType}::character varying[]) AS client_bankrupt_type,
            unnest({BankruptEFRSBNumber}::character varying[]) AS client_bankrupt_efrsb_number,
            unnest({BankruptEFRSBLink}::character varying[]) AS client_bankrupt_efrsb_link,   
            unnest({JurisdictionCourtTitle}::character varying[]) AS client_jurisdiction_court_title,
            unnest({JurisdictionCourtTitleGenitive}::character varying[]) AS client_jurisdiction_court_title_genitive,
            unnest({JurisdictionCourtRegion}::character varying[]) AS client_jurisdiction_court_region,
            unnest({JurisdictionCourtAddress}::character varying[]) AS client_jurisdiction_court_address,
            unnest({JurisdictionCourtReceiver}::character varying[]) AS client_jurisdiction_court_receiver,
            unnest({JurisdictionCourtReceiverBank}::character varying[]) AS client_jurisdiction_court_receiver_bank,
            unnest({JurisdictionCourtReceiverBankCity}::character varying[]) AS client_jurisdiction_court_receiver_bank_city,
            unnest({JurisdictionCourtInn}::character varying[]) AS client_jurisdiction_court_inn,
            unnest({JurisdictionCourtKpp}::character varying[]) AS client_jurisdiction_court_kpp,
            unnest({JurisdictionCourtCorrespondentAccount}::character varying[]) AS client_jurisdiction_court_correspondent_account,
            unnest({JurisdictionCourtAccount}::character varying[]) AS client_jurisdiction_court_account,
            unnest({JurisdictionCourtBik}::character varying[]) AS client_jurisdiction_court_bik,
            unnest({JurisdictionCourtOktmo}::character varying[]) AS client_jurisdiction_court_oktmo,
            unnest({JurisdictionCourtKbk}::character varying[]) AS client_jurisdiction_court_kbk,
            unnest({JurisdictionCourtPhone}::character varying[]) AS client_jurisdiction_court_phone,
            unnest({JurisdictionCourtEmail}::character varying[]) AS client_jurisdiction_court_email,
            unnest({JurisdictionCourtSite}::character varying[]) AS client_jurisdiction_court_site,
            unnest({JurisdictionOspTitle}::character varying[]) AS client_jurisdiction_osp_title,
            unnest({JurisdictionOspAddress}::character varying[]) AS client_jurisdiction_osp_address,
            unnest({JurisdictionOspUfsspTitle}::character varying[]) AS client_jurisdiction_osp_ufssp_title,
            unnest({JurisdictionOspPhone}::character varying[]) AS client_jurisdiction_osp_phone,
            unnest({CommentComment}::character varying[]) AS comment_comment,
            unnest({InteractionLimitConcentDate}::date[]) AS interaction_limit_concent_date,
            unnest({InteractionLimitAgentConcentDate}::date[]) AS interaction_limit_agent_concent_date,
            unnest({InteractionLimitAgentTitle}::character varying[]) AS interaction_limit_agent_title,
            unnest({InteractionLimitAgentBirthDate}::date[]) AS interaction_limit_agent_birth_date,
            unnest({InteractionLimitAgentPhone}::character varying[]) AS interaction_limit_agent_phone,
            unnest({InteractionLimitAgentAddress}::character varying[]) AS interaction_limit_agent_address,
            unnest({InteractionLimitAgentEmail}::character varying[]) AS interaction_limit_agent_email,
            unnest({InteractionLimitAgentLawyer}::character varying[]) AS interaction_limit_agent_lawyer,
            unnest({InteractionLimitRejectDate}::date[]) AS interaction_limit_reject_date,
            unnest({InteractionLimitAgentRejectDate}::date[]) AS interaction_limit_agent_reject_date,
            unnest({InteractionLimitRejectCancelDate}::date[]) AS interaction_limit_reject_cancel_date,
            unnest({InteractionLimitOtherAgentDate}::date[]) AS interaction_limit_other_agent_date,
            unnest({InteractionLimitRequest}::character varying[]) AS interaction_limit_request,
            unnest({InteractionLimitRequestResponse}::character varying[]) AS interaction_limit_request_response,
            unnest({ClaimantType}::character varying[]) AS claimant_type,
            unnest({FirstClaimantType}::character varying[]) AS first_claimant_type,
            unnest({LoanAccountNumber}::character varying[]) AS loan_account_number,
            unnest({LoanFullPrice}::numeric[]) AS loan_full_price,
            unnest({LoanFullPricePercent}::numeric[]) AS loan_full_price_percent,
            unnest({LoanOverdueDate}::date[]) AS loan_overdue_date,
            unnest({LoanClientSuretyDuty}::character varying[]) AS loan_client_surety_duty,
            unnest({LoanClientSuretySum}::numeric[]) AS loan_client_surety_sum) T;

        SELECT collect.temp_loan_check_error() AS "ErrorText";
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempLoanAutoParseUpdateSqlQuery">
      <Text>
        UPDATE
          collect.temp_loan TL
        SET
          client_first_name = CASE WHEN COALESCE(TL.client_first_name, '') = '' THEN T.client_first_name ELSE TL.client_first_name END,
          client_second_name = CASE WHEN COALESCE(TL.client_second_name, '') = '' THEN T.client_second_name ELSE TL.client_second_name END,
          client_third_name = CASE WHEN COALESCE(TL.client_third_name, '') = '' THEN T.client_third_name ELSE TL.client_third_name END
        FROM (
          WITH A AS (
            SELECT
              temp_loan_id,
              regexp_split_to_array(client_title,'\s+') AS client_title
            FROM
              collect.temp_loan
            )
          SELECT
            temp_loan_id,
            client_title[1] || CASE WHEN position('(' IN client_title[2]) > 0 THEN  ' ' || client_title[2] ELSE '' END AS client_first_name,
            CASE WHEN position('(' IN client_title[2]) > 0 THEN client_title[3] ELSE client_title[2] END AS client_second_name,
            CASE WHEN position('(' IN client_title[2]) > 0 THEN COALESCE(client_title[4], '') || COALESCE(' ' || client_title[5], '') ELSE COALESCE(client_title[3], '') || COALESCE(' ' || client_title[4], '') END AS client_third_name
          FROM
            A
          ) T
        WHERE
          COALESCE((SELECT auto_parse FROM collect.excel_import_column WHERE "name" = 'client_title'), false) AND
          T.temp_loan_id = TL.temp_loan_id;

        UPDATE
          collect.temp_loan TL
        SET
          client_passport_series = CASE WHEN COALESCE(TL.client_passport_series, '') = '' THEN T.client_passport_series ELSE TL.client_passport_series END,
          client_passport_number = CASE WHEN COALESCE(TL.client_passport_number, '') = '' THEN T.client_passport_number ELSE TL.client_passport_number END,
          client_passport_given_by = CASE WHEN COALESCE(TL.client_passport_given_by, '') = '' THEN T.client_passport_given_by ELSE TL.client_passport_given_by END,
          client_passport_given_date = CASE WHEN TL.client_passport_given_date IS NULL THEN T.client_passport_given_date ELSE TL.client_passport_given_date END,
          client_passport_code = CASE WHEN COALESCE(TL.client_passport_code, '') = '' THEN T.client_passport_code ELSE TL.client_passport_code END
        FROM (
          SELECT
            temp_loan_id,
            CASE
              WHEN position('серия' IN client_passport)>0 OR position('Серия' IN client_passport)>0 THEN substring(substring(client_passport from E'^.*?\\s{0,}\\d{4}'),'....$')
              WHEN position('паспорт:' IN client_passport)>0 THEN substring(replace(substring(client_passport from E'паспорт:\\s*\\d{2}\\s*\\d{2}'),' ',''),'....$')
              WHEN position('Паспорт:' IN client_passport)>0 THEN substring(replace(substring(client_passport from E'Паспорт:\\s*\\d{2}\\s*\\d{2}'),' ',''),'....$')
              ELSE substring(replace(substring(client_passport from E'\\s*\\d{2}\\s*\\d{2}'),' ',''),'....$')
            END AS client_passport_series,
            CASE
              WHEN position('серия' IN client_passport)>0 OR position('Серия' IN client_passport)>0 THEN substring(substring(client_passport from E'№\\s.*?\\d{6}'),'......$')
              WHEN position('паспорт:' IN client_passport)>0 THEN substring(substring(client_passport from E'паспорт:.*?\\d{6}'),'......$')
              WHEN position('Паспорт:' IN client_passport)>0 THEN substring(substring(client_passport from E'Паспорт:.*?\\d{6}'),'......$')
              ELSE substring(substring(client_passport from E'.*?\\d{6}'),'......$')
            END AS client_passport_number,
            CASE
              WHEN position('серия' IN client_passport)>0 OR position('Серия' IN client_passport)>0 THEN trim(substring(substring(client_passport from E'\\d{6}.*\\,') from 7),' ,')
              WHEN position('выдан' IN client_passport)>0 THEN substr(trim(substring(substring(client_passport from E'выдан.*?$')from 6)), 1,
                   CASE WHEN strpos(trim(substring(substring(client_passport from E'выдан.*?$')from 6)), ',') > 0 THEN strpos(trim(substring(substring(client_passport from E'выдан.*?$')from 6)), ',') - 1 ELSE length(trim(substring(substring(client_passport from E'выдан.*?$')from 6))) END)
              WHEN position('Выдан' IN client_passport)>0 THEN substr(trim(substring(substring(client_passport from E'Выдан.*?$')from 6)), 1,
                   CASE WHEN strpos(trim(substring(substring(client_passport from E'Выдан.*?$')from 6)), ',') > 0 THEN strpos(trim(substring(substring(client_passport from E'Выдан.*?$')from 6)), ',') - 1 ELSE length(trim(substring(substring(client_passport from E'Выдан.*?$')from 6))) END)
              ELSE ''
            END AS client_passport_given_by,
            collect.try_cast(substring(client_passport from E'\\d{2}[\\.\\/]\\d{2}[\\.\\/]\\d{4}'), NULL::date) AS client_passport_given_date,
            substring(client_passport from E'\\d{3}[\\-\\/]\\d{3}') AS client_passport_code
          FROM
            collect.temp_loan
          ) T
        WHERE
          COALESCE((SELECT auto_parse FROM collect.excel_import_column WHERE "name" = 'client_passport'), false) AND
          T.temp_loan_id = TL.temp_loan_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempLoanReferencesUpdateSqlQuery">
      <Text>
        UPDATE
          collect.temp_loan TL
        SET
          client_id = T.client_id
        FROM (
          SELECT
            CP.client_id,
            trim(CP.first_name) AS client_first_name,
            trim(CP.second_name) AS client_second_name,
            trim(CP.third_name) AS client_third_name,
            CP.birth_date AS client_birth_date
          FROM
            collect.client_person CP
            JOIN collect.client C USING(client_id)
          WHERE
            NOT C.deleted
          ORDER BY client_id DESC
          ) T
        WHERE
          TL.client_id IS NULL AND
          COALESCE(TL.client_first_name, '') != '' AND
          COALESCE(TL.client_second_name, '') != '' AND
          COALESCE(TL.client_third_name, '') != '' AND
          TL.client_birth_date IS NOT NULL AND
          lower(TL.client_first_name) = lower(T.client_first_name) AND
          lower(TL.client_second_name) = lower(T.client_second_name) AND
          lower(COALESCE(TL.client_third_name, '')) = lower(COALESCE(T.client_third_name, '')) AND
          TL.client_birth_date = T.client_birth_date;

        UPDATE
          collect.temp_loan TL
        SET
          registration_address_region_id = T.registration_address_region_id
        FROM (
          SELECT
            ARA.address_region_id AS registration_address_region_id,
            ARA.title AS client_registration_address_region
          FROM
            collect.address_region_alternative ARA
          ORDER BY address_region_id DESC
          ) T
        WHERE
          COALESCE(TL.client_registration_address_region, '') != '' AND
          TL.client_registration_address_region = T.client_registration_address_region;

        UPDATE
          collect.temp_loan TL
        SET
          registration_address_region_id = T.registration_address_region_id
        FROM (
          SELECT
            AR.address_region_id AS registration_address_region_id,
            AR.title AS client_registration_address_region
          FROM
            collect.address_region AR
          ORDER BY address_region_id DESC
          ) T
        WHERE
          COALESCE(TL.client_registration_address_region, '') != '' AND
          TL.registration_address_region_id IS NULL AND
          (TL.client_registration_address_region ILIKE '%' || T.client_registration_address_region || '%' OR
          T.client_registration_address_region ILIKE '%' || TL.client_registration_address_region || '%');

        UPDATE
          collect.temp_loan TL
        SET
          registration_address_city_type_id = T.registration_address_city_type_id
        FROM (
          SELECT
            address_city_type_id AS registration_address_city_type_id,
            title AS client_registration_address_city_type,
            string_to_array(alternative_values, ';')::character varying[] AS city_type_alternative
          FROM
            collect.address_city_type
          ORDER BY address_city_type_id DESC
          ) T
        WHERE
          COALESCE(TL.client_registration_address_city_type, '') != '' AND
          (lower(TL.client_registration_address_city_type) = ANY(city_type_alternative) OR
          lower(TL.client_registration_address_city_type) = lower(T.client_registration_address_city_type));

        UPDATE
          collect.temp_loan TL
        SET
          registration_address_street_type_id = T.registration_address_street_type_id
        FROM (
          SELECT
            address_street_type_id AS registration_address_street_type_id,
            title AS client_registration_address_street_type,
            string_to_array(alternative_values, ';')::character varying[] AS street_type_alternative
          FROM
            collect.address_street_type
          ORDER BY address_street_type_id DESC
          ) T
        WHERE
          COALESCE(TL.client_registration_address_street_type, '') != '' AND
          (lower(TL.client_registration_address_street_type) = ANY(street_type_alternative) OR
          lower(TL.client_registration_address_street_type) = lower(T.client_registration_address_street_type));

        UPDATE
          collect.temp_loan TL
        SET
          actual_address_region_id = T.actual_address_region_id
        FROM (
          SELECT
            ARA.address_region_id AS actual_address_region_id,
            ARA.title AS client_actual_address_region
          FROM
            collect.address_region_alternative ARA
          ORDER BY address_region_id DESC
          ) T
        WHERE
          COALESCE(TL.client_actual_address_region, '') != '' AND
          TL.client_actual_address_region = T.client_actual_address_region;

        UPDATE
          collect.temp_loan TL
        SET
          actual_address_region_id = T.actual_address_region_id
        FROM (
          SELECT
            AR.address_region_id AS actual_address_region_id,
            AR.title AS client_actual_address_region
          FROM
            collect.address_region AR
          ORDER BY address_region_id DESC
          ) T
        WHERE
          COALESCE(TL.client_actual_address_region, '') != '' AND
          TL.actual_address_region_id IS NULL AND
          (TL.client_actual_address_region ILIKE '%' || T.client_actual_address_region || '%' OR
          T.client_actual_address_region ILIKE '%' || TL.client_actual_address_region || '%');

        UPDATE
          collect.temp_loan TL
        SET
          actual_address_city_type_id = T.actual_address_city_type_id
        FROM (
          SELECT
            address_city_type_id AS actual_address_city_type_id,
            title AS client_actual_address_city_type,
            string_to_array(alternative_values, ';')::character varying[] AS city_type_alternative
          FROM
            collect.address_city_type
          ORDER BY address_city_type_id DESC
          ) T
        WHERE
          COALESCE(TL.client_actual_address_city_type, '') != '' AND
          (lower(TL.client_actual_address_city_type) = ANY(city_type_alternative) OR
          lower(TL.client_actual_address_city_type) = lower(T.client_actual_address_city_type));

        UPDATE
          collect.temp_loan TL
        SET
          actual_address_street_type_id = T.actual_address_street_type_id
        FROM (
          SELECT
            address_street_type_id AS actual_address_street_type_id,
            title AS client_actual_address_street_type,
            string_to_array(alternative_values, ';')::character varying[] AS street_type_alternative
          FROM
            collect.address_street_type
          ORDER BY address_street_type_id DESC
          ) T
        WHERE
          COALESCE(TL.client_actual_address_street_type, '') != '' AND
          (lower(TL.client_actual_address_street_type) = ANY(street_type_alternative) OR
          lower(TL.client_actual_address_street_type) = lower(T.client_actual_address_street_type));

        UPDATE
          collect.temp_loan TL
        SET
          movable_sell_result_id = T.movable_sell_result_id
        FROM (
          SELECT
            sell_result_id AS movable_sell_result_id,
            title AS client_property_movable_sell_result
          FROM
            collect.sell_result
          ORDER BY sell_result_id DESC
          ) T
        WHERE
          COALESCE(TL.client_property_movable_sell_result, '') != '' AND
          lower(TL.client_property_movable_sell_result) = lower(T.client_property_movable_sell_result);

        UPDATE
          collect.temp_loan TL
        SET
          real_sell_result_id = T.real_sell_result_id
        FROM (
          SELECT
            sell_result_id AS real_sell_result_id,
            title AS client_property_real_sell_result
          FROM
            collect.sell_result
          ORDER BY sell_result_id DESC
          ) T
        WHERE
          COALESCE(TL.client_property_real_sell_result, '') != '' AND
          lower(TL.client_property_real_sell_result) = lower(T.client_property_real_sell_result);

        UPDATE
          collect.temp_loan TL
        SET
          loan_id = T.loan_id
        FROM (
          SELECT
            loan_id,
            trim(credit_number) AS loan_credit_number,
            credit_date AS loan_credit_date
          FROM
            collect.loan
          WHERE
            NOT deleted
          ORDER BY loan_id DESC
          ) T
        WHERE
          TL.loan_id IS NULL AND
          COALESCE(TL.loan_credit_number, '') != '' AND
          TL.loan_credit_date IS NOT NULL AND
          lower(TL.loan_credit_number) = lower(T.loan_credit_number) AND
          TL.loan_credit_date = T.loan_credit_date;

        UPDATE
          collect.temp_loan TL
        SET
          cession_type_id = T.cession_type_id
        FROM (
          SELECT
            cession_type_id,
            title AS cession_type
          FROM
            collect.cession_type
          ORDER BY cession_type_id DESC
          ) T
        WHERE
          COALESCE(TL.cession_type, '') != '' AND
          lower(TL.cession_type) = lower(T.cession_type);

        UPDATE
          collect.temp_loan TL
        SET
          cession_address_region_id = T.cession_address_region_id
        FROM (
          SELECT
            ARA.address_region_id AS cession_address_region_id,
            ARA.title AS cession_region
          FROM
            collect.address_region_alternative ARA
          ORDER BY address_region_id DESC
          ) T
        WHERE
          COALESCE(TL.cession_region, '') != '' AND
          TL.cession_region = T.cession_region;

        UPDATE
          collect.temp_loan TL
        SET
          cession_address_region_id = T.cession_address_region_id
        FROM (
          SELECT
            AR.address_region_id AS cession_address_region_id,
            AR.title AS cession_region
          FROM
            collect.address_region AR
          ORDER BY address_region_id DESC
          ) T
        WHERE
          COALESCE(TL.cession_region, '') != '' AND
          TL.cession_address_region_id IS NULL AND
          (TL.cession_region ILIKE '%' || T.cession_region || '%' OR
          T.cession_region ILIKE '%' || TL.cession_region || '%');

        UPDATE
          collect.temp_loan TL
        SET
          credit_type_id = T.credit_type_id
        FROM (
          SELECT
            credit_type_id,
            title AS loan_credit_type
          FROM
            collect.credit_type
          ORDER BY credit_type_id DESC
          ) T
        WHERE
          COALESCE(TL.loan_credit_type, '') != '' AND
          lower(TL.loan_credit_type) = lower(T.loan_credit_type);

        UPDATE
          collect.temp_loan TL
        SET
          credit_line_type_id = T.credit_line_type_id
        FROM (
          SELECT
            credit_line_type_id,
            title AS loan_credit_line_type
          FROM
            collect.credit_line_type
          ORDER BY credit_line_type_id DESC
          ) T
        WHERE
          COALESCE(TL.loan_credit_line_type, '') != '' AND
          lower(TL.loan_credit_line_type) = lower(T.loan_credit_line_type);

        UPDATE
          collect.temp_loan TL
        SET
          credit_purpose_id = T.credit_purpose_id
        FROM (
          SELECT
            credit_purpose_id,
            title AS loan_credit_purpose
          FROM
            collect.credit_purpose
          ORDER BY credit_purpose_id DESC
          ) T
        WHERE
          COALESCE(TL.loan_credit_purpose, '') != '' AND
          lower(TL.loan_credit_purpose) = lower(T.loan_credit_purpose);

        UPDATE
          collect.temp_loan TL
        SET
          credit_get_type_id = T.credit_get_type_id
        FROM (
          SELECT
            credit_get_type_id,
            title AS loan_credit_get_type
          FROM
            collect.credit_get_type
          ORDER BY credit_get_type_id DESC
          ) T
        WHERE
          COALESCE(TL.loan_credit_get_type, '') != '' AND
          lower(TL.loan_credit_get_type) = lower(T.loan_credit_get_type);

        UPDATE
          collect.temp_loan TL
        SET
          role_id = T.role_id
        FROM (
          SELECT
            role_id,
            title AS loan_client_role
          FROM
            collect.role
          ORDER BY role_id DESC
          ) T
        WHERE
          COALESCE(TL.loan_client_role, '') != '' AND
          lower(TL.loan_client_role) = lower(T.loan_client_role);

        UPDATE
          collect.temp_loan TL
        SET
          user_id = T.user_id
        FROM (
          SELECT
            user_id,
            trim(user_full_name) AS loan_client_user
          FROM
            collect.user_info
          WHERE
            person
          ORDER BY user_id DESC
          ) T
        WHERE
          COALESCE(TL.loan_client_user, '') != '' AND
          lower(TL.loan_client_user) = lower(T.loan_client_user);

        UPDATE
          collect.temp_loan TL
        SET
          succession_court_address_region_id = T.succession_court_address_region_id
        FROM (
          SELECT
            ARA.address_region_id AS succession_court_address_region_id,
            ARA.title AS succession_court_region
          FROM
            collect.address_region_alternative ARA
          ORDER BY address_region_id DESC
          ) T
        WHERE
          COALESCE(TL.succession_court_region, '') != '' AND
          TL.succession_court_region = T.succession_court_region;

        UPDATE
          collect.temp_loan TL
        SET
          succession_court_address_region_id = T.succession_court_address_region_id
        FROM (
          SELECT
            AR.address_region_id AS succession_court_address_region_id,
            AR.title AS succession_court_region
          FROM
            collect.address_region AR
          ORDER BY address_region_id DESC
          ) T
        WHERE
          COALESCE(TL.succession_court_region, '') != '' AND
          TL.succession_court_address_region_id IS NULL AND
          (TL.succession_court_region ILIKE '%' || T.succession_court_region || '%' OR
          T.succession_court_region ILIKE '%' || TL.succession_court_region || '%');

        UPDATE
          collect.temp_loan TL
        SET
          succession_court_document_id = T.succession_court_document_id
        FROM (
          SELECT
            court_document_id AS succession_court_document_id,
            title AS succession_court_document
          FROM
            collect.court_document
          WHERE
            court_document_type IN ('all', 'succession')
          ORDER BY court_document_id DESC
          ) T
        WHERE
          COALESCE(TL.succession_court_document, '') != '' AND
          lower(TL.succession_court_document) = lower(T.succession_court_document);

        UPDATE
          collect.temp_loan TL
        SET
          collection_court_document_id = T.collection_court_document_id
        FROM (
          SELECT
            court_document_id AS collection_court_document_id,
            title AS collection_court_document
          FROM
            collect.court_document
          WHERE
            court_document_type IN ('all', 'collection')
          ORDER BY court_document_id DESC
          ) T
        WHERE
          COALESCE(TL.collection_court_document, '') != '' AND
          lower(TL.collection_court_document) = lower(T.collection_court_document);

        UPDATE
          collect.temp_loan TL
        SET
          collection_court_address_region_id = T.collection_court_address_region_id
        FROM (
          SELECT
            ARA.address_region_id AS collection_court_address_region_id,
            ARA.title AS collection_court_region
          FROM
            collect.address_region_alternative ARA
          ORDER BY address_region_id DESC
          ) T
        WHERE
          COALESCE(TL.collection_court_region, '') != '' AND
          TL.collection_court_region = T.collection_court_region;

        UPDATE
          collect.temp_loan TL
        SET
          collection_court_address_region_id = T.collection_court_address_region_id
        FROM (
          SELECT
            AR.address_region_id AS collection_court_address_region_id,
            AR.title AS collection_court_region
          FROM
            collect.address_region AR
          ORDER BY address_region_id DESC
          ) T
        WHERE
          COALESCE(TL.collection_court_region, '') != '' AND
          TL.collection_court_address_region_id IS NULL AND
          (TL.collection_court_region ILIKE '%' || T.collection_court_region || '%' OR
          T.collection_court_region ILIKE '%' || TL.collection_court_region || '%');

        UPDATE
          collect.temp_loan TL
        SET
          court_result_id = T.court_result_id
        FROM (
          SELECT
            court_result_id,
            title AS collection_court_result
          FROM
            collect.court_result
          ORDER BY court_result_id DESC
          ) T
        WHERE
          COALESCE(TL.collection_court_result, '') != '' AND
          lower(TL.collection_court_result) = lower(T.collection_court_result);

        UPDATE
          collect.temp_loan TL
        SET
          client_bankrupt_court_address_region_id = T.client_bankrupt_court_address_region_id
        FROM (
          SELECT
            ARA.address_region_id AS client_bankrupt_court_address_region_id,
            ARA.title AS client_bankrupt_court_region
          FROM
            collect.address_region_alternative ARA
          ORDER BY address_region_id DESC
          ) T
        WHERE
          COALESCE(TL.client_bankrupt_court_region, '') != '' AND
          TL.client_bankrupt_court_region = T.client_bankrupt_court_region;

        UPDATE
          collect.temp_loan TL
        SET
          client_bankrupt_court_address_region_id = T.client_bankrupt_court_address_region_id
        FROM (
          SELECT
            AR.address_region_id AS client_bankrupt_court_address_region_id,
            AR.title AS client_bankrupt_court_region
          FROM
            collect.address_region AR
          ORDER BY address_region_id DESC
          ) T
        WHERE
          COALESCE(TL.client_bankrupt_court_region, '') != '' AND
          TL.client_bankrupt_court_address_region_id IS NULL AND
          (TL.client_bankrupt_court_region ILIKE '%' || T.client_bankrupt_court_region || '%' OR
          T.client_bankrupt_court_region ILIKE '%' || TL.client_bankrupt_court_region || '%');

        UPDATE
          collect.temp_loan TL
        SET
          client_jurisdiction_court_address_region_id = T.client_jurisdiction_court_address_region_id
        FROM (
          SELECT
            AR.address_region_id AS client_jurisdiction_court_address_region_id,
            AR.title AS client_jurisdiction_court_region
          FROM
            collect.address_region AR
          ORDER BY address_region_id DESC
          ) T
        WHERE
          COALESCE(TL.client_jurisdiction_court_region, '') != '' AND
          TL.client_jurisdiction_court_address_region_id IS NULL AND
          (TL.client_jurisdiction_court_region ILIKE '%' || T.client_jurisdiction_court_region || '%' OR
          T.client_jurisdiction_court_region ILIKE '%' || TL.client_jurisdiction_court_region || '%');

        UPDATE
          collect.temp_loan TL
        SET
          client_gender =
          CASE
            WHEN lower(TL.client_gender) ~ '.*муж.*' OR lower(TL.client_gender) = 'м' THEN 'Мужской'
            WHEN lower(TL.client_gender) ~ '.*жен.*' OR lower(TL.client_gender) = 'ж' THEN 'Женский'
            ELSE NULL
          END
        WHERE
          COALESCE(TL.client_gender, '') != '';

        UPDATE
          collect.temp_loan TL
        SET
          claimant_type_id = T.claimant_type_id
        FROM (
          SELECT
            claimant_type_id,
            title AS claimant_type
          FROM
            collect.claimant_type
          ) T
        WHERE
          COALESCE(TL.claimant_type, '') != '' AND
          lower(TL.claimant_type) = lower(T.claimant_type);

        UPDATE
          collect.temp_loan TL
        SET
          first_claimant_type_id = T.first_claimant_type_id
        FROM (
          SELECT
            claimant_type_id AS first_claimant_type_id,
            title AS first_claimant_type
          FROM
            collect.claimant_type
          ) T
        WHERE
          COALESCE(TL.first_claimant_type, '') != '' AND
          lower(TL.first_claimant_type) = lower(T.first_claimant_type);

        UPDATE
          collect.temp_loan TL
        SET
          loan_client_surety_duty =
          CASE
            WHEN lower(TL.loan_client_surety_duty) = lower('В полном объеме') THEN 'В полном объеме'
            WHEN lower(TL.loan_client_surety_duty) = lower('Частично') THEN 'Частично'
            ELSE NULL
          END
        WHERE
          COALESCE(TL.loan_client_surety_duty, '') != '';
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempLoanSelectSqlQuery">
      <Text>
        SELECT
          temp_loan_id AS "TempLoanId",
          CASE
            WHEN TL.client_id IS NULL THEN client_title
            ELSE collect.get_client_title(CP.first_name, CP.second_name, CP.third_name)
          END AS "ClientTitle",
          COALESCE(CP.first_name, client_first_name) AS "ClientFirstName",
          COALESCE(CP.second_name, client_second_name) AS "ClientSecondName",
          COALESCE(CP.third_name, client_third_name) AS "ClientThirdName",
          client_gender AS "ClientGender",
          COALESCE(CP.birth_date, client_birth_date) AS "ClientBirthDate",
          client_birth_place AS "ClientBirthPlace",
          client_passport AS "ClientPassport",
          client_passport_series AS "ClientPassportSeries",
          client_passport_number AS "ClientPassportNumber",
          client_passport_given_by AS "ClientPassportGivenBy",
          client_passport_given_date AS "ClientPassportGivenDate",
          client_passport_code AS "ClientPassportCode",
          client_inn AS "ClientInn",
          client_is_special_tax_regime AS "ClientIsSpecialTaxRegime",
          client_snils AS "ClientSnils",
          client_email AS "ClientEmail",
          client_work_company_title AS "ClientWorkCompanyTitle",
          client_work_post AS "ClientWorkPost",
          client_work_salary AS "ClientWorkSalary",
          client_work_hired_date AS "ClientWorkHiredDate",
          client_work_fired_date AS "ClientWorkFiredDate",
          client_social_website AS "ClientSocialWebsite",
          client_social_link AS "ClientSocialLink",
          client_phone_number AS "ClientPhoneNumber",
          client_phone_type AS "ClientPhoneType",
          client_phone_contact_person_type AS "ClientPhoneContactPersonType",
          client_phone_contact_person AS "ClientPhoneContactPerson",
          client_phone_comment AS "ClientPhoneComment",
          client_phone_is_main AS "ClientPhoneIsMain",
          client_registration_address AS "ClientRegistrationAddress",
          client_registration_address_okato AS "ClientRegistrationAddressOkato",
          client_registration_address_index AS "ClientRegistrationAddressIndex",
          RA_AR.title AS "ClientRegistrationAddressRegion",
          client_registration_address_district AS "ClientRegistrationAddressDistrict",
          RA_ACT.title AS "ClientRegistrationAddressCityType",
          client_registration_address_city AS "ClientRegistrationAddressCity",
          client_registration_address_city_district AS "ClientRegistrationAddressCityDistrict",
          RA_AST.title AS "ClientRegistrationAddressStreetType",
          client_registration_address_street AS "ClientRegistrationAddressStreet",
          client_registration_address_building AS "ClientRegistrationAddressBuilding",
          client_registration_address_block AS "ClientRegistrationAddressBlock",
          client_registration_address_structure AS "ClientRegistrationAddressStructure",
          client_registration_address_flat AS "ClientRegistrationAddressFlat",
          client_actual_address AS "ClientActualAddress",
          client_actual_address_okato AS "ClientActualAddressOkato",
          client_actual_address_index AS "ClientActualAddressIndex",
          AA_AR.title AS "ClientActualAddressRegion",
          client_actual_address_district AS "ClientActualAddressDistrict",
          AA_ACT.title AS "ClientActualAddressCityType",
          client_actual_address_city AS "ClientActualAddressCity",
          client_actual_address_city_district AS "ClientActualAddressCityDistrict",
          AA_AST.title AS "ClientActualAddressStreetType",
          client_actual_address_street AS "ClientActualAddressStreet",
          client_actual_address_building AS "ClientActualAddressBuilding",
          client_actual_address_block AS "ClientActualAddressBlock",
          client_actual_address_structure AS "ClientActualAddressStructure",
          client_actual_address_flat AS "ClientActualAddressFlat",
          client_property_movable_title AS "ClientPropertyMovableTitle",
          client_property_movable_price AS "ClientPropertyMovablePrice",
          client_property_movable_share AS "ClientPropertyMovableShare",
          client_property_movable_is_pledged AS "ClientPropertyMovableIsPledged",
          client_property_movable_pledge_date AS "ClientPropertyMovablePledgeDate",
          client_property_movable_pledge_price AS "ClientPropertyMovablePledgePrice",
          client_property_movable_description AS "ClientPropertyMovableDescription",
          client_property_movable_model AS "ClientPropertyMovableModel",
          client_property_movable_year AS "ClientPropertyMovableYear",
          client_property_movable_color AS "ClientPropertyMovableColor",
          client_property_movable_buy_date AS "ClientPropertyMovableBuyDate",
          client_property_movable_number AS "ClientPropertyMovableNumber",
          client_property_movable_vin AS "ClientPropertyMovableVin",
          client_property_movable_ban_raise_date AS "ClientPropertyMovableBanRaiseDate",
          client_property_movable_ban_result_date AS "ClientPropertyMovableBanResultDate",
          client_property_movable_unban_date AS "ClientPropertyMovableUnBanDate",
          client_property_movable_ban_result AS "ClientPropertyMovableBanResult",
          client_property_movable_arrest_raise_date AS "ClientPropertyMovableArrestRaiseDate",
          client_property_movable_arrest_result_date AS "ClientPropertyMovableArrestResultDate",
          client_property_movable_unarrest_date AS "ClientPropertyMovableUnArrestDate",
          client_property_movable_arrest_result AS "ClientPropertyMovableArrestResult",
          client_property_movable_wanted_raise_date AS "ClientPropertyMovableWantedRaiseDate",
          client_property_movable_wanted_result_date AS "ClientPropertyMovableWantedResultDate",
          client_property_movable_unwanted_date AS "ClientPropertyMovableUnWantedDate",
          client_property_movable_wanted_result AS "ClientPropertyMovableWantedResult",
          client_property_movable_sell_date AS "ClientPropertyMovableSellDate",
          M_SR.title AS "ClientPropertyMovableSellResult",
          client_property_real_title AS "ClientPropertyRealTitle",
          client_property_real_price AS "ClientPropertyRealPrice",
          client_property_real_share AS "ClientPropertyRealShare",
          client_property_real_is_pledged AS "ClientPropertyRealIsPledged",
          client_property_real_pledge_date AS "ClientPropertyRealPledgeDate",
          client_property_real_pledge_price AS "ClientPropertyRealPledgePrice",
          client_property_real_description AS "ClientPropertyRealDescription",
          client_property_real_address AS "ClientPropertyRealAddress",
          client_property_real_cadastral_number AS "ClientPropertyRealCadastralNumber",
          client_property_real_cadastral_price AS "ClientPropertyRealCadastralPrice",
          client_property_real_area AS "ClientPropertyRealArea",
          client_property_real_ban_raise_date AS "ClientPropertyRealBanRaiseDate",
          client_property_real_ban_result_date AS "ClientPropertyRealBanResultDate",
          client_property_real_unban_date AS "ClientPropertyRealUnBanDate",
          client_property_real_ban_result AS "ClientPropertyRealBanResult",
          client_property_real_arrest_raise_date AS "ClientPropertyRealArrestRaiseDate",
          client_property_real_arrest_result_date AS "ClientPropertyRealArrestResultDate",
          client_property_real_unarrest_date AS "ClientPropertyRealUnArrestDate",
          client_property_real_arrest_result AS "ClientPropertyRealArrestResult",
          client_property_real_sell_date AS "ClientPropertyRealSellDate",
          R_SR.title AS "ClientPropertyRealSellResult",
          client_property_company_title AS "ClientPropertyCompanyTitle",
          client_property_company_price AS "ClientPropertyCompanyPrice",
          client_property_company_share AS "ClientPropertyCompanyShare",
          client_property_company_is_pledged AS "ClientPropertyCompanyIsPledged",
          client_property_company_pledge_date AS "ClientPropertyCompanyPledgeDate",
          client_property_company_pledge_price AS "ClientPropertyCompanyPledgePrice",
          client_property_company_description AS "ClientPropertyCompanyDescription",
          client_property_company_company_title AS "ClientPropertyCompanyCompanyTitle",
          client_property_company_inn AS "ClientPropertyCompanyInn",
          client_property_company_address AS "ClientPropertyCompanyAddress",
          client_property_company_contact AS "ClientPropertyCompanyContact",
          client_property_company_ban_raise_date AS "ClientPropertyCompanyBanRaiseDate",
          client_property_company_ban_result_date AS "ClientPropertyCompanyBanResultDate",
          client_property_company_unban_date AS "ClientPropertyCompanyUnBanDate",
          client_property_company_ban_result AS "ClientPropertyCompanyBanResult",
          client_account_bank_title AS "ClientAccountBankTitle",
          client_account_bank_requisite AS "ClientAccountBankRequisite",
          client_account AS "ClientAccount",
          client_account_description AS "ClientAccountDescription",
          client_account_arrest_date AS "ClientAccountArrestDate",
          client_salary_account_bank_title AS "ClientSalaryAccountBankTitle",
          client_salary_account_bank_requisite AS "ClientSalaryAccountBankRequisite",
          client_salary_account AS "ClientSalaryAccount",
          client_salary_account_description AS "ClientSalaryAccountDescription",
          client_salary_account_arrest_date AS "ClientSalaryAccountArrestDate",
          client_jurisdiction_court_title AS "ClientJurisdictionCourtTitle",
          client_jurisdiction_court_title_genitive AS "ClientJurisdictionCourtTitleGenitive",
          J_AR.title AS "ClientJurisdictionCourtRegion",
          client_jurisdiction_court_address AS "ClientJurisdictionCourtAddress",
          client_jurisdiction_court_receiver AS "ClientJurisdictionCourtReceiver",
          client_jurisdiction_court_receiver_bank AS "ClientJurisdictionCourtReceiverBank",
          client_jurisdiction_court_receiver_bank_city AS "ClientJurisdictionCourtReceiverBankCity",
          client_jurisdiction_court_inn AS "ClientJurisdictionCourtInn",
          client_jurisdiction_court_kpp AS "ClientJurisdictionCourtKpp",
          client_jurisdiction_court_correspondent_account AS "ClientJurisdictionCourtCorrespondentAccount",
          client_jurisdiction_court_account AS "ClientJurisdictionCourtAccount",
          client_jurisdiction_court_bik AS "ClientJurisdictionCourtBik",
          client_jurisdiction_court_oktmo AS "ClientJurisdictionCourtOktmo",
          client_jurisdiction_court_kbk AS "ClientJurisdictionCourtKbk",
          client_jurisdiction_court_phone AS "ClientJurisdictionCourtPhone",
          client_jurisdiction_court_email AS "ClientJurisdictionCourtEmail",
          client_jurisdiction_court_site AS "ClientJurisdictionCourtSite",
          client_jurisdiction_osp_title AS "ClientJurisdictionOspTitle",
          client_jurisdiction_osp_address AS "ClientJurisdictionOspAddress",
          client_jurisdiction_osp_ufssp_title AS "ClientJurisdictionOspUfsspTitle",
          client_jurisdiction_osp_phone AS "ClientJurisdictionOspPhone",
          client_bankrupt_court_title AS "ClientBankruptCourtTitle",
          client_bankrupt_court_title_genitive AS "ClientBankruptCourtTitleGenitive",
          B_AR.title AS "ClientBankruptCourtRegion",
          client_bankrupt_court_address AS "ClientBankruptCourtAddress",
          client_bankrupt_court_receiver AS "ClientBankruptCourtReceiver",
          client_bankrupt_court_receiver_bank AS "ClientBankruptCourtReceiverBank",
          client_bankrupt_court_receiver_bank_city AS "ClientBankruptCourtReceiverBankCity",
          client_bankrupt_court_inn AS "ClientBankruptCourtInn",
          client_bankrupt_court_kpp AS "ClientBankruptCourtKpp",
          client_bankrupt_court_correspondent_account AS "ClientBankruptCourtCorrespondentAccount",
          client_bankrupt_court_account AS "ClientBankruptCourtAccount",
          client_bankrupt_court_bik AS "ClientBankruptCourtBik",
          client_bankrupt_court_oktmo AS "ClientBankruptCourtOktmo",
          client_bankrupt_court_kbk AS "ClientBankruptCourtKbk",
          client_bankrupt_court_phone AS "ClientBankruptCourtPhone",
          client_bankrupt_court_email AS "ClientBankruptCourtEmail",
          client_bankrupt_court_site AS "ClientBankruptCourtSite",
          client_bankrupt_case_number AS "ClientBankruptCaseNumber",
          client_bankrupt_type AS "ClientBankruptType",
          client_bankrupt_efrsb_number AS "ClientBankruptEFRSBNumber",
          client_bankrupt_efrsb_link AS "ClientBankruptEFRSBLink",
          client_bankrupt_out_court_bankrupt_end_date AS "ClientBankruptOutCourtBankruptEndDate",
          client_bankrupt_description AS "ClientBankruptDescription",
          client_bankrupt_next_session_date AS "ClientBankruptNextSessionDate",
          client_bankrupt_recognition_date AS "ClientBankruptRecognitionDate",
          client_bankrupt_sale_property_date AS "ClientBankruptSalePropertyDate",
          client_bankrupt_work_state_date AS "ClientBankruptWorkStateDate",
          cession_title AS "CessionTitle",
          CT.title AS "CessionType",
          cession_date AS "CessionDate",
          cession_agreement_number AS "CessionAgreementNumber",
          inner_org_title AS "InnerOrgTitle",
          inner_org_short_title AS "InnerOrgShortTitle",
          inner_org_leader_post AS "InnerOrgLeaderPost",
          inner_org_document AS "InnerOrgDocument",
          inner_org_leader_title AS "InnerOrgLeaderTitle",
          inner_org_leader_genitive AS "InnerOrgLeaderGenitive",
          inner_org_leader_initials AS "InnerOrgLeaderInitials",
          inner_org_legal_address AS "InnerOrgLegalAddress",
          inner_org_actual_address AS "InnerOrgActualAddress",
          inner_org_city AS "InnerOrgCity",
          inner_org_create_date AS "InnerOrgCreateDate",
          inner_org_inn AS "InnerOrgInn",
          inner_org_kpp AS "InnerOrgKpp",
          inner_org_ogrn AS "InnerOrgOgrn",
          inner_org_payment_account AS "InnerOrgPaymentAccount",
          inner_org_bank AS "InnerOrgBank",
          inner_org_bank_city AS "InnerOrgBankCity",
          inner_org_correspondent_account AS "InnerOrgCorrespondentAccount",
          inner_org_bik AS "InnerOrgBIK",
          inner_org_phone AS "InnerOrgPhone",
          inner_org_fax AS "InnerOrgFax",
          inner_org_email AS "InnerOrgEmail",
          inner_org_website AS "InnerOrgWebsite",
          CL_T.title AS "ClaimantType",
          claimant_title AS "ClaimantTitle",
          claimant_short_title AS "ClaimantShortTitle",
          claimant_branch AS "ClaimantBranch",
          claimant_representative AS "ClaimantRepresentative",
          claimant_representative_post AS "ClaimantRepresentativePost",
          claimant_document AS "ClaimantDocument",
          claimant_inn AS "ClaimantInn",
          claimant_address AS "ClaimantAddress",
          claimant_title_genitive AS "ClaimantTitleGenitive",
          claimant_branch_genitive AS "ClaimantBranchGenitive",
          claimant_representative_genitive AS "ClaimantRepresentativeGenitive",
          claimant_representative_post_genitive AS "ClaimantRepresentativePostGenitive",
          claimant_document_genitive AS "ClaimantDocumentGenitive",
          CS_AR.title AS "CessionRegion",
          COALESCE(L.credit_number, loan_credit_number) AS "LoanCreditNumber",
          COALESCE(L.credit_date, loan_credit_date) AS "LoanCreditDate",
          loan_account_number AS "LoanAccountNumber",
          loan_credit_end_date AS "LoanCreditEndDate",
          loan_credit_sum AS "LoanCreditSum",
          loan_credit_rate AS "LoanCreditRate",
          loan_is_floating_credit_rate AS "LoanIsFloatingCreditRate",
          loan_full_price AS "LoanFullPrice",
          loan_full_price_percent AS "LoanFullPricePercent",
          loan_overdue_date AS "LoanOverdueDate",
          CRT.title AS "LoanCreditType",
          CRLT.title AS "LoanCreditLineType",
          CRP.title AS "LoanCreditPurpose",
          CGT.title AS "LoanCreditGetType",
          FCL_T.title AS "FirstClaimantType",
          first_claimant_title AS "FirstClaimantTitle",
          first_claimant_short_title AS "FirstClaimantShortTitle",
          first_claimant_branch AS "FirstClaimantBranch",
          first_claimant_representative AS "FirstClaimantRepresentative",
          first_claimant_representative_post AS "FirstClaimantRepresentativePost",
          first_claimant_document AS "FirstClaimantDocument",
          first_claimant_inn AS "FirstClaimantInn",
          first_claimant_address AS "FirstClaimantAddress",
          first_claimant_title_genitive AS "FirstClaimantTitleGenitive",
          first_claimant_branch_genitive AS "FirstClaimantBranchGenitive",
          first_claimant_representative_genitive AS "FirstClaimantRepresentativeGenitive",
          first_claimant_representative_post_genitive AS "FirstClaimantRepresentativePostGenitive",
          first_claimant_document_genitive AS "FirstClaimantDocumentGenitive",
          loan_debt_base AS "LoanDebtBase",
          loan_debt_percent AS "LoanDebtPercent",
          loan_debt_penalty AS "LoanDebtPenalty",
          loan_debt_tax AS "LoanDebtTax",
          R.title AS "LoanClientRole",
          loan_client_is_main AS "LoanClientIsMain",
          loan_client_unique_id AS "LoanClientUniqueId",
          loan_client_surety_number AS "LoanClientSuretyNumber",
          loan_client_surety_duty AS "LoanClientSuretyDuty",
          loan_client_surety_sum AS "LoanClientSuretySum",
          UI.user_full_name AS "LoanClientUser",
          loan_client_status AS "LoanClientStatus",
          loan_client_close_date AS "LoanClientCloseDate",
          loan_client_sale_date AS "LoanClientSaleDate",
          loan_client_court_sum AS "LoanClientCourtSum",
          loan_client_court_date AS "LoanClientCourtDate",
          loan_client_debt_base AS "LoanClientDebtBase",
          loan_client_debt_percent AS "LoanClientDebtPercent",
          loan_client_debt_penalty AS "LoanClientDebtPenalty",
          loan_client_debt_tax AS "LoanClientDebtTax",
          notification_number AS "NotificationNumber",
          notification_date AS "NotificationDate",
          notification_send_date AS "NotificationSendDate",
          notification_post_number AS "NotificationPostNumber",
          notification_delivery_info AS "NotificationDeliveryInfo",
          notification_is_actual AS "NotificationIsActual",
          succession_court_title AS "SuccessionCourtTitle",
          succession_court_title_genitive AS "SuccessionCourtTitleGenitive",
          S_AR.title AS "SuccessionCourtRegion",
          succession_court_address AS "SuccessionCourtAddress",
          succession_court_receiver AS "SuccessionCourtReceiver",
          succession_court_receiver_bank AS "SuccessionCourtReceiverBank",
          succession_court_receiver_bank_city AS "SuccessionCourtReceiverBankCity",
          succession_court_inn AS "SuccessionCourtInn",
          succession_court_kpp AS "SuccessionCourtKpp",
          succession_court_correspondent_account AS "SuccessionCourtCorrespondentAccount",
          succession_court_account AS "SuccessionCourtAccount",
          succession_court_bik AS "SuccessionCourtBik",
          succession_court_oktmo AS "SuccessionCourtOktmo",
          succession_court_kbk AS "SuccessionCourtKbk",
          succession_court_phone AS "SuccessionCourtPhone",
          succession_court_email AS "SuccessionCourtEmail",
          succession_court_site AS "SuccessionCourtSite",
          S_CD.title AS "SuccessionCourtDocument",
          succession_document_number AS "SuccessionDocumentNumber",
          succession_document_date AS "SuccessionDocumentDate",
          succession_document_is_duplicate AS "SuccessionDocumentIsDuplicate",
          succession_duplicate_get_date AS "SuccessionDuplicateGetDate",
          succession_duplicate_court_date AS "SuccessionDuplicateCourtDate",
          succession_document_info AS "SuccessionDocumentInfo",
          succession_case_number AS "SuccessionCaseNumber",
          succession_document_sum AS "SuccessionDocumentSum",
          succession_tax_sum AS "SuccessionTaxSum",
          succession_send_date AS "SuccessionSendDate",
          succession_court_date AS "SuccessionCourtDate",
          succession_result AS "SuccessionResult",
          succession_comment AS "SuccessionComment",
          succession_cancel_date AS "SuccessionCancelDate",
          succession_appeal_send_date AS "SuccessionAppealSendDate",
          succession_appeal_date AS "SuccessionAppealDate",
          succession_appeal_result AS "SuccessionAppealResult",
          succession_cassation_send_date AS "SuccessionCassationSendDate",
          succession_cassation_date AS "SuccessionCassationDate",
          succession_cassation_result AS "SuccessionCassationResult",
          C_CD.title AS "CollectionCourtDocument",
          collection_court_document_number AS "CollectionCourtDocumentNumber",
          collection_court_document_date AS "CollectionCourtDocumentDate",
          collection_court_title AS "CollectionCourtTitle",
          collection_court_title_genitive AS "CollectionCourtTitleGenitive",
          C_AR.title AS "CollectionCourtRegion",
          collection_court_address AS "CollectionCourtAddress",
          collection_court_receiver AS "CollectionCourtReceiver",
          collection_court_receiver_bank AS "CollectionCourtReceiverBank",
          collection_court_receiver_bank_city AS "CollectionCourtReceiverBankCity",
          collection_court_inn AS "CollectionCourtInn",
          collection_court_kpp AS "CollectionCourtKpp",
          collection_court_correspondent_account AS "CollectionCourtCorrespondentAccount",
          collection_court_account AS "CollectionCourtAccount",
          collection_court_bik AS "CollectionCourtBik",
          collection_court_oktmo AS "CollectionCourtOktmo",
          collection_court_kbk AS "CollectionCourtKbk",
          collection_court_phone AS "CollectionCourtPhone",
          collection_court_email AS "CollectionCourtEmail",
          collection_court_site AS "CollectionCourtSite",
          collection_send_date AS "CollectionSendDate",
          collection_case_number AS "CollectionCaseNumber",
          collection_judge AS "CollectionJudge",
          collection_contact_date AS "CollectionContactDate",
          collection_court_date AS "CollectionCourtDate",
          collection_result_date AS "CollectionResultDate",
          CR.title AS "CollectionCourtResult",
          collection_sum AS "CollectionSum",
          collection_is_main AS "CollectionIsMain",
          collection_is_recieved AS "CollectionIsRecieved",
          collection_legal_date AS "CollectionLegalDate",
          collection_document_get_date AS "CollectionDocumentGetDate",
          collection_cancel_date AS "CollectionCancelDate",
          collection_appeal_send_date AS "CollectionAppealSendDate",
          collection_appeal_date AS "CollectionAppealDate",
          collection_appeal_result AS "CollectionAppealResult",
          collection_cassation_send_date AS "CollectionCassationSendDate",
          collection_cassation_date AS "CollectionCassationDate",
          collection_cassation_result AS "CollectionCassationResult",
          collection_application_type_title AS "CollectionApplicationTypeTitle",
          collection_application_sum AS "CollectionApplicationSum",
          collection_application_tax AS "CollectionApplicationTax",
          executive_document_info AS "ExecutiveDocumentInfo",
          executive_osp_title AS "ExecutiveOspTitle",
          executive_osp_address AS "ExecutiveOspAddress",
          executive_osp_ufssp_title AS "ExecutiveOspUfsspTitle",
          executive_osp_phone AS "ExecutiveOspPhone",
          executive_bailiff_title AS "ExecutiveBailiffTitle",
          executive_bailiff_phone AS "ExecutiveBailiffPhone",
          executive_send_date AS "ExecutiveSendDate",
          executive_start_date AS "ExecutiveStartDate",
          executive_number AS "ExecutiveNumber",
          executive_other_info AS "ExecutiveOtherInfo",
          executive_replacement_send_date AS "ExecutiveReplacementSendDate",
          executive_replacement_date AS "ExecutiveReplacementDate",
          executive_request AS "ExecutiveRequest",
          executive_request_response AS "ExecutiveRequestResponse",
          executive_end_date AS "ExecutiveEndDate",
          executive_resend_date AS "ExecutiveReSendDate",
          executive_end_reason AS "ExecutiveEndReason",
          executive_restrict_date AS "ExecutiveRestrictDate",
          executive_restrict_end_date AS "ExecutiveRestrictEndDate",
          executive_appeal_send_date AS "ExecutiveAppealSendDate",
          executive_appeal_date AS "ExecutiveAppealDate",
          executive_appeal_result AS "ExecutiveAppealResult",
          comment_comment AS "CommentComment",
          interaction_limit_concent_date AS "InteractionLimitConcentDate",
          interaction_limit_agent_concent_date AS "InteractionLimitAgentConcentDate",
          interaction_limit_agent_title AS "InteractionLimitAgentTitle",
          interaction_limit_agent_birth_date AS "InteractionLimitAgentBirthDate",
          interaction_limit_agent_phone AS "InteractionLimitAgentPhone",
          interaction_limit_agent_address AS "InteractionLimitAgentAddress",
          interaction_limit_agent_email AS "InteractionLimitAgentEmail",
          interaction_limit_agent_lawyer AS "InteractionLimitAgentLawyer",
          interaction_limit_reject_date AS "InteractionLimitRejectDate",
          interaction_limit_agent_reject_date AS "InteractionLimitAgentRejectDate",
          interaction_limit_reject_cancel_date AS "InteractionLimitRejectCancelDate",
          interaction_limit_other_agent_date AS "InteractionLimitOtherAgentDate",
          interaction_limit_request AS "InteractionLimitRequest",
          interaction_limit_request_response AS "InteractionLimitRequestResponse",
          CASE
            WHEN
              COALESCE(TL.loan_credit_number, '') = '' OR
              TL.loan_credit_date IS NULL OR
              COALESCE(TL.client_first_name, '') = '' OR
              COALESCE(TL.client_second_name, '') = '' OR
              TL.client_birth_date IS NULL
            THEN 'error'
            WHEN
              TL.loan_id IS NULL AND
              TL.client_id IS NULL
            THEN 'no_match'
            WHEN
              TL.loan_id IS NULL AND
              TL.client_id IS NOT NULL
            THEN 'client_match'
            WHEN
              TL.loan_id IS NOT NULL AND
              LC.client_id IS NULL
            THEN 'loan_match'
            WHEN
              LC.loan_id IS NOT NULL AND
              LC.client_id IS NOT NULL
            THEN 'full_match'
          END AS "RowStatus",
          CASE
            WHEN
              COALESCE(TL.loan_credit_number, '') = '' OR
              TL.loan_credit_date IS NULL OR
              COALESCE(TL.client_first_name, '') = '' OR
              COALESCE(TL.client_second_name, '') = '' OR
              TL.client_birth_date IS NULL
            THEN false
            ELSE true
          END AS "CanSave",
          CASE
            WHEN
              TL.loan_id IS NULL AND
              TL.client_id IS NULL AND
              NOT (COALESCE(TL.loan_credit_number, '') = '' OR
              TL.loan_credit_date IS NULL OR
              COALESCE(TL.client_first_name, '') = '' OR
              COALESCE(TL.client_second_name, '') = '' OR
              TL.client_birth_date IS NULL)
            THEN true
            ELSE false
          END AS "ToSave"
        FROM
          collect.temp_loan TL
          LEFT JOIN collect.client_person CP USING(client_id)
          LEFT JOIN collect.address_region RA_AR ON RA_AR.address_region_id = TL.registration_address_region_id
          LEFT JOIN collect.address_region AA_AR ON AA_AR.address_region_id = TL.actual_address_region_id
          LEFT JOIN collect.address_region CS_AR ON CS_AR.address_region_id = TL.cession_address_region_id
          LEFT JOIN collect.address_region S_AR ON S_AR.address_region_id = TL.succession_court_address_region_id
          LEFT JOIN collect.address_region C_AR ON C_AR.address_region_id = TL.collection_court_address_region_id
          LEFT JOIN collect.address_region B_AR ON B_AR.address_region_id = TL.client_bankrupt_court_address_region_id
          LEFT JOIN collect.address_region J_AR ON J_AR.address_region_id = TL.client_jurisdiction_court_address_region_id
          LEFT JOIN collect.address_city_type RA_ACT ON RA_ACT.address_city_type_id = TL.registration_address_city_type_id
          LEFT JOIN collect.address_city_type AA_ACT ON AA_ACT.address_city_type_id = TL.actual_address_city_type_id
          LEFT JOIN collect.address_street_type RA_AST ON RA_AST.address_street_type_id = TL.registration_address_street_type_id
          LEFT JOIN collect.address_street_type AA_AST ON AA_AST.address_street_type_id = TL.actual_address_street_type_id
          LEFT JOIN collect.sell_result M_SR ON M_SR.sell_result_id = TL.movable_sell_result_id
          LEFT JOIN collect.sell_result R_SR ON R_SR.sell_result_id = TL.real_sell_result_id
          LEFT JOIN collect.cession_type CT USING(cession_type_id)
          LEFT JOIN collect.claimant_type CL_T USING(claimant_type_id)
          LEFT JOIN collect.claimant_type FCL_T ON TL.first_claimant_type_id = FCL_T.claimant_type_id
          LEFT JOIN collect.credit_type CRT USING(credit_type_id)
          LEFT JOIN collect.credit_line_type CRLT USING(credit_line_type_id)
          LEFT JOIN collect.credit_purpose CRP USING(credit_purpose_id)
          LEFT JOIN collect.credit_get_type CGT USING(credit_get_type_id)
          LEFT JOIN collect.role R USING(role_id)
          LEFT JOIN collect.user_info UI USING(user_id)
          LEFT JOIN collect.court_document S_CD ON S_CD.court_document_id = TL.succession_court_document_id
          LEFT JOIN collect.court_document C_CD ON C_CD.court_document_id = TL.collection_court_document_id
          LEFT JOIN collect.court_result CR USING(court_result_id)
          LEFT JOIN collect.loan L USING(loan_id)
          LEFT JOIN collect.loan_client LC USING(client_id, loan_id)
        ORDER BY temp_loan_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempLoanSaveSqlQuery">
      <Text>
        UPDATE
          collect.temp_loan TL
        SET
          to_save = COALESCE(T.to_save, false)
        FROM (
          SELECT
            unnest({TempLoanId}::bigint[]) AS temp_loan_id,
            unnest({ToSave}::boolean[]) AS to_save
          ) T
        WHERE
          TL.temp_loan_id = T.temp_loan_id;

        --удаление записей со статусом "error"
        DELETE FROM
          collect.temp_loan TL
        WHERE
          COALESCE(TL.loan_credit_number, '') = '' OR
          TL.loan_credit_date IS NULL OR
          COALESCE(TL.client_first_name, '') = '' OR
          COALESCE(TL.client_second_name, '') = '' OR
          TL.client_birth_date IS NULL;

        SELECT
          collect.temp_loan_save(TL.temp_loan_id, {VisibleColumns}::character varying[], {UserId}::smallint)
        FROM
          collect.temp_loan TL
        WHERE
          to_save
        ORDER BY temp_loan_id;

        DELETE FROM
          collect.temp_loan;

        ALTER SEQUENCE
          collect.temp_loan_id_seq
        RESTART WITH 1;
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===ИМПОРТ ПЛАТЕЖЕЙ==========================================-->
    <!--============================================================-->
    <SqlQuery Name="TempPaymentClearSqlQuery">
      <Text>
        DELETE FROM
          collect.temp_payment;

        ALTER SEQUENCE
          collect.temp_payment_id_seq
        RESTART WITH 1;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempPaymentInsertFromExcelSqlQuery">
      <Text>
        INSERT INTO collect.temp_payment(
          payment_client_title,
          payment_client_first_name,
          payment_client_second_name,
          payment_client_third_name,
          payment_credit_number,
          payment_succession_document_number,
          payment_executive_number,
          payment_payer_title,
          payment_number,
          payment_comment,
          payment_date,
          payment_sum)
        SELECT
          trim(client_title),
          trim(client_first_name),
          trim(client_second_name),
          trim(client_third_name),
          trim(credit_number),
          trim(succession_document_number),
          trim(executive_number),
          trim(payer_title),
          trim(payment_number),
          trim(payment_comment),
          payment_date,
          ROUND(CASE WHEN payment_sum >= 0 THEN payment_sum ELSE null END, 2)
        FROM (
          SELECT
            unnest({ClientTitle}::character varying[]) AS client_title,
            unnest({ClientFirstName}::character varying[]) AS client_first_name,
            unnest({ClientSecondName}::character varying[]) AS client_second_name,
            unnest({ClientThirdName}::character varying[]) AS client_third_name,
            unnest({CreditNumber}::character varying[]) AS credit_number,
            unnest({SuccessionDocumentNumber}::character varying[]) AS succession_document_number,
            unnest({ExecutiveNumber}::character varying[]) AS executive_number,
            unnest({PayerTitle}::character varying[]) AS payer_title,
            unnest({PaymentNumber}::character varying[]) AS payment_number,
            unnest({PaymentComment}::character varying[]) AS payment_comment,
            unnest({PaymentDate}::date[]) AS payment_date,
            unnest({PaymentSum}::numeric[]) AS payment_sum) T;

        SELECT collect.temp_payment_check_error('excel') AS "ErrorText";
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempPaymentInsertFromTxtSqlQuery">
      <Text>
        INSERT INTO collect.temp_payment(
          payment_payer_title,
          payment_number,
          payment_comment,
          payment_date,
          payment_sum)
        SELECT
          trim(payer_title),
          trim(payment_number),
          trim(payment_comment),
          payment_date,
          ROUND(CASE WHEN payment_sum >= 0 THEN payment_sum ELSE null END, 2)
        FROM (
          SELECT
            unnest({PayerTitle}::character varying[]) AS payer_title,
            unnest({PaymentNumber}::character varying[]) AS payment_number,
            unnest({PaymentComment}::character varying[]) AS payment_comment,
            unnest({PaymentDate}::date[]) AS payment_date,
            unnest({PaymentSum}::numeric[]) AS payment_sum) T;

        SELECT collect.temp_payment_check_error('txt') AS "ErrorText";
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempPaymentParseUpdateSqlQuery">
      <Text>
       WITH client_person_info AS (
          SELECT
            DISTINCT ON (CP.client_id)
            CP.client_id,
            CASE
              WHEN COALESCE(CP.first_name, '') = '' THEN NULL::character varying
              ELSE btrim(initcap(CP.first_name))
            END AS first_name,
            CASE
              WHEN COALESCE(CP.second_name, '') = '' THEN NULL::character varying
              ELSE btrim(initcap(CP.second_name))
            END AS second_name,
            CASE
              WHEN COALESCE(CP.third_name, '') = '' THEN NULL::character varying
              ELSE btrim(initcap(CP.third_name))
            END AS third_name,
            CP.birth_date
          FROM
            collect.client C
            JOIN collect.client_person CP USING(client_id)
          WHERE
            NOT C.deleted
          ORDER BY CP.client_id
        ), client_info AS (
          SELECT
            client_id,
            collect.get_client_title(CPI.first_name, CPI.second_name, CPI.third_name) AS full_title,
            collect.get_client_title(CPI.first_name, CPI.second_name, CPI.third_name, true) AS short_title
          FROM
            client_person_info CPI
        ), client_similarity AS (
            SELECT
              DISTINCT ON (TP.temp_payment_id)
              TP.temp_payment_id,
              CI.full_title AS payment_client_title,
              GREATEST(word_similarity(CI.full_title, payment_comment), word_similarity(CI.short_title, payment_comment)) AS client_title_similarity,
              CP.first_name AS payment_client_first_name,
              CP.second_name AS payment_client_second_name,
              CP.third_name AS payment_client_third_name
            FROM
              collect.temp_payment TP
              LEFT JOIN client_info CI ON true
              LEFT JOIN collect.client_person CP ON CP.client_id = CI.client_id
            WHERE
              COALESCE(TP.payment_client_title, '') = '' AND
              GREATEST(word_similarity(CI.full_title, payment_comment), word_similarity(CI.short_title, payment_comment)) > 0.7
            ORDER BY TP.temp_payment_id, GREATEST(word_similarity(CI.full_title, payment_comment), word_similarity(CI.short_title, payment_comment)) DESC, CI.client_id
          )
          UPDATE
            collect.temp_payment TP
          SET
            payment_client_title = CASE WHEN COALESCE(TP.payment_client_title, '') = '' THEN S.payment_client_title ELSE TP.payment_client_title END,
            client_title_similarity = CASE WHEN COALESCE(TP.payment_client_title, '') = '' THEN S.client_title_similarity ELSE TP.client_title_similarity END,
            payment_client_first_name = CASE WHEN COALESCE(TP.payment_client_first_name, '') = '' THEN S.payment_client_first_name ELSE TP.payment_client_first_name END,
            payment_client_second_name = CASE WHEN COALESCE(TP.payment_client_second_name, '') = '' THEN S.payment_client_second_name ELSE TP.payment_client_second_name END,
            payment_client_third_name = CASE WHEN COALESCE(TP.payment_client_third_name, '') = '' THEN S.payment_client_third_name ELSE TP.payment_client_third_name END
          FROM
            client_similarity S
          WHERE
            TP.temp_payment_id = S.temp_payment_id;

          WITH credit_number_similarity AS (
            SELECT
              DISTINCT ON (TP.temp_payment_id)
              TP.temp_payment_id,
              L.credit_number AS payment_credit_number,
              word_similarity(L.credit_number, payment_comment) AS credit_number_similarity
            FROM
              collect.temp_payment TP
              LEFT JOIN collect.loan L ON true
            WHERE
              COALESCE(TP.payment_credit_number, '') = '' AND
              NOT L.deleted AND
              length(COALESCE(trim(L.credit_number), '')) >= 5 AND
              word_similarity(L.credit_number, payment_comment) >= 0.9
            ORDER BY TP.temp_payment_id, length(L.credit_number) DESC, word_similarity(L.credit_number, payment_comment) DESC, L.loan_id
          )
          UPDATE
            collect.temp_payment TP
          SET
            payment_credit_number = CASE WHEN COALESCE(TP.payment_credit_number, '') = '' THEN S.payment_credit_number ELSE TP.payment_credit_number END,
            credit_number_similarity = CASE WHEN COALESCE(TP.payment_credit_number, '') = '' THEN S.credit_number_similarity ELSE TP.credit_number_similarity END
          FROM
            credit_number_similarity S
          WHERE
            TP.temp_payment_id = S.temp_payment_id;

          WITH succession_document_number_similarity AS (
            SELECT
              DISTINCT ON (TP.temp_payment_id)
              TP.temp_payment_id,
              LCS.document_number AS payment_succession_document_number,
              word_similarity(LCS.document_number, payment_comment) AS succession_document_number_similarity
            FROM
              collect.temp_payment TP
              LEFT JOIN collect.loan_client_succession LCS ON true
              LEFT JOIN collect.loan_client LC ON LCS.loan_client_id = LC.loan_client_id
              LEFT JOIN collect.loan L ON L.loan_id = LC.loan_id
            WHERE
              COALESCE(TP.payment_succession_document_number, '') = '' AND
              NOT L.deleted AND
              length(COALESCE(trim(LCS.document_number), '')) >= 5 AND
              word_similarity(LCS.document_number, payment_comment) >= 0.9
            ORDER BY TP.temp_payment_id, length(LCS.document_number) DESC, word_similarity(LCS.document_number, payment_comment) DESC, LCS.loan_client_succession_id
          )
          UPDATE
            collect.temp_payment TP
          SET
            payment_succession_document_number = CASE WHEN COALESCE(TP.payment_succession_document_number, '') = '' THEN S.payment_succession_document_number ELSE TP.payment_succession_document_number END,
            succession_document_number_similarity = CASE WHEN COALESCE(TP.payment_succession_document_number, '') = '' THEN S.succession_document_number_similarity ELSE TP.succession_document_number_similarity END
          FROM
            succession_document_number_similarity S
          WHERE
            TP.temp_payment_id = S.temp_payment_id;

          WITH executive_number_similarity AS (
            SELECT
              DISTINCT ON (TP.temp_payment_id)
              TP.temp_payment_id,
              LCE.number AS payment_executive_number,
              word_similarity(LCE.number, payment_comment) AS executive_number_similarity
            FROM
              collect.temp_payment TP
              LEFT JOIN collect.loan_client_executive LCE ON true
              LEFT JOIN collect.loan_client_collection LCC ON LCC.loan_client_collection_id = LCE.loan_client_collection_id
              LEFT JOIN collect.loan_client LC ON LCC.loan_client_id = LC.loan_client_id
              LEFT JOIN collect.loan L ON L.loan_id = LC.loan_id
            WHERE
              COALESCE(TP.payment_executive_number, '') = '' AND
              NOT L.deleted AND
              length(COALESCE(trim(LCE.number), '')) >= 5 AND
              word_similarity(LCE.number, payment_comment) >= 0.9
            ORDER BY TP.temp_payment_id, length(LCE.number) DESC, word_similarity(LCE.number, payment_comment) DESC, LCE.loan_client_executive_id
          )
          UPDATE
            collect.temp_payment TP
          SET
            payment_executive_number = CASE WHEN COALESCE(TP.payment_executive_number, '') = '' THEN S.payment_executive_number ELSE TP.payment_executive_number END,
            executive_number_similarity = CASE WHEN COALESCE(TP.payment_executive_number, '') = '' THEN S.executive_number_similarity ELSE TP.executive_number_similarity END
          FROM
            executive_number_similarity S
          WHERE
            TP.temp_payment_id = S.temp_payment_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempPaymentAutoParseUpdateSqlQuery">
      <Text>
        UPDATE
          collect.temp_payment TP
        SET
          payment_client_first_name = CASE WHEN COALESCE(TP.payment_client_first_name, '') = '' THEN T.payment_client_first_name ELSE TP.payment_client_first_name END,
          payment_client_second_name = CASE WHEN COALESCE(TP.payment_client_second_name, '') = '' THEN T.payment_client_second_name ELSE TP.payment_client_second_name END,
          payment_client_third_name = CASE WHEN COALESCE(TP.payment_client_third_name, '') = '' THEN T.payment_client_third_name ELSE TP.payment_client_third_name END
        FROM (
          WITH A AS (
            SELECT
              temp_payment_id,
              regexp_split_to_array(payment_client_title,'\s+') AS client_title
            FROM
              collect.temp_payment
            )
          SELECT
            temp_payment_id,
            client_title[1] || CASE WHEN position('(' IN client_title[2]) > 0 THEN  ' ' || client_title[2] ELSE '' END AS payment_client_first_name,
            CASE WHEN position('(' IN client_title[2]) > 0 THEN client_title[3] ELSE client_title[2] END AS payment_client_second_name,
            CASE WHEN position('(' IN client_title[2]) > 0 THEN COALESCE(client_title[4], '') || COALESCE(' ' || client_title[5], '') ELSE COALESCE(client_title[3], '') || COALESCE(' ' || client_title[4], '') END AS payment_client_third_name
          FROM
            A
          ) T
        WHERE
          COALESCE((SELECT auto_parse FROM collect.excel_import_column WHERE "name" = 'payment_client_title'), false) AND
          T.temp_payment_id = TP.temp_payment_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempPaymentReferencesUpdateSqlQuery">
      <Text>
        UPDATE
          collect.temp_payment TP
        SET
          loan_client_payment_id = T.loan_client_payment_id,
          loan_client_id = T.loan_client_id,
          client_id = T.client_id,
          loan_id = T.loan_id,
          client_title_similarity = 1,
          loan_similarity = 1
        FROM (
          SELECT
            LCP.loan_client_payment_id,
            LC.loan_client_id,
            LC.client_id,
            LC.loan_id,
            trim(LCP.number) AS payment_number
          FROM
            collect.loan_client_payment LCP
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN collect.loan L USING(loan_id)
          WHERE
            NOT L.deleted
          ORDER BY loan_client_payment_id DESC
          ) T
        WHERE
          COALESCE(TP.payment_number, '') != '' AND
          lower(TP.payment_number) = lower(T.payment_number);

        UPDATE
          collect.temp_payment TP
        SET
          loan_id = T.loan_id,
          loan_similarity = COALESCE(credit_number_similarity, 1)
        FROM (
          SELECT
            L.loan_id,
            trim(L.credit_number) AS payment_credit_number
          FROM
            collect.loan L
          WHERE
            NOT L.deleted
          ORDER BY loan_id DESC
          ) T
        WHERE
          TP.loan_id IS NULL AND
          COALESCE(TP.payment_credit_number, '') != '' AND
          lower(TP.payment_credit_number) = lower(T.payment_credit_number);

        UPDATE
          collect.temp_payment TP
        SET
          loan_id = T.loan_id,
          loan_similarity = COALESCE(succession_document_number_similarity, 1)
        FROM (
          SELECT
            L.loan_id,
            trim(LCS.document_number) AS payment_succession_document_number
          FROM
            collect.loan_client_succession LCS
            LEFT JOIN collect.loan_client USING(loan_client_id)
            LEFT JOIN collect.loan L USING(loan_id)
          WHERE
            NOT L.deleted
          ORDER BY loan_id DESC, loan_client_succession_id DESC
          ) T
        WHERE
          TP.loan_id IS NULL AND
          COALESCE(TP.payment_succession_document_number, '') != '' AND
          lower(TP.payment_succession_document_number) = lower(T.payment_succession_document_number);

        UPDATE
          collect.temp_payment TP
        SET
          loan_id = T.loan_id,
          loan_similarity = COALESCE(executive_number_similarity, 1)
        FROM (
          SELECT
            L.loan_id,
            trim(LCE.number) AS payment_executive_number
          FROM
            collect.loan_client_executive LCE
            LEFT JOIN collect.loan_client_collection USING(loan_client_collection_id)
            LEFT JOIN collect.loan_client USING(loan_client_id)
            LEFT JOIN collect.loan L USING(loan_id)
          WHERE
            NOT L.deleted
          ORDER BY loan_id DESC, loan_client_executive_id DESC
          ) T
        WHERE
          TP.loan_id IS NULL AND
          COALESCE(TP.payment_executive_number, '') != '' AND
          lower(TP.payment_executive_number) = lower(T.payment_executive_number);

        UPDATE
          collect.temp_payment TP
        SET
          client_id = T.client_id,
          loan_client_id = T.loan_client_id,
          client_title_similarity = 1
        FROM (
          SELECT
            MAX(LC.loan_client_id) AS loan_client_id,
            MAX(LC.client_id) AS client_id,
            LC.loan_id
          FROM
            collect.loan_client LC
            LEFT JOIN collect.loan L USING(loan_id)
          WHERE
            NOT L.deleted
          GROUP BY LC.loan_id
          HAVING count(*) = 1
          ) T
        WHERE
          TP.loan_client_id IS NULL AND
          TP.loan_id IS NOT NULL AND
          TP.loan_id = T.loan_id;

        UPDATE
          collect.temp_payment TP
        SET
          client_id = T.client_id,
          client_title_similarity = COALESCE(client_title_similarity, 1)
        FROM (
          SELECT
            CP.client_id,
            trim(CP.first_name) AS payment_client_first_name,
            trim(CP.second_name) AS payment_client_second_name,
            trim(CP.third_name) AS payment_client_third_name,
            LC.loan_ids
          FROM
            collect.client_person CP
            JOIN collect.client C USING(client_id)
            LEFT JOIN (SELECT array_agg(loan_id) AS loan_ids, client_id FROM collect.loan_client LEFT JOIN collect.loan L USING(loan_id) WHERE NOT L.deleted GROUP BY client_id) LC USING(client_id)
          WHERE
            NOT C.deleted
          ORDER BY client_id DESC
          ) T
        WHERE
          TP.client_id IS NULL AND
          (TP.loan_id IS NULL OR TP.loan_id = ANY(T.loan_ids)) AND
          COALESCE(TP.payment_client_first_name, '') != '' AND
          COALESCE(TP.payment_client_second_name, '') != '' AND
          COALESCE(TP.payment_client_third_name, '') != '' AND
          lower(TP.payment_client_first_name) = lower(T.payment_client_first_name) AND
          lower(TP.payment_client_second_name) = lower(T.payment_client_second_name) AND
          lower(TP.payment_client_third_name) = lower(T.payment_client_third_name);

        UPDATE
          collect.temp_payment TP
        SET
          loan_client_id = T.loan_client_id
        FROM (
          SELECT
            LC.loan_client_id,
            LC.loan_id,
            LC.client_id
          FROM
            collect.loan_client LC
            LEFT JOIN collect.loan L USING(loan_id)
          WHERE
            NOT L.deleted
          ORDER BY loan_client_id DESC
          ) T
        WHERE
          TP.loan_client_id IS NULL AND
          TP.loan_id IS NOT NULL AND
          TP.client_id IS NOT NULL AND
          TP.loan_id = T.loan_id AND
          TP.client_id = T.client_id;

        WITH client_info AS (
          SELECT
            client_id,
            collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS full_title,
            collect.get_client_title(CP.first_name, CP.second_name, CP.third_name, true) AS short_title
          FROM
            collect.client C
            JOIN collect.client_person CP USING(client_id)
          WHERE
            NOT C.deleted
        ), payer_title_similarity AS (
          SELECT
            DISTINCT ON (TP.temp_payment_id)
            TP.temp_payment_id,
            CI.client_id AS payer_client_id,
            GREATEST(word_similarity(CI.full_title, payment_payer_title), word_similarity(CI.short_title, payment_payer_title)) AS payer_title_similarity
          FROM
            collect.temp_payment TP
            LEFT JOIN client_info CI ON true
            LEFT JOIN collect.client_person CP ON CP.client_id = CI.client_id
          WHERE
            TP.loan_client_payment_id IS NULL AND
            COALESCE(TP.payment_payer_title, '') != '' AND
            GREATEST(word_similarity(CI.full_title, payment_payer_title), word_similarity(CI.short_title, payment_payer_title)) > 0.85
          ORDER BY TP.temp_payment_id, GREATEST(word_similarity(CI.full_title, payment_payer_title), word_similarity(CI.short_title, payment_payer_title)) DESC, CI.client_id
        )
        UPDATE
          collect.temp_payment TP
        SET
          payer_client_id = S.payer_client_id,
          payer_title_similarity = S.payer_title_similarity
        FROM
          payer_title_similarity S
        WHERE
          TP.temp_payment_id = S.temp_payment_id;

        UPDATE
          collect.temp_payment
        SET
          client_title_similarity = CASE WHEN client_id IS NULL THEN 1 ELSE COALESCE(client_title_similarity, 1) END,
          payer_title_similarity = COALESCE(payer_title_similarity, 1),
          loan_similarity = CASE WHEN loan_id IS NULL THEN 1 ELSE COALESCE(loan_similarity, 1) END,
          to_save = (loan_client_id IS NOT NULL AND loan_client_payment_id IS NULL);
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempPaymentSelectSqlQuery">
      <Text>
        SELECT
          TP.temp_payment_id AS "TempPaymentId",
          TP.loan_client_payment_id AS "LoanClientPaymentId",
          TP.loan_id AS "LoanId",
          TP.client_id AS "ClientId",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "ClientTitle",
          L.credit_number AS "CreditNumber",
          CASE
            WHEN COALESCE(TP.payer_client_id, LCP.payer_client_id) IS NULL THEN TP.payment_payer_title
            ELSE collect.get_client_title(CP_P.first_name, CP_P.second_name, CP_P.third_name)
          END AS "PayerTitle",
          TP.payment_date AS "PaymentDate",
          TP.payment_sum AS "PaymentSum",
          TP.payment_number AS "PaymentNumber",
          TP.payment_comment AS "PaymentComment",
          CASE WHEN client_title_similarity = 1 THEN NULL ELSE 'Точность совпадения ' || ROUND(client_title_similarity * 100, 2) || '%' END AS "ClientSimilarityText",
          CASE WHEN payer_title_similarity = 1 THEN NULL ELSE 'Точность совпадения ' || ROUND(payer_title_similarity * 100, 2) || '%' END AS "PayerSimilarityText",
          CASE WHEN loan_similarity = 1 THEN NULL ELSE 'Точность совпадения ' || ROUND(loan_similarity * 100, 2) || '%' END AS "LoanSimilarityText",
          CASE
            WHEN
              TP.loan_client_payment_id IS NOT NULL
            THEN 'payment_exists'
            WHEN
              TP.loan_client_id IS NULL AND
              TP.loan_id IS NULL AND
              TP.client_id IS NULL
            THEN 'no_match'
            WHEN
              TP.loan_client_id IS NULL AND
              TP.loan_id IS NULL AND
              TP.client_id IS NOT NULL
            THEN 'client_match'
            WHEN
              TP.loan_client_id IS NULL AND
              TP.loan_id IS NOT NULL AND
              TP.client_id IS NULL
            THEN 'loan_match'
            WHEN
              TP.loan_client_id IS NOT NULL
            THEN 'full_match'
          END AS "RowStatus",
          CASE
            WHEN
              TP.loan_client_payment_id IS NULL AND
              TP.loan_client_id IS NOT NULL
            THEN true
            ELSE false
          END AS "CanSave",
          to_save AS "ToSave"
        FROM
          collect.temp_payment TP
          LEFT JOIN collect.loan_client_payment LCP USING(loan_client_payment_id)
          LEFT JOIN collect.loan_client LC ON COALESCE(TP.loan_client_id, LCP.loan_client_id) = LC.loan_client_id
          LEFT JOIN collect.client_person CP ON COALESCE(TP.client_id, LC.client_id) = CP.client_id
          LEFT JOIN collect.client_person CP_P ON COALESCE(TP.payer_client_id, LCP.payer_client_id) = CP_P.client_id
          LEFT JOIN collect.loan L ON COALESCE(TP.loan_id, LC.loan_id) = L.loan_id
        ORDER BY temp_payment_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempPaymentToSaveUpdateSqlQuery">
      <Text>
        UPDATE
          collect.temp_payment TP
        SET
          to_save = COALESCE(T.to_save, false)
        FROM (
          SELECT
            unnest({ToSave}::boolean[]) AS to_save,
            unnest({TempPaymentId}::bigint[]) AS temp_payment_id
          ) T
        WHERE
          TP.temp_payment_id = T.temp_payment_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempPaymentUpdateSqlQuery">
      <Text>
        UPDATE
          collect.temp_payment TP
        SET
          client_id = T.client_id,
          loan_id = T.loan_id,
          loan_client_id = T.loan_client_id,
          client_title_similarity = 1,
          loan_similarity = 1,
          to_save = true
        FROM (
          SELECT
            loan_client_id,
            loan_id,
            client_id
          FROM
            collect.loan_client
          WHERE
            loan_id = {LoanId} AND
            client_id = {ClientId}
          ) T
        WHERE
          TP.temp_payment_id = {TempPaymentId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempPaymentSaveSqlQuery">
      <Text>
        SELECT
          collect.loan_client_payment_insert(
          TP.loan_client_id,
          TP.payer_client_id,
          CASE WHEN TP.payer_client_id IS NULL THEN TP.payment_payer_title ELSE NULL END,
          TP.payment_date,
          TP.payment_sum,
          TP.payment_number,
          TP.payment_comment,
          {UserId}::smallint,
          true)
        FROM
          collect.temp_payment TP
        WHERE
          to_save;

        DELETE FROM
          collect.temp_payment;

        ALTER SEQUENCE
          collect.temp_payment_id_seq
        RESTART WITH 1;
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===ИМПОРТ СУДОВ ИЗ EXCEL====================================-->
    <!--============================================================-->

    <SqlQuery Name="TempCourtAddressSelectSqlQuery">
      <Text>
        WITH address_index_position AS (
          SELECT
            temp_court_id,
            COALESCE(position(substring(court_jurisdiction_address, '\m\d{6}') in court_jurisdiction_address), 0) AS jur_index_position,
            court_jurisdiction_address
          FROM
            collect.temp_court
        ), address_string_formatted AS (
          SELECT
            temp_court_id,
            CASE
              WHEN jur_index_position > 0
              THEN
                CASE
                  WHEN length(court_jurisdiction_address) = jur_index_position + 5
                  THEN court_jurisdiction_address
                  ELSE
                    CASE
                      WHEN substr(court_jurisdiction_address, jur_index_position + 6, 1) = ','
                      THEN court_jurisdiction_address
                      ELSE substr(court_jurisdiction_address, 1, jur_index_position + 5) || ',' || substr(court_jurisdiction_address, jur_index_position + 6)
                    END
                END
              ELSE court_jurisdiction_address
            END AS court_jurisdiction_address
          FROM
            address_index_position
        )
        SELECT
          temp_court_id AS "TempId",
          CASE
            WHEN {AddressType} = 'court_jurisdiction_address' THEN court_jurisdiction_address
          END AS "AddressString"
        FROM
          address_string_formatted;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempCourtAddressUpdateSqlQuery">
      <Text>
        UPDATE
          collect.temp_court TC
        SET
          court_jurisdiction_address_index = CASE WHEN COALESCE(court_jurisdiction_address_index, '') = '' THEN trim(T.index) ELSE court_jurisdiction_address_index END,
          court_jurisdiction_address_region = CASE WHEN COALESCE(court_jurisdiction_address_region, '') = '' THEN trim(T.region) ELSE court_jurisdiction_address_region END,
          court_jurisdiction_address_district = CASE WHEN COALESCE(court_jurisdiction_address_district, '') = '' THEN trim(T.district) ELSE court_jurisdiction_address_district END,
          court_jurisdiction_address_city = CASE WHEN COALESCE(court_jurisdiction_address_city, '') = '' THEN trim(T.city) ELSE court_jurisdiction_address_city END,
          court_jurisdiction_address_city_type = CASE WHEN COALESCE(court_jurisdiction_address_city_type, '') = '' THEN trim(T.city_type) ELSE court_jurisdiction_address_city_type END,
          court_jurisdiction_address_street = CASE WHEN COALESCE(court_jurisdiction_address_street, '') = '' THEN trim(T.street) ELSE court_jurisdiction_address_street END,
          court_jurisdiction_address_street_type = CASE WHEN COALESCE(court_jurisdiction_address_street_type, '') = '' THEN trim(T.street_type) ELSE court_jurisdiction_address_street_type END,
          court_jurisdiction_address_building = CASE WHEN COALESCE(court_jurisdiction_address_building, '') = '' THEN trim(T.house) ELSE court_jurisdiction_address_building END,
          court_jurisdiction_address_block = CASE WHEN COALESCE(court_jurisdiction_address_block, '') = '' THEN trim(T.block) ELSE court_jurisdiction_address_block END,
          court_jurisdiction_address_structure = CASE WHEN COALESCE(court_jurisdiction_address_structure, '') = '' THEN trim(T.structure) ELSE court_jurisdiction_address_structure END,
          court_jurisdiction_address_flat = CASE WHEN COALESCE(court_jurisdiction_address_flat, '') = '' THEN trim(T.flat) ELSE court_jurisdiction_address_flat END
        FROM (
          SELECT
            unnest({TempId}::bigint[]) AS temp_court_id,
            unnest({Index}::character varying[]) AS index,
            unnest({Region}::character varying[]) AS region,
            unnest({District}::character varying[]) AS district,
            unnest({City}::character varying[]) AS city,
            unnest({CityType}::character varying[]) AS city_type,
            unnest({Street}::character varying[]) AS street,
            unnest({StreetType}::character varying[]) AS street_type,
            unnest({House}::character varying[]) AS house,
            unnest({Block}::character varying[]) AS block,
            unnest({Structure}::character varying[]) AS structure,
            unnest({Flat}::character varying[]) AS flat) T
        WHERE
          {AddressType} = 'court_jurisdiction_address' AND
          T.temp_court_id = TC.temp_court_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempCourtReferencesUpdateSqlQuery">
      <Text>
        UPDATE
          collect.temp_court TC
        SET
          court_address_region_id = T.court_address_region_id
        FROM (
          SELECT
            ARA.address_region_id AS court_address_region_id,
            ARA.title AS court_address_region
          FROM
            collect.address_region_alternative ARA
          ORDER BY address_region_id DESC) T
        WHERE
          COALESCE(TC.court_address_region, '') != '' AND
          TC.court_address_region = T.court_address_region;

        UPDATE
          collect.temp_court TC
        SET
          court_address_region_id = T.court_address_region_id
        FROM (
          SELECT
            AR.address_region_id AS court_address_region_id,
            AR.title AS court_address_region
          FROM
            collect.address_region AR
          ORDER BY address_region_id DESC) T
        WHERE
          COALESCE(TC.court_address_region, '') != '' AND
          TC.court_address_region_id IS NULL AND
          (TC.court_address_region ILIKE '%' || T.court_address_region || '%' OR
          T.court_address_region ILIKE '%' || TC.court_address_region || '%');

        UPDATE
          collect.temp_court TC
        SET
          court_jurisdiction_address_region_id = T.court_jurisdiction_address_region_id
        FROM (
          SELECT
            ARA.address_region_id AS court_jurisdiction_address_region_id,
            ARA.title AS court_jurisdiction_address_region
          FROM
            collect.address_region_alternative ARA
          ORDER BY address_region_id DESC) T
        WHERE
          COALESCE(TC.court_jurisdiction_address_region, '') != '' AND
          TC.court_jurisdiction_address_region = T.court_jurisdiction_address_region;

        UPDATE
          collect.temp_court TC
        SET
          court_jurisdiction_address_region_id = T.court_jurisdiction_address_region_id
        FROM (
          SELECT
            AR.address_region_id AS court_jurisdiction_address_region_id,
            AR.title AS court_jurisdiction_address_region
          FROM
            collect.address_region AR
          ORDER BY address_region_id DESC) T
        WHERE
          COALESCE(TC.court_jurisdiction_address_region, '') != '' AND
          TC.court_jurisdiction_address_region_id IS NULL AND
          (TC.court_jurisdiction_address_region ILIKE '%' || T.court_jurisdiction_address_region || '%' OR
          T.court_jurisdiction_address_region ILIKE '%' || TC.court_jurisdiction_address_region || '%');

        UPDATE
          collect.temp_court TC
        SET
          court_jurisdiction_address_city_type_id = T.court_jurisdiction_address_city_type_id
        FROM (
          SELECT
            address_city_type_id AS court_jurisdiction_address_city_type_id,
            title AS court_jurisdiction_address_city_type,
            string_to_array(alternative_values, ';')::character varying[] AS city_type_alternative
          FROM
            collect.address_city_type
          ORDER BY address_city_type_id DESC) T
        WHERE
          COALESCE(TC.court_jurisdiction_address_city_type, '') != '' AND
          (lower(TC.court_jurisdiction_address_city_type) = ANY(city_type_alternative) OR
          lower(TC.court_jurisdiction_address_city_type) = lower(T.court_jurisdiction_address_city_type));

        UPDATE
          collect.temp_court TC
        SET
          court_jurisdiction_address_street_type_id = T.court_jurisdiction_address_street_type_id
        FROM (
          SELECT
            address_street_type_id AS court_jurisdiction_address_street_type_id,
            title AS court_jurisdiction_address_street_type,
            string_to_array(alternative_values, ';')::character varying[] AS street_type_alternative
          FROM
            collect.address_street_type
          ORDER BY address_street_type_id DESC) T
        WHERE
          COALESCE(TC.court_jurisdiction_address_street_type, '') != '' AND
          (lower(TC.court_jurisdiction_address_street_type) = ANY(street_type_alternative) OR
          lower(TC.court_jurisdiction_address_street_type) = lower(T.court_jurisdiction_address_street_type));

        UPDATE
          collect.temp_court TC
        SET
          court_jurisdiction_address_district_id = address_district_id
      FROM
          collect.address_district
      WHERE
        COALESCE(court_jurisdiction_address_district, '') != '' AND
        lower(court_jurisdiction_address_district) = lower(title);

        UPDATE
          collect.temp_court TC
        SET
          court_jurisdiction_address_city_id = address_city_id
        FROM
          collect.address_city
        WHERE
          COALESCE(court_jurisdiction_address_city, '') != '' AND
          lower(court_jurisdiction_address_city) = lower(title);

        UPDATE
          collect.temp_court TC
        SET
          court_jurisdiction_address_street_id = address_street_id
        FROM
          collect.address_street
        WHERE
          COALESCE(court_jurisdiction_address_street, '') != '' AND
          lower(court_jurisdiction_address_street) = lower(title);

        UPDATE
          collect.temp_court TC
        SET
          court_id = C.court_id
        FROM (
          SELECT
            court_id,
            trim(title) AS court_title
          FROM
            collect.court
          ORDER BY court_id DESC) C
        WHERE
          TC.court_id IS NULL AND
          COALESCE(TC.court_title, '') != '' AND
          lower(TC.court_title) = lower(C.court_title);

        UPDATE
          collect.temp_court TC
        SET
          court_jurisdiction_address_id = A.address_id
        FROM
          collect.court_address CA
          JOIN collect.address A USING(address_id)
          LEFT JOIN collect.get_address_string(address_id) GAS USING(address_id)
        WHERE
          CA.court_id = TC.court_id AND
          ((
            (NOT collect.not_equals(A.address_index, court_jurisdiction_address_index) OR similarity(A.address_index, court_jurisdiction_address_index) IS NOT DISTINCT FROM 1) AND
            A.address_region_id IS NOT DISTINCT FROM court_jurisdiction_address_region_id AND
            A.address_district_id IS NOT DISTINCT FROM court_jurisdiction_address_district_id AND
            (NOT collect.not_equals(A.address_city_district, court_jurisdiction_address_city_district) OR similarity(A.address_city_district, court_jurisdiction_address_city_district) IS NOT DISTINCT FROM 1) AND
            A.address_city_type_id IS NOT DISTINCT FROM court_jurisdiction_address_city_type_id AND
            A.address_city_id IS NOT DISTINCT FROM court_jurisdiction_address_city_id AND
            A.address_street_type_id IS NOT DISTINCT FROM court_jurisdiction_address_street_type_id AND
            A.address_street_id IS NOT DISTINCT FROM court_jurisdiction_address_street_id AND
            (NOT collect.not_equals(A.address_building, court_jurisdiction_address_building) OR similarity(A.address_building, court_jurisdiction_address_building) IS NOT DISTINCT FROM 1) AND
            (NOT collect.not_equals(A.address_block, court_jurisdiction_address_block) OR similarity(A.address_block, court_jurisdiction_address_block) IS NOT DISTINCT FROM 1) AND
            (NOT collect.not_equals(A.address_structure, court_jurisdiction_address_structure) OR similarity(A.address_structure, court_jurisdiction_address_structure) IS NOT DISTINCT FROM 1) AND
            (NOT collect.not_equals(A.address_flat, court_jurisdiction_address_flat) OR similarity(A.address_flat, court_jurisdiction_address_flat) IS NOT DISTINCT FROM 1)
          ) OR
          (
            court_jurisdiction_address IS NOT NULL AND
            similarity(CASE WHEN COALESCE(A.address_string,'') = '' THEN GAS.address_string ELSE A.address_string END, court_jurisdiction_address) IS NOT DISTINCT FROM 1
          ));
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempCourtSelectSqlQuery">
      <Text>
        SELECT
          TC.temp_court_id AS "TempCourtId",
          TC.court_title AS "CourtTitle",
          TC.court_title_genitive AS "CourtTitleGenitive",
          TC.court_address_region AS "CourtAddressRegion",
          TC.court_address AS "CourtAddress",
          TC.court_jurisdiction_address AS "JurisdictionAddress",
          TC.court_jurisdiction_address_index AS "JurisdictionAddressIndex",
          RA_AR.title AS "JurisdictionAddressRegion",
          TC.court_jurisdiction_address_district AS "JurisdictionAddressDistrict",
          RA_ACT.title AS "JurisdictionAddressCityType",
          TC.court_jurisdiction_address_city AS "JurisdictionAddressCity",
          TC.court_jurisdiction_address_city_district AS "JurisdictionAddressCityDistrict",
          RA_AST.title AS "JurisdictionAddressStreetType",
          TC.court_jurisdiction_address_street AS "JurisdictionAddressStreet",
          TC.court_jurisdiction_address_building AS "JurisdictionAddressBuilding",
          TC.court_jurisdiction_address_block AS "JurisdictionAddressBlock",
          TC.court_jurisdiction_address_structure AS "JurisdictionAddressStructure",
          TC.court_jurisdiction_address_flat AS "JurisdictionAddressFlat",
          TC.court_receiver AS "CourtReceiver",
          TC.court_receiver_bank AS "CourtReceiverBank",
          TC.court_receiver_bank_city AS "CourtReceiverBankCity",
          TC.court_inn AS "CourtInn",
          TC.court_kpp AS "CourtKpp",
          TC.court_correspondent_account AS "CourtCorrespondentAccount",
          TC.court_account AS "CourtAccount",
          TC.court_bik AS "CourtBik",
          TC.court_oktmo AS "CourtOktmo",
          TC.court_kbk AS "CourtKbk",
          TC.court_phone AS "CourtPhone",
          TC.court_email AS "CourtEmail",
          TC.court_site AS "CourtSite",
          CASE
            WHEN
              court_id IS NULL AND court_jurisdiction_address_id IS NULL
            THEN 'no_match'
            WHEN
              court_id IS NOT NULL AND court_jurisdiction_address_id IS NULL
            THEN 'entity_match'
            WHEN
              court_id IS NOT NULL AND court_jurisdiction_address_id IS NOT NULL
            THEN 'full_match'
          END AS "RowStatus",
          true AS "CanSave",
          CASE
            WHEN
              court_id IS NULL
            THEN true
            ELSE false
          END AS "ToSave"
        FROM
          collect.temp_court TC
          LEFT JOIN collect.address_region RA_AR ON RA_AR.address_region_id = TC.court_jurisdiction_address_region_id
          LEFT JOIN collect.address_city_type RA_ACT ON RA_ACT.address_city_type_id = TC.court_jurisdiction_address_city_type_id
          LEFT JOIN collect.address_street_type RA_AST ON RA_AST.address_street_type_id = TC.court_jurisdiction_address_street_type_id
        ORDER BY temp_court_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempCourtClearSqlQuery">
      <Text>
        DELETE FROM collect.temp_court;

        ALTER SEQUENCE collect.temp_court_id_seq
        RESTART WITH 1;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempCourtInsertSqlQuery">
      <Text>
        INSERT INTO collect.temp_court(
          court_title,
          court_title_genitive,
          court_address_region,
          court_address,
          court_jurisdiction_address,
          court_jurisdiction_address_index,
          court_jurisdiction_address_region,
          court_jurisdiction_address_district,
          court_jurisdiction_address_city_type,
          court_jurisdiction_address_city,
          court_jurisdiction_address_city_district,
          court_jurisdiction_address_street_type,
          court_jurisdiction_address_street,
          court_jurisdiction_address_building,
          court_jurisdiction_address_block,
          court_jurisdiction_address_structure,
          court_jurisdiction_address_flat,
          court_receiver,
          court_receiver_bank,
          court_receiver_bank_city,
          court_inn,
          court_kpp,
          court_correspondent_account,
          court_account,
          court_bik,
          court_oktmo,
          court_kbk,
          court_phone,
          court_email,
          court_site)
        SELECT
          trim(court_title),
          trim(court_title_genitive),
          trim(court_address_region),
          trim(court_address),
          trim(court_jurisdiction_address),
          trim(court_jurisdiction_address_index),
          trim(court_jurisdiction_address_region),
          trim(court_jurisdiction_address_district),
          trim(regexp_replace(court_jurisdiction_address_city_type, '[^А-Яа-я ]', '', 'g')),
          trim(court_jurisdiction_address_city),
          trim(court_jurisdiction_address_city_district),
          trim(regexp_replace(court_jurisdiction_address_street_type, '[^А-Яа-я ]', '', 'g')),
          trim(court_jurisdiction_address_street),
          trim(court_jurisdiction_address_building),
          trim(court_jurisdiction_address_block),
          trim(court_jurisdiction_address_structure),
          trim(court_jurisdiction_address_flat),
          trim(court_receiver),
          trim(court_receiver_bank),
          trim(court_receiver_bank_city),
          substr(regexp_replace(court_inn, '[^0-9]', '', 'g'), 1, 12),
          trim(court_kpp),
          trim(court_correspondent_account),
          trim(court_account),
          trim(court_bik),
          trim(court_oktmo),
          trim(court_kbk),
          CASE WHEN substr(regexp_replace(court_phone, '[^0-9+]', '', 'g'), 1, 1) = '+'
            THEN substr(regexp_replace(court_phone, '[^0-9+]', '', 'g'), 1, 12)
            ELSE substr(regexp_replace(court_phone, '[^0-9+]', '', 'g'), 1, 11)
          END,
          trim(court_email),
          trim(court_site)
        FROM (
          SELECT
            unnest({CourtTitle}::character varying[]) AS court_title,
            unnest({CourtTitleGenitive}::character varying[]) AS court_title_genitive,
            unnest({CourtAddressRegion}::character varying[]) AS court_address_region,
            unnest({CourtAddress}::character varying[]) AS court_address,
            unnest({JurisdictionAddress}::character varying[]) AS court_jurisdiction_address,
            unnest({JurisdictionAddressIndex}::character varying[]) AS court_jurisdiction_address_index,
            unnest({JurisdictionAddressRegion}::character varying[]) AS court_jurisdiction_address_region,
            unnest({JurisdictionAddressDistrict}::character varying[]) AS court_jurisdiction_address_district,
            unnest({JurisdictionAddressCityType}::character varying[]) AS court_jurisdiction_address_city_type,
            unnest({JurisdictionAddressCity}::character varying[]) AS court_jurisdiction_address_city,
            unnest({JurisdictionAddressCityDistrict}::character varying[]) AS court_jurisdiction_address_city_district,
            unnest({JurisdictionAddressStreetType}::character varying[]) AS court_jurisdiction_address_street_type,
            unnest({JurisdictionAddressStreet}::character varying[]) AS court_jurisdiction_address_street,
            unnest({JurisdictionAddressBuilding}::character varying[]) AS court_jurisdiction_address_building,
            unnest({JurisdictionAddressBlock}::character varying[]) AS court_jurisdiction_address_block,
            unnest({JurisdictionAddressStructure}::character varying[]) AS court_jurisdiction_address_structure,
            unnest({JurisdictionAddressFlat}::character varying[]) AS court_jurisdiction_address_flat,
            unnest({CourtReceiver}::character varying[]) AS court_receiver,
            unnest({CourtReceiverBank}::character varying[]) AS court_receiver_bank,
            unnest({CourtReceiverBankCity}::character varying[]) AS court_receiver_bank_city,
            unnest({CourtInn}::character varying[]) AS court_inn,
            unnest({CourtKpp}::character varying[]) AS court_kpp,
            unnest({CourtCorrespondentAccount}::character varying[]) AS court_correspondent_account,
            unnest({CourtAccount}::character varying[]) AS court_account,
            unnest({CourtBik}::character varying[]) AS court_bik,
            unnest({CourtOktmo}::character varying[]) AS court_oktmo,
            unnest({CourtKbk}::character varying[]) AS court_kbk,
            unnest({CourtPhone}::character varying[]) AS court_phone,
            unnest({CourtEmail}::character varying[]) AS court_email,
            unnest({CourtSite}::character varying[]) AS court_site) T;

        SELECT collect.temp_court_check_error() AS "ErrorText";
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempCourtSaveSqlQuery">
      <Text>
        UPDATE collect.temp_court TC
        SET to_save = COALESCE(T.to_save, false)
        FROM (
          SELECT
            unnest({TempCourtId}::bigint[]) AS temp_court_id,
            unnest({ToSave}::boolean[]) AS to_save) T
        WHERE TC.temp_court_id = T.temp_court_id;

        --удаление записей со статусом "error"
        DELETE FROM collect.temp_court TC
        WHERE COALESCE(TC.court_title, '') = '';

        SELECT collect.temp_court_save(TC.temp_court_id, {VisibleColumns}::character varying[], {UserId}::smallint)
        FROM collect.temp_court TC
        WHERE to_save
        ORDER BY temp_court_id;

        DELETE FROM collect.temp_court;

        ALTER SEQUENCE collect.temp_court_id_seq
        RESTART WITH 1;
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===ИМПОРТ ОСП ИЗ EXCEL======================================-->
    <!--============================================================-->

    <SqlQuery Name="TempOspAddressSelectSqlQuery">
      <Text>
        WITH address_index_position AS (
          SELECT
            temp_osp_id,
            COALESCE(position(substring(osp_jurisdiction_address, '\m\d{6}') in osp_jurisdiction_address), 0) AS jur_index_position,
            osp_jurisdiction_address
          FROM
            collect.temp_osp
        ), address_string_formatted AS (
          SELECT
            temp_osp_id,
            CASE
              WHEN jur_index_position > 0
              THEN
                CASE
                  WHEN length(osp_jurisdiction_address) = jur_index_position + 5
                  THEN osp_jurisdiction_address
                  ELSE
                    CASE
                      WHEN substr(osp_jurisdiction_address, jur_index_position + 6, 1) = ','
                      THEN osp_jurisdiction_address
                      ELSE substr(osp_jurisdiction_address, 1, jur_index_position + 5) || ',' || substr(osp_jurisdiction_address, jur_index_position + 6)
                    END
                END
              ELSE osp_jurisdiction_address
            END AS osp_jurisdiction_address
          FROM
            address_index_position
        )
        SELECT
          temp_osp_id AS "TempId",
          CASE
            WHEN {AddressType} = 'osp_jurisdiction_address' THEN osp_jurisdiction_address
          END AS "AddressString"
        FROM address_string_formatted;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempOspAddressUpdateSqlQuery">
      <Text>
        UPDATE
          collect.temp_osp O
        SET
          osp_jurisdiction_address_index = CASE WHEN COALESCE(osp_jurisdiction_address_index, '') = '' THEN trim(T.index) ELSE osp_jurisdiction_address_index END,
          osp_jurisdiction_address_region = CASE WHEN COALESCE(osp_jurisdiction_address_region, '') = '' THEN trim(T.region) ELSE osp_jurisdiction_address_region END,
          osp_jurisdiction_address_district = CASE WHEN COALESCE(osp_jurisdiction_address_district, '') = '' THEN trim(T.district) ELSE osp_jurisdiction_address_district END,
          osp_jurisdiction_address_city = CASE WHEN COALESCE(osp_jurisdiction_address_city, '') = '' THEN trim(T.city) ELSE osp_jurisdiction_address_city END,
          osp_jurisdiction_address_city_type = CASE WHEN COALESCE(osp_jurisdiction_address_city_type, '') = '' THEN trim(T.city_type) ELSE osp_jurisdiction_address_city_type END,
          osp_jurisdiction_address_street = CASE WHEN COALESCE(osp_jurisdiction_address_street, '') = '' THEN trim(T.street) ELSE osp_jurisdiction_address_street END,
          osp_jurisdiction_address_street_type = CASE WHEN COALESCE(osp_jurisdiction_address_street_type, '') = '' THEN trim(T.street_type) ELSE osp_jurisdiction_address_street_type END,
          osp_jurisdiction_address_building = CASE WHEN COALESCE(osp_jurisdiction_address_building, '') = '' THEN trim(T.house) ELSE osp_jurisdiction_address_building END,
          osp_jurisdiction_address_block = CASE WHEN COALESCE(osp_jurisdiction_address_block, '') = '' THEN trim(T.block) ELSE osp_jurisdiction_address_block END,
          osp_jurisdiction_address_structure = CASE WHEN COALESCE(osp_jurisdiction_address_structure, '') = '' THEN trim(T.structure) ELSE osp_jurisdiction_address_structure END,
          osp_jurisdiction_address_flat = CASE WHEN COALESCE(osp_jurisdiction_address_flat, '') = '' THEN trim(T.flat) ELSE osp_jurisdiction_address_flat END
        FROM (
          SELECT
            unnest({TempId}::bigint[]) AS temp_osp_id,
            unnest({Index}::character varying[]) AS index,
            unnest({Region}::character varying[]) AS region,
            unnest({District}::character varying[]) AS district,
            unnest({City}::character varying[]) AS city,
            unnest({CityType}::character varying[]) AS city_type,
            unnest({Street}::character varying[]) AS street,
            unnest({StreetType}::character varying[]) AS street_type,
            unnest({House}::character varying[]) AS house,
            unnest({Block}::character varying[]) AS block,
            unnest({Structure}::character varying[]) AS structure,
            unnest({Flat}::character varying[]) AS flat) T
        WHERE
          {AddressType} = 'osp_jurisdiction_address' AND
          T.temp_osp_id = O.temp_osp_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempOspReferencesUpdateSqlQuery">
      <Text>
        UPDATE
          collect.temp_osp O
        SET
          osp_jurisdiction_address_region_id = T.osp_jurisdiction_address_region_id
        FROM (
          SELECT
            ARA.address_region_id AS osp_jurisdiction_address_region_id,
            ARA.title AS osp_jurisdiction_address_region
          FROM
            collect.address_region_alternative ARA
          ORDER BY address_region_id DESC) T
        WHERE
          COALESCE(O.osp_jurisdiction_address_region, '') != '' AND
          O.osp_jurisdiction_address_region = T.osp_jurisdiction_address_region;

        UPDATE
          collect.temp_osp O
        SET
          osp_jurisdiction_address_region_id = T.osp_jurisdiction_address_region_id
        FROM (
          SELECT
            AR.address_region_id AS osp_jurisdiction_address_region_id,
            AR.title AS osp_jurisdiction_address_region
          FROM
            collect.address_region AR
          ORDER BY address_region_id DESC) T
        WHERE
          COALESCE(O.osp_jurisdiction_address_region, '') != '' AND
          O.osp_jurisdiction_address_region_id IS NULL AND
          (O.osp_jurisdiction_address_region ILIKE '%' || T.osp_jurisdiction_address_region || '%' OR
          T.osp_jurisdiction_address_region ILIKE '%' || O.osp_jurisdiction_address_region || '%');

        UPDATE
          collect.temp_osp O
        SET
          osp_jurisdiction_address_city_type_id = T.osp_jurisdiction_address_city_type_id
        FROM (
          SELECT
            address_city_type_id AS osp_jurisdiction_address_city_type_id,
            title AS osp_jurisdiction_address_city_type,
            string_to_array(alternative_values, ';')::character varying[] AS city_type_alternative
          FROM
            collect.address_city_type
          ORDER BY address_city_type_id DESC) T
        WHERE
          COALESCE(O.osp_jurisdiction_address_city_type, '') != '' AND
          (lower(O.osp_jurisdiction_address_city_type) = ANY(city_type_alternative) OR
          lower(O.osp_jurisdiction_address_city_type) = lower(T.osp_jurisdiction_address_city_type));

        UPDATE
          collect.temp_osp O
        SET
          osp_jurisdiction_address_street_type_id = T.osp_jurisdiction_address_street_type_id
        FROM (
          SELECT
            address_street_type_id AS osp_jurisdiction_address_street_type_id,
            title AS osp_jurisdiction_address_street_type,
            string_to_array(alternative_values, ';')::character varying[] AS street_type_alternative
          FROM
            collect.address_street_type
          ORDER BY address_street_type_id DESC) T
        WHERE
          COALESCE(O.osp_jurisdiction_address_street_type, '') != '' AND
          (lower(O.osp_jurisdiction_address_street_type) = ANY(street_type_alternative) OR
          lower(O.osp_jurisdiction_address_street_type) = lower(T.osp_jurisdiction_address_street_type));

        UPDATE
          collect.temp_osp O
        SET
          osp_jurisdiction_address_district_id = address_district_id
        FROM
          collect.address_district
        WHERE
          COALESCE(osp_jurisdiction_address_district, '') != '' AND
         lower(osp_jurisdiction_address_district) = lower(title);

        UPDATE
          collect.temp_osp O
        SET
          osp_jurisdiction_address_city_id = address_city_id
        FROM
          collect.address_city
        WHERE
          COALESCE(osp_jurisdiction_address_city, '') != '' AND
          lower(osp_jurisdiction_address_city) = lower(title);

        UPDATE
          collect.temp_osp O
        SET
          osp_jurisdiction_address_street_id = address_street_id
        FROM
          collect.address_street
        WHERE
          COALESCE(osp_jurisdiction_address_street, '') != '' AND
          lower(osp_jurisdiction_address_street) = lower(title);

        UPDATE
          collect.temp_osp O
        SET
          osp_id = T.osp_id
        FROM (
          SELECT
            osp_id,
            trim(title) AS osp_title
          FROM
            collect.osp
          ORDER BY osp_id DESC) T
        WHERE
          O.osp_id IS NULL AND
          COALESCE(O.osp_title, '') != '' AND
          lower(O.osp_title) = lower(T.osp_title);

        UPDATE
          collect.temp_osp O
        SET
          osp_jurisdiction_address_id = A.address_id,
          can_save = OA.osp_id IS NULL OR O.osp_id IS NOT NULL AND OA.osp_id = O.osp_id
        FROM
          collect.osp_address OA
          JOIN collect.address A USING(address_id)
          LEFT JOIN collect.get_address_string(address_id) GAS USING(address_id)
        WHERE
          (
            (NOT collect.not_equals(A.address_index, osp_jurisdiction_address_index) OR similarity(A.address_index, osp_jurisdiction_address_index) IS NOT DISTINCT FROM 1) AND
            A.address_region_id IS NOT DISTINCT FROM osp_jurisdiction_address_region_id AND
            A.address_district_id IS NOT DISTINCT FROM osp_jurisdiction_address_district_id AND
            (NOT collect.not_equals(A.address_city_district, osp_jurisdiction_address_city_district) OR similarity(A.address_city_district, osp_jurisdiction_address_city_district) IS NOT DISTINCT FROM 1) AND
            A.address_city_type_id IS NOT DISTINCT FROM osp_jurisdiction_address_city_type_id AND
            A.address_city_id IS NOT DISTINCT FROM osp_jurisdiction_address_city_id AND
            A.address_street_type_id IS NOT DISTINCT FROM osp_jurisdiction_address_street_type_id AND
            A.address_street_id IS NOT DISTINCT FROM osp_jurisdiction_address_street_id AND
            (NOT collect.not_equals(A.address_building, osp_jurisdiction_address_building) OR similarity(A.address_building, osp_jurisdiction_address_building) IS NOT DISTINCT FROM 1) AND
            (NOT collect.not_equals(A.address_block, osp_jurisdiction_address_block) OR similarity(A.address_block, osp_jurisdiction_address_block) IS NOT DISTINCT FROM 1) AND
            (NOT collect.not_equals(A.address_structure, osp_jurisdiction_address_structure) OR similarity(A.address_structure, osp_jurisdiction_address_structure) IS NOT DISTINCT FROM 1) AND
            (NOT collect.not_equals(A.address_flat, osp_jurisdiction_address_flat) OR similarity(A.address_flat, osp_jurisdiction_address_flat) IS NOT DISTINCT FROM 1)
          ) OR
          (
            osp_jurisdiction_address IS NOT NULL AND
            similarity(CASE WHEN COALESCE(A.address_string,'') = '' THEN GAS.address_string ELSE A.address_string END, osp_jurisdiction_address) IS NOT DISTINCT FROM 1
          );
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempOspSelectSqlQuery">
      <Text>
        SELECT
          O.temp_osp_id AS "TempOspId",
          O.osp_title AS "OspTitle",
          O.osp_address AS "OspAddress",
          O.osp_ufssp_title AS "OspUfsspTitle",
          O.osp_phone AS "OspPhone",
          O.osp_jurisdiction_address AS "JurisdictionAddress",
          O.osp_jurisdiction_address_index AS "JurisdictionAddressIndex",
          RA_AR.title AS "JurisdictionAddressRegion",
          O.osp_jurisdiction_address_district AS "JurisdictionAddressDistrict",
          RA_ACT.title AS "JurisdictionAddressCityType",
          O.osp_jurisdiction_address_city AS "JurisdictionAddressCity",
          O.osp_jurisdiction_address_city_district AS "JurisdictionAddressCityDistrict",
          RA_AST.title AS "JurisdictionAddressStreetType",
          O.osp_jurisdiction_address_street AS "JurisdictionAddressStreet",
          O.osp_jurisdiction_address_building AS "JurisdictionAddressBuilding",
          O.osp_jurisdiction_address_block AS "JurisdictionAddressBlock",
          O.osp_jurisdiction_address_structure AS "JurisdictionAddressStructure",
          O.osp_jurisdiction_address_flat AS "JurisdictionAddressFlat",
          CASE
            WHEN
              NOT O.can_save
            THEN 'error'
            WHEN
              O.osp_id IS NULL AND O.osp_jurisdiction_address_id IS NULL
            THEN 'no_match'
            WHEN
              O.osp_id IS NOT NULL AND O.osp_jurisdiction_address_id IS NULL
            THEN 'entity_match'
            WHEN
              O.osp_id IS NOT NULL AND O.osp_jurisdiction_address_id IS NOT NULL
            THEN 'full_match'
          END AS "RowStatus",
          O.can_save AS "CanSave",
          O.osp_id IS NULL AND O.can_save AS "ToSave"
        FROM
          collect.temp_osp O
          LEFT JOIN collect.address_region RA_AR ON RA_AR.address_region_id = O.osp_jurisdiction_address_region_id
          LEFT JOIN collect.address_city_type RA_ACT ON RA_ACT.address_city_type_id = O.osp_jurisdiction_address_city_type_id
          LEFT JOIN collect.address_street_type RA_AST ON RA_AST.address_street_type_id = O.osp_jurisdiction_address_street_type_id
        ORDER BY O.temp_osp_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempOspClearSqlQuery">
      <Text>
        DELETE FROM collect.temp_osp;

        ALTER SEQUENCE collect.temp_osp_id_seq
        RESTART WITH 1;
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempOspInsertSqlQuery">
      <Text>
        INSERT INTO collect.temp_osp(
          osp_title,
          osp_address,
          osp_ufssp_title,
          osp_phone,
          osp_jurisdiction_address,
          osp_jurisdiction_address_index,
          osp_jurisdiction_address_region,
          osp_jurisdiction_address_district,
          osp_jurisdiction_address_city_type,
          osp_jurisdiction_address_city,
          osp_jurisdiction_address_city_district,
          osp_jurisdiction_address_street_type,
          osp_jurisdiction_address_street,
          osp_jurisdiction_address_building,
          osp_jurisdiction_address_block,
          osp_jurisdiction_address_structure,
          osp_jurisdiction_address_flat)
        SELECT
          trim(osp_title),
          trim(osp_address),
          trim(osp_ufssp_title),
          CASE WHEN substr(regexp_replace(osp_phone, '[^0-9+]', '', 'g'), 1, 1) = '+'
            THEN substr(regexp_replace(osp_phone, '[^0-9+]', '', 'g'), 1, 12)
            ELSE substr(regexp_replace(osp_phone, '[^0-9+]', '', 'g'), 1, 11)
          END,
          trim(osp_jurisdiction_address),
          trim(osp_jurisdiction_address_index),
          trim(osp_jurisdiction_address_region),
          trim(osp_jurisdiction_address_district),
          trim(regexp_replace(osp_jurisdiction_address_city_type, '[^А-Яа-я ]', '', 'g')),
          trim(osp_jurisdiction_address_city),
          trim(osp_jurisdiction_address_city_district),
          trim(regexp_replace(osp_jurisdiction_address_street_type, '[^А-Яа-я ]', '', 'g')),
          trim(osp_jurisdiction_address_street),
          trim(osp_jurisdiction_address_building),
          trim(osp_jurisdiction_address_block),
          trim(osp_jurisdiction_address_structure),
          trim(osp_jurisdiction_address_flat)
        FROM (
          SELECT
            unnest({OspTitle}::character varying[]) AS osp_title,
            unnest({OspAddress}::character varying[]) AS osp_address,
            unnest({OspUfsspTitle}::character varying[]) AS osp_ufssp_title,
            unnest({OspPhone}::character varying[]) AS osp_phone,
            unnest({JurisdictionAddress}::character varying[]) AS osp_jurisdiction_address,
            unnest({JurisdictionAddressIndex}::character varying[]) AS osp_jurisdiction_address_index,
            unnest({JurisdictionAddressRegion}::character varying[]) AS osp_jurisdiction_address_region,
            unnest({JurisdictionAddressDistrict}::character varying[]) AS osp_jurisdiction_address_district,
            unnest({JurisdictionAddressCityType}::character varying[]) AS osp_jurisdiction_address_city_type,
            unnest({JurisdictionAddressCity}::character varying[]) AS osp_jurisdiction_address_city,
            unnest({JurisdictionAddressCityDistrict}::character varying[]) AS osp_jurisdiction_address_city_district,
            unnest({JurisdictionAddressStreetType}::character varying[]) AS osp_jurisdiction_address_street_type,
            unnest({JurisdictionAddressStreet}::character varying[]) AS osp_jurisdiction_address_street,
            unnest({JurisdictionAddressBuilding}::character varying[]) AS osp_jurisdiction_address_building,
            unnest({JurisdictionAddressBlock}::character varying[]) AS osp_jurisdiction_address_block,
            unnest({JurisdictionAddressStructure}::character varying[]) AS osp_jurisdiction_address_structure,
            unnest({JurisdictionAddressFlat}::character varying[]) AS osp_jurisdiction_address_flat) T;

        SELECT collect.temp_osp_check_error() AS "ErrorText";
      </Text>
    </SqlQuery>

    <SqlQuery Name="TempOspSaveSqlQuery">
      <Text>
        UPDATE collect.temp_osp O
        SET to_save = COALESCE(T.to_save, false)
        FROM (
          SELECT
            unnest({TempOspId}::bigint[]) AS temp_osp_id,
            unnest({ToSave}::boolean[]) AS to_save) T
        WHERE O.temp_osp_id = T.temp_osp_id;

        --удаление записей со статусом "error"
        DELETE FROM collect.temp_osp O
        WHERE COALESCE(O.osp_title, '') = '';

        SELECT collect.temp_osp_save(O.temp_osp_id, {VisibleColumns}::character varying[], {UserId}::smallint)
        FROM collect.temp_osp O
        WHERE to_save
        ORDER BY temp_osp_id;

        DELETE FROM collect.temp_osp;

        ALTER SEQUENCE collect.temp_osp_id_seq
        RESTART WITH 1;
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===ОТЧЕТЫ===================================================-->
    <!--============================================================-->
    <SqlQuery Name="ReportPaymentSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), T AS (
          SELECT
            LCP.loan_client_payment_id,
            LCP.loan_client_id,
            LC.client_id,
            LC.loan_id
          FROM
            collect.loan_client_payment LCP
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN collect.loan L USING(loan_id)
          WHERE
            NOT L.deleted AND
            LCP.date <![CDATA[>=]]> {DateStart}::date AND
            LCP.date <![CDATA[<=]]> {DateFinish}::date
        ), loan_users AS (
          SELECT
            LC.loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client LC
            JOIN T USING(loan_id)
          WHERE
            LC.user_id IS NOT NULL
          GROUP BY LC.loan_id
        ), final AS (
          SELECT
            T.*
          FROM
            T
            LEFT JOIN loan_users LU USING(loan_id)
            LEFT JOIN current_user_info CUI ON true
          WHERE
            CUI.user_is_administrator OR
            (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
            {UserId} = ANY(LU.user_ids)
        ), loan_client_payment AS (
          SELECT
            F.loan_client_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            final F
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_payment_id)
          GROUP BY F.loan_client_id
        ), loan_client_repayment_payment AS (
          SELECT
            F.loan_client_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            final F
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_payment_id)
            LEFT JOIN collect.loan_client LC ON LC.loan_client_id = F.loan_client_id
          WHERE
            LCP.date >= LC.repayment_date
          GROUP BY F.loan_client_id
        ), loan_client_info AS (
          SELECT
            DISTINCT ON(F.loan_client_id)
            F.loan_client_id,
            CASE
              WHEN LC.repayment_date IS NULL THEN GREATEST(COALESCE(LC.debt_base, 0) + COALESCE(LC.debt_percent, 0) + COALESCE(LC.debt_penalty, 0) + COALESCE(LC.debt_tax, 0) - COALESCE(P.total_payment_sum, 0), 0)
              ELSE GREATEST(COALESCE(LC.repayment_sum, 0) - COALESCE(RP.total_payment_sum, 0), 0)
            END AS total_debt_rest_sum
          FROM
            final F
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN loan_client_payment P USING (loan_client_id)
            LEFT JOIN loan_client_repayment_payment RP USING (loan_client_id)
          ORDER BY
            F.loan_client_id
        )
        SELECT
          F.loan_client_payment_id AS "LoanClientPaymentId",
          F.loan_client_id AS "LoanClientId",
          F.loan_id AS "LoanId",
          LCP.date AS "PaymentDate",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "ClientTitle",
          L.credit_number AS "CreditNumber",
          UI.user_full_name AS "UserTitle",
          CL.short_title AS "ClaimantTitle",
          C.title AS "CessionTitle",
          AR.title AS "CessionRegionTitle",
          LCP.sum AS "PaymentSum",
          LCI.total_debt_rest_sum AS "LoanClientTotalDebtRestSum"
        FROM
          final F
          LEFT JOIN collect.loan_client_payment LCP USING(loan_client_payment_id)
          LEFT JOIN collect.loan_client LC ON LCP.loan_client_id = LC.loan_client_id
          LEFT JOIN collect.client_person CP ON CP.client_id = LC.client_id
          LEFT JOIN collect.user_info UI USING(user_id)
          LEFT JOIN collect.loan L ON L.loan_id = LC.loan_id
          LEFT JOIN collect.cession C USING(cession_id)
          LEFT JOIN collect.claimant CL USING(claimant_id)
          LEFT JOIN collect.address_region AR ON AR.address_region_id = C.address_region_id
          LEFT JOIN loan_client_info LCI ON LCP.loan_client_id = LCI.loan_client_id
        ORDER BY LCP.date, "ClientTitle", LCP.loan_client_payment_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ReportInteractionSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), dates AS (
          SELECT
            collect.convert_date_filter({DateStart}::timestamp) AS start_date,
            collect.convert_date_filter({DateFinish}::timestamp + interval '24h') AS finish_date
        ), T AS (
          SELECT
            LCI.loan_client_interaction_id,
            LC.loan_id,
            LCI.loan_client_id,
            LC.client_id,
            LCI.date,
            L.credit_number,
            UI.user_full_name,
            IT.title AS interaction_type_title,
            CL.short_title AS claimant_title,
            C.title AS cession_title
          FROM
            collect.loan_client_interaction LCI
            LEFT JOIN collect.user_info UI USING(user_id)
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN collect.loan L USING(loan_id)
            LEFT JOIN collect.interaction_type IT USING(interaction_type_id)
            LEFT JOIN collect.cession C USING(cession_id)
            LEFT JOIN collect.claimant CL USING(claimant_id)
            LEFT JOIN dates D ON true
          WHERE
            NOT L.deleted AND
            LCI.date <![CDATA[>=]]> D.start_date AND
            LCI.date <![CDATA[<]]> D.finish_date
        ), loan_users AS (
          SELECT
            loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client
            JOIN T USING(loan_id)
          WHERE
            user_id IS NOT NULL
          GROUP BY loan_id
        )
        SELECT
          T.loan_id AS "LoanId",
          T.loan_client_id AS "LoanClientId",
          T.date AS "InteractionDate",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "ClientTitle",
          T.credit_number AS "CreditNumber",
          T.user_full_name AS "UserTitle",
          T.interaction_type_title AS "InteractionTypeTitle",
          T.claimant_title AS "ClaimantTitle",
          T.cession_title AS "CessionTitle"
        FROM
          T
          LEFT JOIN collect.client_person CP USING(client_id)
          LEFT JOIN loan_users LU USING(loan_id)
          LEFT JOIN current_user_info CUI ON true
        WHERE
          CUI.user_is_administrator OR
          (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
          {UserId} = ANY(LU.user_ids)
        ORDER BY T.date, "ClientTitle", T.loan_client_interaction_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="ReportDebtForPeriodSqlQuery">
      <Text>
		WITH --Table for filter without downloading
		loan_client_payment_table AS(
		  SELECT
		    loan_client_payment_id,
		    loan_client_id,
		    payer_client_id,--just in case
		    DATE, 
		    SUM
		  FROM
		    COLLECT.loan_client_payment
            LEFT JOIN collect.loan_client using(loan_client_id)
            LEFT JOIN collect.loan using(loan_id)
          WHERE
             loan_client_payment.date <![CDATA[<=]]> {DateFinish}::DATE
             AND NOT loan.deleted 
		),
		loan_client_payment_before_start AS(
		  SELECT
		    loan_client_id,
		    SUM(SUM) AS payment_before_start
		  FROM
		    loan_client_payment_table
		  WHERE
		    loan_client_payment_table.date <![CDATA[<]]> {DateStart}::DATE
		  GROUP BY
		    loan_client_id
		),
		loan_client_payment_between_filters AS(
		  SELECT
		    loan_client_id,
		    SUM(SUM) AS payment_between
		  FROM
		    loan_client_payment_table
		  WHERE
		    loan_client_payment_table.date >= {DateStart}::DATE
		    AND loan_client_payment_table.date <![CDATA[<=]]> {DateFinish}::DATE
		  GROUP BY
		    loan_client_id
		),
		loan_client_total_debt AS (
		  SELECT
		    loan_client_id,
		    CASE WHEN repayment_date IS NULL THEN COALESCE(debt_base, 0) + COALESCE(debt_percent, 0) + COALESCE(debt_penalty, 0) + COALESCE(debt_tax, 0) ELSE COALESCE(repayment_sum, 0) END AS total_debt
		  FROM
		    COLLECT.loan_client
		),
		tmp AS(
		  SELECT
		    loan_client_id AS "LoanClientId",
            loan.loan_id as "LoanId",
		    collect.get_client_title(client_person.first_name, client_person.second_name, client_person.third_name, false) AS "ClientTitle",
		    loan.credit_number AS "CreditNumber",
		    cession.title AS "CessionTitle",
		    claimant.short_title AS "ClaimantTitle",
		    inner_org.short_title AS "InnerOrgTitle",
		    lctd.total_debt - COALESCE(lcpbs.payment_before_start, 0) AS "DebtBeforeStart",
		    COALESCE(lcpbf.payment_between, 0) AS "TotalPaidInFilters",
		    lctd.total_debt - (
		      COALESCE(lcpbs.payment_before_start, 0) + COALESCE(lcpbf.payment_between, 0)
		    ) AS "DebtToEndFilter"
		  FROM
		    COLLECT.loan_client
		    LEFT JOIN COLLECT.loan USING(loan_id)
		    LEFT JOIN COLLECT.client_person USING(client_id)
		    LEFT JOIN COLLECT.cession USING(cession_id)
		    LEFT JOIN COLLECT.claimant USING(claimant_id)
		    LEFT JOIN COLLECT.inner_org USING(inner_org_id)
		    LEFT JOIN loan_client_total_debt lctd USING(loan_client_id)
		    LEFT JOIN loan_client_payment_before_start lcpbs USING(loan_client_id)
		    LEFT JOIN loan_client_payment_between_filters lcpbf USING(loan_client_id)
		  WHERE
		    NOT loan.deleted --idk need or no AND NOT loan.archive
            AND ({ClaimantIdArray}::bigint[] = ARRAY[NULL]::bigint[] OR claimant_id = ANY({ClaimantIdArray}::bigint[]))
            AND ({CessionIdArray}::bigint[] = ARRAY[NULL]::bigint[] OR cession_id = ANY({CessionIdArray}::bigint[]))
            AND ({InnerOrgIdArray}::bigint[] = ARRAY[NULL]::bigint[] OR inner_org_id = ANY({InnerOrgIdArray}::bigint[]))
		)
		SELECT
		  *
		FROM
		  tmp
		WHERE
		  "DebtBeforeStart" > 0
  </Text>
    </SqlQuery>

    <SqlQuery Name="ReportApplicationTaxPaymentSelectSqlQuery">
      <Text>
        WITH _loan_client AS (
          SELECT
            loan_client_id,
            loan_client_collection_id
          FROM
            collect.loan_client_collection
            LEFT JOIN collect.application_tax_payment_export ATPE USING (application_tax_payment_export_id)
          WHERE
            (NOT {OnlyMainCourt}::boolean OR is_main) AND
            (NOT {TaxIsCalculated}::boolean OR application_tax IS NOT NULL) AND
            (NOT {PaymentWasExported}::boolean OR ATPE.date BETWEEN {DateStart}::date AND {DateFinish}::date)
        )
        SELECT
          LC.loan_id AS "LoanId", 
          LC.loan_client_id AS "LoanClientId", 
          LCC.loan_client_collection_id AS "LoanClientCollectionId", 
          CES.claimant_id AS "ClaimantId",
          CES.inner_org_id AS "InnerOrgId",
          CES.title AS "CessionTitle",
          trim(COALESCE(trim(initcap(CP.first_name)), '') || ' ' || COALESCE(trim(initcap(CP.second_name)), '') || ' ' || COALESCE(trim(initcap(CP.third_name)), '')) AS "ClientTitle",
          LCC.court_id AS "CourtId",
          LCC.application_type_id AS "ApplicationTypeId",
          LCC.application_tax AS "TaxSum",
          ATPE.number AS "PaymentExportNum",
          ATPE.date AS "PaymentExportDate",
          LC.user_id AS "UserId",
          LCC.application_tax IS NOT NULL AND LCC.court_id IS NOT NULL AS "CanExport",
          CASE
            WHEN LCC.application_tax IS NULL THEN 'EmptyTax'
            WHEN LCC.court_id IS NULL THEN 'WithoutCourt'
          END AS "Error"
        FROM
          collect.loan L
          JOIN collect.loan_client LC USING (loan_id)
          JOIN _loan_client USING (loan_client_id)
          JOIN collect.loan_client_collection LCC USING (loan_client_collection_id)
          JOIN collect.cession CES USING (cession_id)
          JOIN collect.client_person CP USING (client_id)
          LEFT JOIN collect.application_tax_payment_export ATPE USING (application_tax_payment_export_id)
        ORDER BY "ClientTitle";
      </Text>
    </SqlQuery>

    <SqlQuery Name="PaymentExportToTxtSelectSqlQuery">
      <Text>
        SELECT collect.get_1c_export_text({LoanClientCollectionIds}::bigint[]) AS "ExportText"
      </Text>
    </SqlQuery><!--============================================================-->

    <SqlQuery Name="ReportUsersSqlQuery">
      <Text> 
		      WITH report_period AS (
		  SELECT
		    COLLECT.convert_date_filter({DateStart}:: TIMESTAMP) AS date_start,
		    COLLECT.convert_date_filter({DateFinish} :: TIMESTAMP) AS date_finish
		),
		finish_statuses AS (
		  SELECT
		    status_id
		  FROM
		    COLLECT.status
		  WHERE
		    is_finish_status
		),
		date_start_closed AS (
		  SELECT
		    DISTINCT ON (loan_client_id) 
		    loan_client_user_history.*
		  FROM
		    COLLECT.loan_client_user_history
		    LEFT JOIN report_period ON TRUE
		    JOIN finish_statuses using(status_id)
		  WHERE
		    edit_date <![CDATA[<]]> report_period.date_start
		
		  ORDER BY
		    loan_client_id,
		    edit_date desc
		),
		date_start_history AS (
		  SELECT
		    *
		  FROM
		    (
		      SELECT
		        DISTINCT ON (loan_client_id) 
		        loan_client_user_history.*
		      FROM
		        COLLECT.loan_client_user_history
		        LEFT JOIN report_period on TRUE
		      WHERE
		        edit_date <![CDATA[<]]> report_period.date_start
		      ORDER BY
		        loan_client_id,
		        edit_date desc
		      ) tmp
		      except 
		      SELECT * FROM (
		      SELECT
		        DISTINCT ON (loan_client_id) 
		        loan_client_user_history.*
		      FROM
		        COLLECT.loan_client_user_history
		        LEFT JOIN report_period ON TRUE
		        join finish_statuses on finish_statuses.status_id = loan_client_user_history.status_id
		      WHERE
		        edit_date <![CDATA[<]]> report_period.date_start
		      ORDER BY
		        loan_client_id,
		        edit_date desc
		        ) tmp2
		    ),
		    date_start_loans_user_counter AS(
		      SELECT
		        date_start_history.user_id,
		        COUNT(loan_client_id) AS counter
		      FROM
		        date_start_history
		        LEFT JOIN COLLECT.loan_client USING (loan_client_id)
		        LEFT JOIN COLLECT.loan USING (loan_id)
		      WHERE
		        NOT loan.deleted
		      GROUP BY
		        date_start_history.user_id
		    ),
		        tmp_for_new_loans as(
		SELECT 
		 * 
		 FROM (
		      SELECT
		        DISTINCT ON (loan_client_id) loan_client_id
		      FROM
		        COLLECT.loan_client_user_history
		        LEFT JOIN report_period on TRUE
		        join finish_statuses on finish_statuses.status_id != loan_client_user_history.status_id
		      WHERE
		        edit_date between report_period.date_start and report_period.date_finish
		      ORDER BY
		        loan_client_id,
		        edit_date desc
		      ) tmp
		except 
		SELECT * FROM (
		  SELECT DISTINCT ON (loan_client_id) 
		    loan_client_id
		  FROM
		    COLLECT.loan_client_user_history
		    LEFT JOIN report_period on TRUE
		  WHERE
		    edit_date <![CDATA[<]]> report_period.date_start
		  ORDER BY
		    loan_client_id,
		    edit_date desc
		  ) tmp2
		  ), list_of_users_by_finish as(
		  SELECT
		        DISTINCT ON (loan_client_id) loan_client_id,user_id
		      FROM
		        COLLECT.loan_client_user_history
		        LEFT JOIN report_period ON TRUE
		        JOIN finish_statuses on finish_statuses.status_id != loan_client_user_history.status_id
		      WHERE
		        edit_date between report_period.date_start and report_period.date_finish
		      ORDER BY
		        loan_client_id,
		        edit_date desc
		  ), date_between_new_loans_user as(
		    SELECT 
              loan_client_id,
              user_id 
            FROM 
              tmp_for_new_loans 
              left join list_of_users_by_finish using(loan_client_id)
		), new_tmp_changer_loan_client as(
		     SELECT DISTINCT ON (loan_client_id) *
		      FROM
		        COLLECT.loan_client_user_history
		        LEFT JOIN report_period ON TRUE
		        JOIN finish_statuses on finish_statuses.status_id != loan_client_user_history.status_id
		      WHERE
		        edit_date between report_period.date_start and report_period.date_finish
		      ORDER BY
		        loan_client_id,
		        edit_date desc
		  ), old_new_loan_client_user_id as(
		    SELECT
             loan_client_id,
             date_start_history.user_id as old_user, 
             new_tmp_changer_loan_client.user_id as new_user 
		    FROM 
		      date_start_history 
		      left join new_tmp_changer_loan_client using(loan_client_id)
		  ), date_between_new_change_user_counter as (
		    SELECT new_user, old_user, case when (old_user != new_user) then 1 else 0 end as summ
		    FROM old_new_loan_client_user_id
		    where new_user is not null
		  ), loans_changed_between as (
		    SELECT old_user as user_id, sum(summ) as counter FROM date_between_new_change_user_counter group by old_user
		  ),
		    date_between_new_loans_user_counter_without_changer AS (
		      SELECT
		        date_between_new_loans_user.user_id,
		        COUNT(loan_client_id) AS counter
		      FROM
		        date_between_new_loans_user
		        LEFT JOIN COLLECT.loan_client USING (loan_client_id)
		        LEFT JOIN COLLECT.loan USING (loan_id)
		      WHERE
		        NOT loan.deleted
		      GROUP BY
		        date_between_new_loans_user.user_id
		    ), date_between_new_loans_user_counter as(
		        SELECT 
                  user_id, 
                  sum(counter) as counter
		        FROM
		          (SELECT 
                    user_id,
                    counter 
		          FROM 
                    date_between_new_loans_user_counter_without_changer
		          union all
		          SELECT 
                    new_user, 
                    summ
		          FROM 
                    date_between_new_change_user_counter
		          ) tmp
		          group by user_id
		    ),
		    date_between_closed_loans_user as(
		    SELECT
		        DISTINCT ON (loan_client_id) loan_client_id, user_id
		      FROM
		        COLLECT.loan_client_user_history
		        LEFT JOIN report_period on TRUE
		        JOIN finish_statuses using (status_id)
		      WHERE
		        edit_date between report_period.date_start and report_period.date_finish
		      ORDER BY
		        loan_client_id,
		        edit_date desc
		    ),
		    
		    date_between_closed_loans_user_counter AS (
		      SELECT
		        date_between_closed_loans_user.user_id,
		        COUNT(loan_client_id) AS counter
		      FROM
		        date_between_closed_loans_user
		        LEFT JOIN COLLECT.loan_client USING (loan_client_id)
		        LEFT JOIN COLLECT.loan USING (loan_id)
		      WHERE
		        NOT loan.deleted
		      GROUP BY
		        date_between_closed_loans_user.user_id
		    ),
		    date_finish_history AS (
		SELECT 
		 * 
		 FROM (
		      SELECT DISTINCT ON (loan_client_id) loan_client_user_history.*
		      FROM
		        COLLECT.loan_client_user_history
		        LEFT JOIN report_period ON TRUE
		      WHERE
		        edit_date <![CDATA[<]]>= report_period.date_finish
		      ORDER BY
		        loan_client_id,
		        edit_date desc
		      ) tmp
		      except 
		      SELECT * FROM (SELECT
		        DISTINCT ON (loan_client_id) loan_client_user_history.*
		      FROM
		        COLLECT.loan_client_user_history
		        LEFT JOIN report_period ON TRUE
		        JOIN finish_statuses using(status_id)
		      WHERE
		        loan_client_user_history.edit_date <![CDATA[<]]> report_period.date_finish
		      ORDER BY
		        loan_client_id,
		        edit_date desc
		        ) tmp2
		    ),
		    date_finish_open_loans_user_count AS (
		      SELECT
		        date_finish_history.user_id,
		        COUNT(loan_client_id) AS counter
		      FROM
		        date_finish_history
		        LEFT JOIN COLLECT.loan_client USING (loan_client_id)
		        LEFT JOIN COLLECT.loan USING (loan_id)
		      WHERE
		        NOT loan.deleted
		      GROUP BY
		        date_finish_history.user_id
		    ),
		    all_comments AS (
		      SELECT
		        loan_comment_id,
		        loan_client.loan_client_id,
		        loan_comment.create_date
		      FROM
		        COLLECT.loan_comment
		        LEFT JOIN COLLECT.loan_client USING(loan_id)
		        LEFT JOIN report_period ON TRUE
		      WHERE
		        loan_id IS NOT NULL
		        AND create_date BETWEEN report_period.date_start and report_period.date_finish
		      UNION
		      ALL
		      SELECT
		        loan_comment_id,
		        loan_client_id,
		        create_date
		      FROM
		        COLLECT.loan_comment
		        LEFT JOIN report_period ON TRUE
		      WHERE
		        loan_client_id IS NOT NULL
		        AND create_date BETWEEN report_period.date_start and report_period.date_finish
		    ),
		    all_comments_with_loan_client_id AS (
		      SELECT
		        loan_client_id,
		        user_id,
		        COUNT(loan_comment_id) AS counter
		      FROM
		        date_finish_history
		        LEFT JOIN all_comments USING(loan_client_id)
		        LEFT JOIN report_period ON TRUE
		      WHERE
		        all_comments.create_date BETWEEN report_period.date_start and report_period.date_finish
		      GROUP BY
		        loan_client_id,
		        user_id
		      ORDER BY
		        loan_client_id
		    ),
		    count_loan_client_with_new_comments AS (
		      SELECT
		        user_id,
		        COUNT(loan_client_id) AS counter
		      FROM
		        all_comments_with_loan_client_id
		      GROUP BY
		        user_id
		    ),
		    all_tasks_between_date AS(
		      SELECT
		        loan_client_id,
		        execution_date
		      FROM
		        COLLECT.task
		        LEFT JOIN COLLECT.task_loan USING(task_id)
		        LEFT JOIN COLLECT.loan_client USING(loan_id, client_id)
		        LEFT JOIN report_period ON TRUE
		      WHERE
		        execution_date IS NOT NULL
		        AND execution_date  BETWEEN report_period.date_start and report_period.date_finish
		    ),
		    all_task_with_realy_user_id AS (
		      SELECT
		        DISTINCT ON (loan_client_id) loan_client_id,
		        user_id,
		        edit_date,
		        execution_date
		      FROM
		        COLLECT.loan_client_user_history
		        LEFT JOIN all_tasks_between_date USING(loan_client_id)
		      WHERE
		        user_id IS NOT NULL
		        AND execution_date > edit_date
		      ORDER BY
		        loan_client_id,
		        edit_date ASC
		    ),
		    all_task_with_reauly_user_id_count AS (
		      SELECT
		        user_id,
		        COUNT(loan_client_id) AS counter
		      FROM
		        all_task_with_realy_user_id
		      GROUP BY
		        user_id
		    ),
		    all_files AS (
		      SELECT
		        loan_file_id,
		        loan_client.loan_client_id,
		        loan_file.create_date
		      FROM
		        COLLECT.loan_file
		        LEFT JOIN COLLECT.loan_client USING(loan_id)
		        LEFT JOIN report_period ON TRUE
		      WHERE
		        loan_id IS NOT NULL
		        AND create_date  BETWEEN report_period.date_start and report_period.date_finish
		      UNION
		      ALL
		      SELECT
		        loan_file_id,
		        loan_client_id,
		        create_date
		      FROM
		        COLLECT.loan_file
		        LEFT JOIN report_period ON TRUE
		      WHERE
		        loan_client_id IS NOT NULL
		        AND create_date  BETWEEN report_period.date_start and report_period.date_finish
		    ),
		    all_files_with_loan_client_id AS (
		      SELECT
		        loan_client_id,
		        user_id,
		        COUNT(loan_file_id) AS counter
		      FROM
		        date_finish_history
		        LEFT JOIN all_files USING(loan_client_id)
		        LEFT JOIN report_period on TRUE
		      WHERE
		        all_files.create_date  BETWEEN report_period.date_start and report_period.date_finish
		      GROUP BY
		        loan_client_id,
		        user_id
		      ORDER BY
		        loan_client_id
		    ),
		    count_loan_client_with_new_files AS (
		      SELECT
		        user_id,
		        COUNT(loan_client_id) AS counter
		      FROM
		        all_files_with_loan_client_id
		      GROUP BY
		        user_id
		    ),
		    distinct_changes_in_loan_by_user_id AS(
		      SELECT
		        loan_client_id,
		        user_id
		      FROM
		        all_files_with_loan_client_id
		      UNION
		      SELECT
		        loan_client_id,
		        user_id
		      FROM
		        all_task_with_realy_user_id
		      UNION
		      SELECT
		        loan_client_id,
		        user_id
		      FROM
		        all_comments_with_loan_client_id
		    ),
		    distinct_changes_in_loan_by_user_id_count AS (
		      SELECT
		        user_id,
		        COUNT(loan_client_id) AS counter
		      FROM
		        distinct_changes_in_loan_by_user_id
		      GROUP BY
		        user_id
		    )
		    
		
		    SELECT
		      ui.user_id AS "UserId",
		      ui.user_full_name AS "UserTitle",
		      COALESCE(date_start_loans_user_counter.counter, 0) AS "LoansAtStart",
		      COALESCE(date_between_new_loans_user_counter.counter, 0) AS "NewLoansBetween",
		      COALESCE(loans_changed_between.counter,0) as "LoansChanged",
		      COALESCE(date_between_closed_loans_user_counter.counter, 0) AS "ClosedLoansBetween",
		      COALESCE(date_finish_open_loans_user_count.counter, 0) AS "OpenLoansAtFinish",
		      COALESCE(count_loan_client_with_new_comments.counter, 0) AS "NewComments",
		      COALESCE(all_task_with_reauly_user_id_count.counter, 0) AS "NewTasks",
		      COALESCE(count_loan_client_with_new_files.counter, 0) AS "NewFiles",
		      COALESCE(
		        distinct_changes_in_loan_by_user_id_count.counter,
		        0
		      ) AS "NewActions"
		      
		    FROM
		      COLLECT.user_info ui
		      LEFT JOIN date_start_loans_user_counter USING (user_id)
		      LEFT JOIN date_between_new_loans_user_counter USING (user_id)
		      LEFT JOIN date_between_closed_loans_user_counter USING (user_id)
		      LEFT JOIN date_finish_open_loans_user_count USING (user_id)
		      LEFT JOIN count_loan_client_with_new_comments USING (user_id)
		      LEFT JOIN all_task_with_reauly_user_id_count USING(user_id)
		      LEFT JOIN count_loan_client_with_new_files USING(user_id)
		      LEFT JOIN distinct_changes_in_loan_by_user_id_count USING(user_id)
		      left join loans_changed_between using (user_id)
		      
		    WHERE
		      ui.person
		      AND NOT ui.archive
      </Text>
    </SqlQuery>


    <!--============================================================-->
    <!--===БКИ=====================================================-->
    <!--============================================================-->
    <SqlQuery Name="LoanClientForNbkiSelectSqlQuery">
      <Text>
        WITH filtered_loan AS (
          SELECT * FROM collect.filtered_bki_loan_client(
            {UserId}::smallint,
            'nbki'::character varying,
            {CessionId}::bigint[],
            {ClaimantId}::bigint[],
            {InnerOrgId}::bigint[],
            {CreditNumber}::character varying,
            {LoanDebtRestFrom}::numeric,
            {LoanDebtRestTo}::numeric,
            {UniqueId}::character varying,
            {ClientTitle}::character varying,
            {IsCancel}::boolean,
            {WasExportedToNbki}::boolean,
            {WasExportedToEquifax}::boolean,
            {WasExportedToOkb}::boolean,
            {HasBkiErrors}::boolean,
            {ShowOnlyChecked}::boolean,
            {LoanClientId}::bigint[]
          )
        ), S AS (
          SELECT
            LC.loan_client_id
          FROM
            collect.loan_client LC
            JOIN filtered_loan USING (loan_client_id)
          ORDER BY LC.loan_id, LC.loan_client_id
        ), R AS (
          SELECT
            count(*) AS total_rows,
            COALESCE(CEIL(count(*)::numeric/GREATEST(COALESCE({RowsPerPage}, count(*))::numeric, 1)), 1) AS total_pages
          FROM S
        ), final AS (
          SELECT
            row_number() over() AS "RowNumber",
            (SELECT R.total_rows FROM R) AS "TotalRows",
            (SELECT R.total_pages FROM R) AS "TotalPages",
            *
          FROM S
          LIMIT COALESCE({RowsPerPage}, (SELECT R.total_rows FROM R))
          OFFSET (GREATEST((LEAST((SELECT R.total_pages FROM R), COALESCE({CurrentPage}, 1)) - 1)::integer, 0) * COALESCE({RowsPerPage}, (SELECT R.total_rows FROM R)))
        ), loan AS (
          SELECT DISTINCT loan_id
          FROM final
            JOIN collect.loan_client USING (loan_client_id)
        ), current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), loan_users AS (
          SELECT
            LC.loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            final
            JOIN collect.loan_client LC USING (loan_client_id)
          WHERE
            LC.user_id IS NOT NULL
          GROUP BY LC.loan_id
        ), allowed_loan AS (
          SELECT DISTINCT 
            L.loan_id,
            true AS loan_is_allowed
          FROM
            loan L
            LEFT JOIN loan_users LU USING(loan_id)
            LEFT JOIN current_user_info CUI ON true
          WHERE
            CUI.user_is_administrator OR
            (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
            {UserId} = ANY(LU.user_ids)
        ), loan_payment AS (
          SELECT
            L.loan_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            loan L
            JOIN collect.loan_client LC USING (loan_id)
            LEFT JOIN collect.loan_client_payment LCP USING (loan_client_id)
          GROUP BY L.loan_id
        ), loan_info AS (
          SELECT DISTINCT ON (loan_id)
            L.loan_id,
            GREATEST(COALESCE(L.debt_base, 0) + COALESCE(L.debt_percent, 0) + COALESCE(L.debt_penalty, 0) + COALESCE(L.debt_tax, 0) - COALESCE(LP.total_payment_sum, 0), 0) AS total_debt_rest_sum
          FROM
            loan
            JOIN collect.loan L USING (loan_id)
            LEFT JOIN loan_payment LP USING(loan_id)
        ), nbki_client_error AS (
          SELECT
            BE.client_id,
            string_agg(BE.error, E'\r\n') AS error
          FROM
            final
            JOIN collect.loan_client USING (loan_client_id)
            LEFT JOIN collect.bki_error BE USING (client_id)
            LEFT JOIN collect.bki_type BT USING(bki_type_id)
          WHERE
            BT.name = 'nbki'
          GROUP BY BE.client_id
        ), nbki_loan_error AS (
          SELECT
            BE.loan_id,
            string_agg(BE.error, E'\r\n') AS error
          FROM
            final
            JOIN collect.loan_client USING (loan_client_id)
            LEFT JOIN collect.bki_error BE USING (loan_id)
            LEFT JOIN collect.bki_type BT USING(bki_type_id)
          WHERE
            BT.name = 'nbki'
          GROUP BY BE.loan_id
        ), was_exported_to_nbki AS (
          SELECT
            DISTINCT BED.loan_client_id,
            true AS was_exported_to_nbki
          FROM
            final
            JOIN collect.bki_export_detail BED USING (loan_client_id)
            LEFT JOIN collect.bki_export BE USING (bki_export_id)
            LEFT JOIN collect.bki_type BT USING (bki_type_id)
          WHERE
            BT.name = 'nbki' AND
            BED.is_accepted
        ), was_exported_to_equifax AS (
          SELECT
            DISTINCT BED.loan_client_id,
            true AS was_exported_to_equifax
          FROM
            final
            JOIN collect.bki_export_detail BED USING (loan_client_id)
            LEFT JOIN collect.bki_export BE USING (bki_export_id)
            LEFT JOIN collect.bki_type BT USING (bki_type_id)
          WHERE
            BT.name = 'equifax' AND
            BED.is_accepted
        ), was_exported_to_okb AS (
          SELECT
            DISTINCT BED.loan_client_id,
            true AS was_exported_to_okb
          FROM
            final
            JOIN collect.bki_export_detail BED USING (loan_client_id)
            LEFT JOIN collect.bki_export BE USING (bki_export_id)
            LEFT JOIN collect.bki_type BT USING (bki_type_id)
          WHERE
            BT.name = 'okb' AND
            BED.is_accepted
        )
        SELECT
          F."RowNumber",
          F."TotalRows",
          F."TotalPages",
          COALESCE(loan_client_id = ANY({LoanClientId}::bigint[]), false) AS "ToExport",
          LC.loan_id AS "LoanId",
          LC.loan_client_id AS "LoanClientId",
          C.inner_org_id AS "InnerOrgId",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "ClientTitle",
          LC.unique_id AS "UniqueId",
          L.credit_number AS "CreditNumber",
          LC.is_main AS "IsMain",
          CL.short_title AS "ClaimantTitle",
          C.title AS "CessionTitle",
          LI.total_debt_rest_sum AS "LoanTotalDebtRestSum",
          LC.is_nbki_cancel AS "IsCancel",
          (NCE.error IS NOT NULL OR NLE.error IS NOT NULL) AS "HasNbkiErrors",
          COALESCE(NCE.error || E'\r\n', '') || COALESCE(NLE.error, '') AS "NbkiError",
          CASE WHEN COALESCE(WEN.was_exported_to_nbki, false) THEN 'Да' ELSE 'Нет' END AS "WasExportedToNbki",
          CASE WHEN COALESCE(WEE.was_exported_to_equifax, false) THEN 'Да' ELSE 'Нет' END AS "WasExportedToEquifax",
          CASE WHEN COALESCE(WEO.was_exported_to_okb, false) THEN 'Да' ELSE 'Нет' END AS "WasExportedToOkb",
          COALESCE(AL.loan_is_allowed, false) AS "CanEditLoan"
        FROM
          final F
          JOIN collect.loan_client LC USING(loan_client_id)
          LEFT JOIN collect.client_person CP USING(client_id)
          LEFT JOIN collect.loan L USING(loan_id)
          LEFT JOIN collect.cession C USING(cession_id)
          LEFT JOIN collect.claimant CL USING(claimant_id)
          LEFT JOIN loan_info LI USING(loan_id)
          LEFT JOIN nbki_client_error NCE USING(client_id)
          LEFT JOIN nbki_loan_error NLE USING(loan_id)
          LEFT JOIN was_exported_to_nbki WEN USING(loan_client_id)
          LEFT JOIN was_exported_to_equifax WEE USING(loan_client_id)
          LEFT JOIN was_exported_to_okb WEO USING(loan_client_id)
          LEFT JOIN allowed_loan AL USING(loan_id);
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanClientForEquifaxSelectSqlQuery">
      <Text>
        WITH filtered_loan AS (
          SELECT * FROM collect.filtered_bki_loan_client(
            {UserId}::smallint,
            'equifax'::character varying,
            {CessionId}::bigint[],
            {ClaimantId}::bigint[],
            {InnerOrgId}::bigint[],
            {CreditNumber}::character varying,
            {LoanDebtRestFrom}::numeric,
            {LoanDebtRestTo}::numeric,
            {UniqueId}::character varying,
            {ClientTitle}::character varying,
            {IsCancel}::boolean,
            {WasExportedToNbki}::boolean,
            {WasExportedToEquifax}::boolean,
            {WasExportedToOkb}::boolean,
            {HasBkiErrors}::boolean,
            {ShowOnlyChecked}::boolean,
            {LoanClientId}::bigint[]
          )
        ), S AS (
          SELECT
            LC.loan_client_id
          FROM
            collect.loan_client LC
            JOIN filtered_loan USING (loan_client_id)
          ORDER BY LC.loan_id, LC.loan_client_id
        ), R AS (
          SELECT
            count(*) AS total_rows,
            COALESCE(CEIL(count(*)::numeric/GREATEST(COALESCE({RowsPerPage}, count(*))::numeric, 1)), 1) AS total_pages
          FROM S
        ), final AS (
          SELECT
            row_number() over() AS "RowNumber",
            (SELECT R.total_rows FROM R) AS "TotalRows",
            (SELECT R.total_pages FROM R) AS "TotalPages",
            *
          FROM S
          LIMIT COALESCE({RowsPerPage}, (SELECT R.total_rows FROM R))
          OFFSET (GREATEST((LEAST((SELECT R.total_pages FROM R), COALESCE({CurrentPage}, 1)) - 1)::integer, 0) * COALESCE({RowsPerPage}, (SELECT R.total_rows FROM R)))
        ), loan AS (
          SELECT DISTINCT loan_id
          FROM final
            JOIN collect.loan_client USING (loan_client_id)
        ), current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), loan_users AS (
          SELECT
            LC.loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            final
            JOIN collect.loan_client LC USING (loan_client_id)
          WHERE
            LC.user_id IS NOT NULL
          GROUP BY LC.loan_id
        ), allowed_loan AS (
          SELECT DISTINCT 
            L.loan_id,
            true AS loan_is_allowed
          FROM
            loan L
            LEFT JOIN loan_users LU USING(loan_id)
            LEFT JOIN current_user_info CUI ON true
          WHERE
            CUI.user_is_administrator OR
            (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
            {UserId} = ANY(LU.user_ids)
        ), loan_payment AS (
          SELECT
            L.loan_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            loan L
            JOIN collect.loan_client LC USING (loan_id)
            LEFT JOIN collect.loan_client_payment LCP USING (loan_client_id)
          GROUP BY L.loan_id
        ), loan_info AS (
          SELECT DISTINCT ON (loan_id)
            L.loan_id,
            GREATEST(COALESCE(L.debt_base, 0) + COALESCE(L.debt_percent, 0) + COALESCE(L.debt_penalty, 0) + COALESCE(L.debt_tax, 0) - COALESCE(LP.total_payment_sum, 0), 0) AS total_debt_rest_sum
          FROM
            loan
            JOIN collect.loan L USING (loan_id)
            LEFT JOIN loan_payment LP USING(loan_id)
        ), equifax_client_error AS (
          SELECT
            BE.client_id,
            string_agg(BE.error, E'\r\n') AS error
          FROM
            collect.bki_error BE
            JOIN collect.bki_type BT USING(bki_type_id)
          WHERE
            BT.name = 'equifax'
          GROUP BY BE.client_id
        ), equifax_loan_error AS (
          SELECT
            BE.loan_id,
            string_agg(BE.error, E'\r\n') AS error
          FROM
            collect.bki_error BE
            JOIN collect.bki_type BT USING(bki_type_id)
          WHERE
            BT.name = 'equifax'
          GROUP BY BE.loan_id
        ), was_exported_to_nbki AS (
          SELECT
            DISTINCT BED.loan_client_id,
            true AS was_exported_to_nbki
          FROM
            collect.bki_export BE
            LEFT JOIN collect.bki_type BT USING(bki_type_id)
            LEFT JOIN collect.bki_export_detail BED USING(bki_export_id)
          WHERE
            BT.name = 'nbki' AND
            BED.is_accepted
        ), was_exported_to_equifax AS (
          SELECT
            DISTINCT BED.loan_client_id,
            true AS was_exported_to_equifax
          FROM
            collect.bki_export BE
            LEFT JOIN collect.bki_type BT USING(bki_type_id)
            LEFT JOIN collect.bki_export_detail BED USING(bki_export_id)
          WHERE
            BT.name = 'equifax' AND
            BED.is_accepted
        ), was_exported_to_okb AS (
          SELECT
            DISTINCT BED.loan_client_id,
            true AS was_exported_to_okb
          FROM
            collect.bki_export BE
            LEFT JOIN collect.bki_type BT USING(bki_type_id)
            LEFT JOIN collect.bki_export_detail BED USING(bki_export_id)
          WHERE
            BT.name = 'okb' AND
            BED.is_accepted
        )
        SELECT
          F."RowNumber",
          F."TotalRows",
          F."TotalPages",
          COALESCE(loan_client_id = ANY({LoanClientId}::bigint[]), false) AS "ToExport",
          LC.loan_id AS "LoanId",
          LC.loan_client_id AS "LoanClientId",
          C.inner_org_id AS "InnerOrgId",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "ClientTitle",
          LC.unique_id AS "UniqueId",
          L.credit_number AS "CreditNumber",
          LC.is_main AS "IsMain",
          CL.short_title AS "ClaimantTitle",
          C.title AS "CessionTitle",
          LC.is_equifax_cancel AS "IsCancel",
          LI.total_debt_rest_sum AS "LoanTotalDebtRestSum",
          (ECE.error IS NOT NULL OR ELE.error IS NOT NULL) AS "HasEquifaxErrors",
          COALESCE(ECE.error || E'\r\n', '') || COALESCE(ELE.error, '') AS "EquifaxError",
          CASE WHEN COALESCE(WEN.was_exported_to_nbki, false) THEN 'Да' ELSE 'Нет' END AS "WasExportedToNbki",
          CASE WHEN COALESCE(WEE.was_exported_to_equifax, false) THEN 'Да' ELSE 'Нет' END AS "WasExportedToEquifax",
          CASE WHEN COALESCE(WEO.was_exported_to_okb, false) THEN 'Да' ELSE 'Нет' END AS "WasExportedToOkb",
          COALESCE(AL.loan_is_allowed, false) AS "CanEditLoan"
        FROM
          final F
          JOIN collect.loan_client LC USING(loan_client_id)
          LEFT JOIN collect.client_person CP USING(client_id)
          LEFT JOIN collect.loan L USING(loan_id)
          LEFT JOIN collect.cession C USING(cession_id)
          LEFT JOIN collect.claimant CL USING(claimant_id)
          LEFT JOIN loan_info LI USING(loan_id)
          LEFT JOIN equifax_client_error ECE USING(client_id)
          LEFT JOIN equifax_loan_error ELE USING(loan_id)
          LEFT JOIN was_exported_to_nbki WEN USING(loan_client_id)
          LEFT JOIN was_exported_to_equifax WEE USING(loan_client_id)
          LEFT JOIN was_exported_to_okb WEO USING(loan_client_id)
          LEFT JOIN allowed_loan AL USING(loan_id);
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanClientForOkbSelectSqlQuery">
      <Text>
        WITH filtered_loan AS (
          SELECT * FROM collect.filtered_bki_loan_client(
            {UserId}::smallint,
            'okb'::character varying,
            {CessionId}::bigint[],
            {ClaimantId}::bigint[],
            {InnerOrgId}::bigint[],
            {CreditNumber}::character varying,
            {LoanDebtRestFrom}::numeric,
            {LoanDebtRestTo}::numeric,
            {UniqueId}::character varying,
            {ClientTitle}::character varying,
            {IsCancel}::boolean,
            {WasExportedToNbki}::boolean,
            {WasExportedToEquifax}::boolean,
            {WasExportedToOkb}::boolean,
            {HasBkiErrors}::boolean,
            {ShowOnlyChecked}::boolean,
            {LoanClientId}::bigint[]
          )
        ), S AS (
          SELECT
            LC.loan_client_id
          FROM
            collect.loan_client LC
            JOIN filtered_loan USING (loan_client_id)
          ORDER BY LC.loan_id, LC.loan_client_id
        ), R AS (
          SELECT
            count(*) AS total_rows,
            COALESCE(CEIL(count(*)::numeric/GREATEST(COALESCE({RowsPerPage}, count(*))::numeric, 1)), 1) AS total_pages
          FROM S
        ), final AS (
          SELECT
            row_number() over() AS "RowNumber",
            (SELECT R.total_rows FROM R) AS "TotalRows",
            (SELECT R.total_pages FROM R) AS "TotalPages",
            *
          FROM S
          LIMIT COALESCE({RowsPerPage}, (SELECT R.total_rows FROM R))
          OFFSET (GREATEST((LEAST((SELECT R.total_pages FROM R), COALESCE({CurrentPage}, 1)) - 1)::integer, 0) * COALESCE({RowsPerPage}, (SELECT R.total_rows FROM R)))
        ), loan AS (
          SELECT DISTINCT loan_id
          FROM final
            JOIN collect.loan_client USING (loan_client_id)
        ), current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), loan_users AS (
          SELECT
            LC.loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            final
            JOIN collect.loan_client LC USING (loan_client_id)
          WHERE
            LC.user_id IS NOT NULL
          GROUP BY LC.loan_id
        ), allowed_loan AS (
          SELECT DISTINCT 
            L.loan_id,
            true AS loan_is_allowed
          FROM
            loan L
            LEFT JOIN loan_users LU USING(loan_id)
            LEFT JOIN current_user_info CUI ON true
          WHERE
            CUI.user_is_administrator OR
            (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
            {UserId} = ANY(LU.user_ids)
        ), loan_payment AS (
          SELECT
            L.loan_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            loan L
            JOIN collect.loan_client LC USING (loan_id)
            LEFT JOIN collect.loan_client_payment LCP USING (loan_client_id)
          GROUP BY L.loan_id
        ), loan_info AS (
          SELECT DISTINCT ON (loan_id)
            L.loan_id,
            GREATEST(COALESCE(L.debt_base, 0) + COALESCE(L.debt_percent, 0) + COALESCE(L.debt_penalty, 0) + COALESCE(L.debt_tax, 0) - COALESCE(LP.total_payment_sum, 0), 0) AS total_debt_rest_sum
          FROM
            loan
            JOIN collect.loan L USING (loan_id)
            LEFT JOIN loan_payment LP USING(loan_id)
        ), okb_client_error AS (
          SELECT
            BE.client_id,
            string_agg(BE.error, E'\r\n') AS error
          FROM
            collect.bki_error BE
            JOIN collect.bki_type BT USING(bki_type_id)
          WHERE
            BT.name = 'okb'
          GROUP BY BE.client_id
        ), okb_loan_error AS (
          SELECT
            BE.loan_id,
            string_agg(BE.error, E'\r\n') AS error
          FROM
            collect.bki_error BE
            JOIN collect.bki_type BT USING(bki_type_id)
          WHERE
            BT.name = 'okb'
          GROUP BY BE.loan_id
        ), was_exported_to_nbki AS (
          SELECT
            DISTINCT BED.loan_client_id,
            true AS was_exported_to_nbki
          FROM
            collect.bki_export BE
            LEFT JOIN collect.bki_type BT USING(bki_type_id)
            LEFT JOIN collect.bki_export_detail BED USING(bki_export_id)
          WHERE
            BT.name = 'nbki' AND
            BED.is_accepted
        ), was_exported_to_equifax AS (
          SELECT
            DISTINCT BED.loan_client_id,
            true AS was_exported_to_equifax
          FROM
            collect.bki_export BE
            LEFT JOIN collect.bki_type BT USING(bki_type_id)
            LEFT JOIN collect.bki_export_detail BED USING(bki_export_id)
          WHERE
            BT.name = 'equifax' AND
            BED.is_accepted
        ), was_exported_to_okb AS (
          SELECT
            DISTINCT BED.loan_client_id,
            true AS was_exported_to_okb
          FROM
            collect.bki_export BE
            LEFT JOIN collect.bki_type BT USING(bki_type_id)
            LEFT JOIN collect.bki_export_detail BED USING(bki_export_id)
          WHERE
            BT.name = 'okb' AND
            BED.is_accepted
        )
        SELECT
          F."RowNumber",
          F."TotalRows",
          F."TotalPages",
          COALESCE(loan_client_id = ANY({LoanClientId}::bigint[]), false) AS "ToExport",
          LC.loan_id AS "LoanId",
          LC.loan_client_id AS "LoanClientId",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "ClientTitle",
          LC.unique_id AS "UniqueId",
          L.credit_number AS "CreditNumber",
          LC.is_main AS "IsMain",
          CL.short_title AS "ClaimantTitle",
          C.title AS "CessionTitle",
          LC.is_okb_cancel AS "IsCancel",
          LI.total_debt_rest_sum AS "LoanTotalDebtRestSum",
          (OCE.error IS NOT NULL OR OLE.error IS NOT NULL) AS "HasOkbErrors",
          COALESCE(OCE.error || E'\r\n', '') || COALESCE(OLE.error, '') AS "OkbError",
          CASE WHEN COALESCE(WEN.was_exported_to_nbki, false) THEN 'Да' ELSE 'Нет' END AS "WasExportedToNbki",
          CASE WHEN COALESCE(WEE.was_exported_to_equifax, false) THEN 'Да' ELSE 'Нет' END AS "WasExportedToEquifax",
          CASE WHEN COALESCE(WEO.was_exported_to_okb, false) THEN 'Да' ELSE 'Нет' END AS "WasExportedToOkb",
          COALESCE(AL.loan_is_allowed, false) AS "CanEditLoan",
          C.inner_org_id AS "InnerOrgId"
        FROM
          final F
          JOIN collect.loan_client LC USING(loan_client_id)
          LEFT JOIN collect.client_person CP USING(client_id)
          LEFT JOIN collect.loan L USING(loan_id)
          LEFT JOIN collect.cession C USING(cession_id)
          LEFT JOIN collect.claimant CL USING(claimant_id)
          LEFT JOIN loan_info LI USING(loan_id)
          LEFT JOIN okb_client_error OCE USING(client_id)
          LEFT JOIN okb_loan_error OLE USING(loan_id)
          LEFT JOIN was_exported_to_nbki WEN USING(loan_client_id)
          LEFT JOIN was_exported_to_equifax WEE USING(loan_client_id)
          LEFT JOIN was_exported_to_okb WEO USING(loan_client_id)
          LEFT JOIN allowed_loan AL USING(loan_id);
      </Text>
    </SqlQuery>
    
    <SqlQuery Name="LoanClientIsCancelSelectSqlQuery">
      <Text>
        SELECT 
          loan_client_id AS "LoanClientId"
        FROM unnest({LoanClientId}::bigint[]) loan_client_id
          JOIN collect.loan_client LC USING (loan_client_id)
        WHERE 
          COALESCE(CASE {BkiType}
            WHEN 'okb' THEN LC.is_okb_cancel
            WHEN 'equifax' THEN LC.is_equifax_cancel
            WHEN 'nbki' THEN LC.is_nbki_cancel
          END, false)
      </Text>
    </SqlQuery>

    <SqlQuery Name="BkiExportSelectSqlQuery">
      <Text>
        WITH detail_records AS (
          SELECT
            bki_export_id,
            COUNT(bki_export_detail) AS total_count,
            SUM((is_accepted OR recreate_bki_export_id IS NOT NULL)::integer) AS success_count
          FROM collect.bki_export_detail
          GROUP BY bki_export_id
        )
        SELECT
          BE.bki_export_id AS "BkiExportId",
          BT.name AS "BkiName",
          BE.export_date AS "ExportDate",
          UI.user_full_name AS "UserTitle",
          substr(F.path, length(F.path) - strpos(reverse(F.path),'\') + 2) AS "FileName",
          F.guid AS "Guid",
          COALESCE(total_count, 0) = COALESCE(success_count, 0) AS "IsAccepted"
        FROM
          collect.bki_export BE
          LEFT JOIN detail_records USING (bki_export_id)
          LEFT JOIN collect.bki_type BT USING(bki_type_id)
          LEFT JOIN collect.user_info UI USING(user_id)
          LEFT JOIN public.file F USING(file_id)
        ORDER BY BE.export_date DESC, BE.bki_export_id DESC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="BkiExportDetailSelectSqlQuery">
      <Text>
        WITH loan AS (
          SELECT
            DISTINCT L.loan_id
          FROM
            collect.bki_export_detail BED
            LEFT JOIN collect.loan_client LC USING(loan_client_id)
            LEFT JOIN collect.loan L ON LC.loan_id = L.loan_id
        ), loan_payment AS (
          SELECT
            L.loan_id,
            SUM(LCP.sum) AS total_payment_sum
          FROM
            loan L
            LEFT JOIN collect.loan_client LC USING(loan_id)
            LEFT JOIN collect.loan_client_payment LCP USING(loan_client_id)
          GROUP BY L.loan_id
        ), loan_info AS (
          SELECT
            L.loan_id,
            GREATEST(COALESCE(L.debt_base, 0) + COALESCE(L.debt_percent, 0) + COALESCE(L.debt_penalty, 0) + COALESCE(L.debt_tax, 0) - COALESCE(LP.total_payment_sum, 0), 0) AS total_debt_rest_sum
          FROM
            loan
            LEFT JOIN collect.loan L USING(loan_id)
            LEFT JOIN loan_payment LP USING(loan_id)
        )
        SELECT
          BED.bki_export_id AS "BkiExportId",
          BED.bki_export_detail_id AS "BkiExportDetailId",
          BED.loan_client_id AS "LoanClientId",
          LC.loan_id AS "LoanId",
          BED.is_accepted AS "IsAccepted",
          BED.recreate_bki_export_id IS NOT NULL AS "ReCreated",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "Title",
          LI.total_debt_rest_sum AS "LoanTotalDebtRestSum",
          C.inner_org_id AS "InnerOrgId",
          BED.unique_id AS "UniqueId"
        FROM
          collect.bki_export_detail BED
          LEFT JOIN collect.loan_client LC USING(loan_client_id)
          LEFT JOIN collect.loan L ON LC.loan_id = L.loan_id
          LEFT JOIN collect.client_person CP USING(client_id)
          LEFT JOIN loan_info LI ON LC.loan_id = LI.loan_id
          LEFT JOIN collect.cession C USING (cession_id)
        ORDER BY "Title", "BkiExportDetailId";
      </Text>
    </SqlQuery>

    <SqlQuery Name="BkiLoanClientSelectSqlQuery">
      <Text>
        WITH client AS (
          SELECT
            DISTINCT client_id
          FROM
            collect.loan_client
          WHERE
            loan_client_id = ANY({Ids}::bigint[])
        ), loan AS (
          SELECT 
            DISTINCT loan_id
          FROM
            collect.loan_client
          WHERE
            loan_client_id = ANY({Ids}::bigint[])
        ), main_unique AS (
          SELECT DISTINCT ON (loan_id) 
            loan_id, 
            unique_id,
            R.bki_num
          FROM loan
            JOIN collect.loan_client USING (loan_id)
            LEFT JOIN collect.role R USING (role_id)
          ORDER BY loan_id, bki_num, R.title = 'Заемщик' DESC, is_main DESC
        ), figurants AS (
          SELECT 
            loan_id,
            SUM(CASE WHEN R.bki_num = 1 THEN 1 ELSE 0 END) AS debtors, 
            SUM(CASE WHEN R.bki_num = 2 THEN 1 ELSE 0 END) AS guarantors
          FROM loan L
            LEFT JOIN collect.loan_client LC USING (loan_id)
            LEFT JOIN collect.role R USING (role_id)
          GROUP BY loan_id
        ), last_export AS (
          SELECT 
            DISTINCT ON (loan_client_id)
            loan_client_id,
            unique_id
          FROM 
            unnest({Ids}::bigint[]) loan_client_id
            JOIN collect.bki_export_detail USING (loan_client_id)
            JOIN collect.bki_export USING (bki_export_id)
            JOIN collect.bki_type BT USING (bki_type_id)
          WHERE 
            BT.name = {BkiType} AND is_accepted
          ORDER BY loan_client_id, export_date DESC
        ), events AS (
          SELECT * 
          FROM collect.get_bki_events({BkiType}::character varying, {Ids}::bigint[])
        )
        SELECT
          ROW_NUMBER() OVER(ORDER BY LC.loan_client_id, BET.order_number, EV.event_date) AS "RowNumber",
          LC.loan_client_id AS "LoanClientId",
          LC.loan_id AS "LoanId",
          LC.client_id AS "ClientId",
          L.credit_number AS "CreditNumber",
          -- пока только физ. лица
          true AS "IsPerson",
          
          BET.number AS "EventNumber",
          BET.name AS "EventName",
          BET.operation AS "EventOperation",
          EV.event_date AS "EventDate",
          EV.remove_event AS "IsEventRemove",
          
          C.first_name AS "Surname", 
          C.second_name AS "Name",
          C.third_name AS "Patronymic", 
          
          643 AS "BirthOksm",
          C.birth_date AS "BirthDate",
          C.birth_place  AS "BirthPlace",
          
          643 AS "DocOksm",
          21 AS "DocType",
          C.passport_series AS "DocSerial",
          C.passport_number AS "DocNumber",
          C.passport_given_date AS "DocIssueDate",
          C.passport_given_by AS "DocWho",
          C.passport_code AS "DocDepartmentCode",
          null AS "DocEndDate",
          
          1 AS "TaxCode",
          C.inn AS "TaxNum",
          C.is_special_tax_regime AS "SpecialTaxRegimeInd",
          C.snils AS "Snils",
          null AS "RegNum",
          
          C.email AS "Email",
          false AS "SoleProprietorInd",
          null AS "SoleProprietorDateReg",
          
          'RUB' AS "CreditCurrency",
          COALESCE(CASE WHEN remove_event THEN LE.unique_id END, LC.unique_id) AS "Uid", -- УИД сделки
          R.bki_num  AS "Role",
          L.credit_date AS "CreditDate",
          CASE WHEN R.bki_num = 1 THEN 1 ELSE 9 END AS "TradeType",
          CT.bki_num AS "CreditType",
          CLT.bki_num AS "CreditLineType",
          CP.bki_num AS "CreditPurpose",
          L.credit_end_date AS "CreditEndDate",
          false AS "IssuedTranchesInd",
          FCT.bki_num AS "CreditorType",
          
          L.credit_date AS "TrancheDate",
          null AS "TrancheNumber",
          
          CASE 
            WHEN R.bki_num = 1 THEN COALESCE(L.credit_sum, 0)
            WHEN R.bki_num = 2 THEN COALESCE(LC.surety_sum, L.credit_sum, 0)
          END AS "CreditSum",
          CASE
            WHEN close_event THEN 0
            ELSE GREATEST(D.debt_all, 0)
          END AS "SecuredSum",
          'RUB' AS "SecuredCurrency",
          MU.unique_id AS "SecuredUid",
          CASE WHEN MU.bki_num = 1 THEN 1 ELSE 9 END AS "SecuredTradeType",
          
          GREATEST(F.debtors - (R.bki_num = 1)::integer, 0) AS "SolidaryCount",
          F.guarantors - (R.bki_num = 2)::integer > 0 AS "GuarantorInd",
          
          L.full_price_percent AS "CreditTotalPercent",
          L.full_price AS "CreditTotalMonetary",
          
          CASE 
            WHEN close_event THEN 0
            ELSE GREATEST(D.debt_all, 0)
          END AS "AveragePaymentSum",
          false AS "AmendMentInd",
          EV.last_payment_ind AS "LastPaymentInd",
          
          --общие данные о долге
          CASE 
            WHEN R.bki_num = 1 THEN COALESCE(L.credit_sum, 0)
            WHEN R.bki_num = 2 THEN COALESCE(LC.surety_sum, L.credit_sum, 0)
          END AS "ArrearStartSum",
          CASE 
            WHEN close_event THEN 0
            ELSE GREATEST(D.debt_all, 0)
          END AS "ArrearSum",
          CASE 
            WHEN close_event THEN 0
            ELSE GREATEST(D.debt_base, 0)
          END AS "ArrearBase",
          CASE 
            WHEN close_event THEN 0
            ELSE GREATEST(D.debt_percent, 0)
          END AS "ArrearPercent",
          CASE 
            WHEN close_event THEN 0
            ELSE GREATEST(D.debt_other, 0)
          END AS "ArrearOther",
          
          --просроченный долг
          L.overdue_date AS "PastDueArrearStartDate",
          CASE WHEN close_event OR GREATEST(D.debt_base, 0) = 0 THEN null ELSE L.overdue_date END AS "BaseMissPaymentDate",
          CASE WHEN close_event OR GREATEST(D.debt_percent, 0) = 0 THEN null ELSE L.overdue_date END AS "PercentMissPaymentDate",
          
          -- последняя оплата
          COALESCE(last_pay_date, EV.event_date)::date AS "LastPaymentDate",
          D.last_pay_all AS "LastPaymentSum",
          D.last_pay_base AS "LastPaymentBase",
          D.last_pay_percent AS "LastPaymentPercent",
          D.last_pay_other AS "LastPaymentOther",
          
          -- все оплаты
          COALESCE(L.debt_base, 0) + COALESCE(L.debt_percent, 0) + COALESCE(L.debt_penalty, 0) + COALESCE(L.debt_tax, 0) - D.debt_all AS "TotalPaymentSum", 
          COALESCE(L.debt_base, 0) - D.debt_base AS "TotalPaymentBase",
          COALESCE(L.debt_percent, 0) - D.debt_percent AS "TotalPaymentPercent",
          COALESCE(L.debt_penalty, 0) + COALESCE(L.debt_tax, 0) - D.debt_other AS "TotalPaymentOther",
          
          CASE WHEN D.debt_all > 0 THEN 2 ELSE 1 END AS "SizeKeepCode", --соблюдение размера платежей
          3 AS "TermsKeepCode", -- соблюдение срока внесения платежей
          99 AS "TermsFrequency",
          
          CASE 
            WHEN close_event OR GREATEST(D.debt_all, 0) = 0 THEN false
            ELSE EV.event_date::date - (L.overdue_date::date - '1d'::interval)::date > 90 
          END AS "OverdueGreater90Ind",
          GREATEST(CASE
            WHEN close_event OR GREATEST(D.debt_all, 0) = 0
            THEN 0 ELSE EV.event_date::date - (L.overdue_date::date - '1d'::interval)::date
          END, 0) AS "DaysPastDue", -- проолжительность просрочки
          
          close_event AS "TerminationInd",
          COALESCE(CASE 
            WHEN close_event
            THEN
              CASE 
                WHEN R.bki_num = 1 OR CR.bki_num IN (1, 2) THEN CR.bki_num 
              END
          END, 99) AS "TerminationCode",
          CASE WHEN close_event THEN LC.close_date END AS "TerminationDate",
          
          CASE WHEN sold_event THEN 3 END AS "StopCode",
          CASE WHEN sold_event THEN LC.sale_date END AS "StopDate",
          
          true AS "AccountingInd",
          L.is_floating_credit_rate AS "FloatingCreditRateInd",
          L.credit_rate AS "CreditRate",
          false AS "SupportedInd",
          null AS "SupportInfo"
        FROM
          collect.loan_client LC
          LEFT JOIN collect.status USING (status_id)
          LEFT JOIN collect.close_reason CR USING (close_reason_id)
          LEFT JOIN collect.client_person C USING (client_id)
          LEFT JOIN collect.role R USING(role_id)
          LEFT JOIN collect.loan L USING(loan_id)
          LEFT JOIN collect.cession CS USING(cession_id)
          LEFT JOIN collect.claimant FC ON COALESCE(L.first_claimant_id, CS.claimant_id) = FC.claimant_id
          LEFT JOIN collect.claimant_type FCT USING (claimant_type_id)
          LEFT JOIN collect.credit_type CT USING(credit_type_id)
          LEFT JOIN collect.credit_line_type CLT USING (credit_line_type_id)
          LEFT JOIN collect.credit_purpose CP USING(credit_purpose_id)
          LEFT JOIN figurants F USING (loan_id)
          LEFT JOIN main_unique MU USING (loan_id)
          LEFT JOIN last_export LE USING (loan_client_id)
          LEFT JOIN events EV USING (loan_client_id)
          LEFT JOIN LATERAL (SELECT * FROM collect.get_loan_distributed_data(L.loan_id::bigint, EV.event_date::date)) D ON TRUE
          LEFT JOIN collect.bki_event_type BET USING (bki_event_type_id)
        WHERE 
          LC.loan_client_id = ANY({Ids}::bigint[])
        ORDER BY LC.loan_client_id, BET.order_number, EV.event_date;
      </Text>
    </SqlQuery>

    <SqlQuery Name="BkiContactSelectSqlQuery">
      <Text>
        SELECT 
          phone_number AS "PhoneNumber",
          title AS "PhoneComment"
        FROM 
          collect.client_phone
          LEFT JOIN collect.phone_type USING (phone_type_id)
        WHERE client_id = {ClientId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="BkiAddressSelectSqlQuery">
      <Text>
        WITH registration_address AS (
          SELECT
            DISTINCT ON (CA.client_id)
            CA.client_id,
            A.address_index AS index,
            A.address_okato AS okato,
            AC.title AS location,
            AST.title AS street,
            A.address_building AS house,
            A.address_block AS block,
            A.address_flat AS apartment,
            collect.get_bki_address_string(A.address_index, A.address_okato, AC.title, AST.title, A.address_building, A.address_block, A.address_flat) AS addr_str
          FROM collect.client_address CA
            JOIN collect.address_type AT USING(address_type_id)
            LEFT JOIN collect.address A USING(address_id)
            LEFT JOIN collect.address_city AC USING(address_city_id)
            LEFT JOIN collect.address_street AST USING(address_street_id)
          WHERE
            AT.title = 'Регистрация' AND CA.client_id = {ClientId}
        ), actual_address AS (
          SELECT
            DISTINCT ON (CA.client_id)
            CA.client_id,
            A.address_index AS index,
            A.address_okato AS okato,
            AC.title AS location,
            AST.title AS street,
            A.address_building AS house,
            A.address_block AS block,
            A.address_flat AS apartment,
            collect.get_bki_address_string(A.address_index, A.address_okato, AC.title, AST.title, A.address_building, A.address_block, A.address_flat) AS addr_str
          FROM collect.client_address CA
            JOIN collect.address_type AT USING(address_type_id)
            LEFT JOIN collect.address A USING(address_id)
            LEFT JOIN collect.address_city AC USING(address_city_id)
            LEFT JOIN collect.address_street AST USING(address_street_id)
          WHERE
            AT.title IN ('Проживание', 'Регистрация') AND CA.client_id = {ClientId}
          ORDER BY CA.client_id, AT.title = 'Регистрация'
        )
        SELECT 
          643 AS "AddrOksm",
          RA.index AS "PostalCode",
	      RA.okato AS "Okato",
          RA.location AS "OtherLocation",
          RA.street AS "Street",
          RA.house AS "HouseNumber",
          RA.block AS "Block",
          null AS "Building",
          RA.apartment AS "Apartment",
          
          643 AS "AddrOksmTemp",
          COALESCE(trim(lower(RA.addr_str)) != trim(lower(AA.addr_str)), false) AS "TempAddressDifferentInd",
          AA.index AS "PostalCodeTemp",
          AA.okato AS "OkatoTemp",
          AA.location AS "OtherLocationTemp",
          AA.street AS "StreetTemp",
          AA.house AS "HouseNumberTemp",
          AA.block AS "BlockTemp",
          null AS "BuildingTemp",
          AA.apartment AS "ApartmentTemp"
        FROM collect.client C
		  LEFT JOIN registration_address RA USING (client_id)
		  LEFT JOIN actual_address AA USING (client_id)
        WHERE C.client_id = {ClientId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="BkiGuaranteeSelectSqlQuery">
      <Text>
        SELECT 
          'RUB' AS "GuaranteeCurrency",
          LC.unique_id AS "GuaranteeUid", --УИД поручительства
          COALESCE(LC.surety_sum, L.credit_sum, 0) AS "GuaranteeSum",
          L.credit_date AS "GuaranteeAgreementDate",
          L.credit_end_date AS "GuaranteeExpirationDate",
          CASE 
            WHEN S.is_finish_status 
            THEN LC.close_date 
          END AS "GuaranteeFactExpirationDate",
          CASE 
            WHEN S.is_finish_status 
            THEN
              CASE WHEN CR.bki_num IN (1, 2) THEN CR.bki_num ELSE 99 END
          END AS "GuaranteeEndReason"
        FROM
          collect.loan_client LC
          LEFT JOIN collect.status S USING (status_id)
          LEFT JOIN collect.loan L USING (loan_id)
          LEFT JOIN collect.close_reason CR USING (close_reason_id)
          LEFT JOIN collect.role R USING (role_id)
        WHERE
          LC.loan_id = {LoanId}::bigint AND 
          LC.loan_client_id != {LoanClientId}::bigint AND
          R.bki_num = 2;
      </Text>
    </SqlQuery>

    <SqlQuery Name="BkiErrorUpdateSqlQuery">
      <Text>
        DELETE FROM
          collect.bki_error
        WHERE
          (client_id = {ClientId} OR loan_id = {LoanId}) AND
          bki_type_id = (SELECT bki_type_id FROM collect.bki_type WHERE name = {BkiType});

        INSERT INTO collect.bki_error(
          bki_type_id,
          error,
          client_id)
        SELECT
          bki_type_id,
          unnest({ClientError}::character varying[]),
          {ClientId}
        FROM
          collect.bki_type
        WHERE
          name = {BkiType};

        INSERT INTO collect.bki_error(
          bki_type_id,
          error,
          loan_id)
        SELECT
          bki_type_id,
          unnest({LoanError}::character varying[]),
          {LoanId}
        FROM
          collect.bki_type
        WHERE
          name = {BkiType};
      </Text>
    </SqlQuery>

    <SqlQuery Name="BkiExportInsertSqlQuery">
      <Text>
        SELECT collect.bki_export_insert(
          {BkiType}::character varying,
          {Guid}::character varying,
          {RemoveGuid}::character varying,
          {LoanClientId}::bigint[],
          {RemoveLoanClientId}::bigint[],
          {ReCreateBkiExportId}::bigint,
          {UserId}::smallint
        );
      </Text>
    </SqlQuery>

    <SqlQuery Name="BkiExportDetailUpdateSqlQuery">
      <Text>
        UPDATE
          collect.bki_export_detail
        SET
          is_accepted = {IsAccepted}
        WHERE
          bki_export_detail_id = ANY({BkiExportDetailId}::bigint[]) AND
          recreate_bki_export_id IS NULL AND
          is_accepted != {IsAccepted};

        UPDATE
          collect.loan_client LC
        SET
          is_nbki_exported = {IsAccepted}
        FROM (
          SELECT
            BED.loan_client_id,
            BT.name AS bki_name
          FROM
            collect.bki_export BE
            LEFT JOIN collect.bki_type BT USING(bki_type_id)
            LEFT JOIN collect.bki_export_detail BED USING(bki_export_id)
          WHERE
            bki_export_detail_id = ANY({BkiExportDetailId}::bigint[]) AND
            recreate_bki_export_id IS NULL AND
            is_accepted != {IsAccepted}
        ) T
        WHERE
          LC.loan_client_id = T.loan_client_id AND
          T.bki_name = 'nbki';

        UPDATE
          collect.loan_client LC
        SET
          is_equifax_exported = {IsAccepted}
        FROM (
          SELECT
            BED.loan_client_id,
            BT.name AS bki_name
          FROM
            collect.bki_export BE
            LEFT JOIN collect.bki_type BT USING(bki_type_id)
            LEFT JOIN collect.bki_export_detail BED USING(bki_export_id)
          WHERE
            bki_export_detail_id = ANY({BkiExportDetailId}::bigint[]) AND
            recreate_bki_export_id IS NULL AND
            is_accepted != {IsAccepted}
        ) T
        WHERE
          LC.loan_client_id = T.loan_client_id AND
          T.bki_name = 'equifax';

        UPDATE
          collect.loan_client LC
        SET
          is_okb_exported = {IsAccepted}
        FROM (
          SELECT
            BED.loan_client_id,
            BT.name AS bki_name
          FROM
            collect.bki_export BE
            LEFT JOIN collect.bki_type BT USING(bki_type_id)
            LEFT JOIN collect.bki_export_detail BED USING(bki_export_id)
          WHERE
            bki_export_detail_id = ANY({BkiExportDetailId}::bigint[]) AND
            recreate_bki_export_id IS NULL AND
            is_accepted != {IsAccepted}
        ) T
        WHERE
          LC.loan_client_id = T.loan_client_id AND
          T.bki_name = 'okb';
      </Text>
    </SqlQuery>

    <SqlQuery Name="BkiErrorsSelectSqlQuery">
      <Text>
        WITH errors AS (
          SELECT
            BE.error,
            BE.loan_id,
            BE.client_id,
            BT.title
          FROM
            collect.bki_error BE
            LEFT JOIN collect.bki_type BT USING (bki_type_id)
          WHERE
            bki_type_id IS NOT NULL AND
            BT.name = {BkiType}
        ), distinct_client_ids AS(
          SELECT
            DISTINCT client_id
          FROM
            errors
        ), distinct_loan_ids AS(
          SELECT
            DISTINCT loan_id
          FROM
            errors
        ), client_info AS(
          SELECT
            CP.client_id,
            collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS client,
            string_agg(DISTINCT trim(L.credit_number || ' (цессия:' || C.title || ')'), ', ') AS credit_numbers
          FROM
            distinct_client_ids DCI
            JOIN collect.loan_client LC USING(client_id)
            LEFT JOIN collect.client_person CP USING (client_id)
            LEFT JOIN collect.loan L USING (loan_id)
            LEFT JOIN collect.cession C USING (cession_id)
          GROUP BY CP.client_id
        ), loan_info AS(
          SELECT
            L.loan_id,
            L.credit_number,
            CS.title AS cession_number,
            string_agg(collect.get_client_title(CP.first_name, CP.second_name, CP.third_name), ', ') as clients
          FROM
            distinct_loan_ids DLI
            JOIN collect.loan L USING(loan_id)
            LEFT JOIN collect.cession CS USING (cession_id)
            LEFT JOIN collect.loan_client LC USING (loan_id)
            LEFT JOIN collect.client_person CP USING (client_id)
          GROUP BY L.loan_id, CS.cession_id
        )
        SELECT
          COALESCE(LI.credit_number, CI.credit_numbers) AS "CreditNumber",
          COALESCE(LI.clients, CI.client) AS "ClientTitle",
          LI.cession_number AS "CessionNumber",
          error AS "Error",
          CASE
            WHEN E.client_id IS NULL THEN 'loan_error_type'
            ELSE 'client_error_type'
          END AS "Type",
          E.title AS "BkiTypeTitle"
        FROM
          errors E
          LEFT JOIN client_info CI USING (client_id)
          LEFT JOIN loan_info LI USING (loan_id);
      </Text>
    </SqlQuery>
    
    <SqlQuery Name="BkiExportSetNotAcceptedFromFileSqlQuery">
      <Text>
        SELECT collect.loan_client_bki_not_accepted_update(
          {ErrorFileName}::character varying, 
          {BkiExportId}::bigint, 
          {UidArray}::character varying[], 
          {UidArrayIsCancel}::character varying[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="BkiIsCancelUpdateSqlQuery">
      <Text>
        UPDATE collect.loan_client 
        SET
          is_okb_cancel = CASE WHEN {BkiType} = 'okb' THEN {IsCancel} ELSE is_okb_cancel END,
          is_equifax_cancel = CASE WHEN {BkiType} = 'equifax' THEN {IsCancel} ELSE is_equifax_cancel END,
          is_nbki_cancel = CASE WHEN {BkiType} = 'nbki' THEN {IsCancel} ELSE is_nbki_cancel END
        WHERE 
          loan_client_id = {LoanClientId};
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===ФССП=====================================================-->
    <!--============================================================-->
    <SqlQuery Name="FsspInfoSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids,
            (SELECT list_client FROM collect.user_info WHERE user_id = {UserId}) AS list_client
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}
        ), loan_users AS (
          SELECT
            loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client
          WHERE
            user_id IS NOT NULL
          GROUP BY loan_id
        ), allowed_client AS (
          SELECT
            DISTINCT client_id
          FROM
            collect.client
            LEFT JOIN collect.loan_client USING(client_id)
            LEFT JOIN loan_users LU USING(loan_id)
            LEFT JOIN current_user_info CUI ON true
          WHERE
            (NOT (list_client = 'none') AND
            (list_client = 'full' OR
            (list_client = 'partial' AND
             (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
             {UserId} = ANY(LU.user_ids))))
        ), S AS (
          SELECT
            FC.fssp_checking_id AS "FsspCheckingId",
            FC.check_date AS "CheckDate",
            collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "ClientTitle",
            FC.executive AS "Executive",
            FC.details AS "Details",
            FC.executive_end AS "ExecutiveEnd",
            FC.subject AS "Subject",
            FC.debt_rest_sum AS "DebtRestSum",
            FC.department AS "Department",
            FC.bailiff AS "Bailiff",
            FC.user_id AS "UserId",
            FC.executive_number AS "ExecutiveNumber",
            FC.executive_date AS "ExecutiveDate",
            FC.details_type AS "DetailsType",
            FC.details_number AS "DetailsNumber",
            FC.details_date AS "DetailsDate",
            FC.issuer AS "Issuer",
            FC.executive_reason_end AS "ExecutiveReasonEnd",
            FC.department_address AS "DepartmentAddress",
            FC.bailiff_phone AS "BailiffPhone",
            FC.executive_number_consolidated AS "ExecutiveNumberConsolidated",
            FC.executive_end_date AS "ExecutiveEndDate"
          FROM
            allowed_client AC
            LEFT JOIN collect.client C USING(client_id)
            LEFT JOIN collect.client_person CP USING(client_id)
            JOIN collect.fssp_checking FC USING(client_id)
          WHERE
            NOT C.deleted AND
            ({CheckDateFrom} IS NULL OR date_trunc('minute', FC.check_date) >= date_trunc('minute', {CheckDateFrom}::timestamp)) AND
            ({CheckDateTo} IS NULL OR date_trunc('minute', FC.check_date) <![CDATA[<=]]> date_trunc('minute', {CheckDateTo}::timestamp)) AND
            (COALESCE({ClientTitle}, '') = '' OR
              collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) ILIKE '%' || {ClientTitle} ||'%') AND
            (COALESCE({Executive}, '') = '' OR FC.executive ILIKE '%' || {Executive} ||'%') AND
            (COALESCE({Details}, '') = '' OR FC.details ILIKE '%' || {Details} ||'%') AND
            (COALESCE({Subject}, '') = '' OR FC.subject ILIKE '%' || {Subject} ||'%') AND
            (COALESCE({Department}, '') = '' OR FC.department ILIKE '%' || {Department} ||'%') AND
            (COALESCE({Bailiff}, '') = '' OR FC.bailiff ILIKE '%' || {Bailiff} ||'%') AND
            ({FsspUserId}::smallint[] = ARRAY[NULL]::smallint[] OR FC.user_id = ANY({FsspUserId}::integer[])) AND
            is_paid = {FsspCheckType}::boolean
          ORDER BY "ClientTitle", FC.check_date DESC, FC.fssp_checking_id DESC
        ), R AS (
          SELECT
            count(*) AS total_rows,
            COALESCE(CEIL(count(*)::numeric/GREATEST(COALESCE({RowsPerPage}, count(*))::numeric, 1)), 1) AS total_pages
          FROM
            S
        )
        SELECT
          row_number() over() AS "RowNumber",
          (SELECT R.total_rows FROM R) AS "TotalRows",
          (SELECT R.total_pages FROM R) AS "TotalPages",
          *
        FROM
          S
        LIMIT COALESCE({RowsPerPage}, (SELECT R.total_rows FROM R))
        OFFSET (GREATEST((LEAST((SELECT R.total_pages FROM R), COALESCE({CurrentPage}, 1)) - 1)::integer, 0) * COALESCE({RowsPerPage}, (SELECT R.total_rows FROM R)));
      </Text>
    </SqlQuery>

    <SqlQuery Name="FsspInfoByLoanIdSelectSqlQuery">
      <Text>
        WITH executive_number AS (
          SELECT
            fssp_checking_id,
            trim((regexp_matches(FC.executive, '(.*)\sот\s(\d{1,2}\.\d{2}\.\d{2,4})', 'g'))[1]) AS executive_number
          FROM
            collect.fssp_checking FC
            JOIN collect.loan_client LC USING(client_id)
          WHERE
            LC.loan_id = {LoanId}
        )
        SELECT
          FC.fssp_checking_id AS "FsspCheckingId",
          FC.check_date AS "CheckDate",
          FC.client_title AS "ClientTitle",
          COALESCE(EN.executive_number, FC.executive, FC.executive_number) AS "ExecutiveNumber",
          COALESCE(FC.executive, FC.executive_number) AS "Executive",
          FC.details AS "Details",
          FC.subject AS "Subject",
          FC.debt_rest_sum AS "DebtRestSum",
          FC.department AS "Department",
          FC.bailiff AS "Bailiff",
          FC.executive_end AS "ExecutiveEnd",
          LC.client_id AS "ClientId",
          FC.executive_date AS "ExecutiveDate",
          FC.executive_end_date AS "ExecutiveEndDate",
          FC.executive_reason_end AS "ExecutiveReasonEnd",
          FC.executive_number_consolidated AS "ExecutiveNumberConsolidated",
          FC.details_type AS "DetailsType",
          FC.details_number AS "DetailsNumber",
          FC.details_date AS "DetailsDate",
          FC.issuer AS "Issuer",
          FC.department_address AS "DepartmentAddress",
          FC.bailiff_phone AS "BailiffPhone",
          FC.is_paid AS "IsPaid",
          FC.user_id AS "UserId"
        FROM
          collect.fssp_checking FC
          JOIN collect.loan_client LC USING(client_id)
          LEFT JOIN executive_number EN USING(fssp_checking_id)
        WHERE
          LC.loan_id = {LoanId}
        ORDER BY FC.check_date DESC, FC.fssp_checking_id DESC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="FsspInfoForApplySelectSqlQuery">
      <Text>
        SELECT
          court_document_id AS "CourtDocumentId",
          court_document_number AS "CourtDocumentNumber",
          court_document_date AS "CourtDocumentDate",
          court_id AS "CourtId",
          executive_number AS "ExecutiveNumber",
          executive_start_date AS "ExecutiveStartDate",
          executive_end_reason AS "ExecutiveEndReason",
          executive_end_date AS "ExecutiveEndDate",
          osp_id AS "OspId",
          bailiff_title AS "BailiffTitle",
          bailiff_phone AS "BailiffPhone",
          fssp_debt AS "FsspDebt"
        FROM
          collect.get_fssp_info({FsspCheckingId}::bigint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="FsspTaskSelectSqlQuery">
      <Text>
        WITH client AS (
          SELECT
            FCT.task,
            unnest(debtor_id) AS client_id
          FROM
            collect.fssp_checking_task FCT
            LEFT JOIN (SELECT collect.is_administrator({UserId}::smallint) AS user_is_admin) AI ON true
          WHERE
            (AI.user_is_admin OR FCT.user_id = {UserId}::smallint) AND
            NOT user_check
        ), distinct_client AS (
          SELECT
            DISTINCT client_id,
            task
          FROM
            client
        ), client_info AS (
          SELECT
            C.task,
            string_agg(collect.get_client_title(CP.first_name, CP.second_name, CP.third_name, false), ', ') AS client_titles,
            string_agg(collect.get_client_title(CP.first_name, CP.second_name, CP.third_name, true), ', ') AS short_client_titles
          FROM
            distinct_client C
            JOIN collect.client_person CP USING(client_id)
          GROUP BY C.task
        )
        SELECT
          FCT.task AS "Task",
          FCT.status AS "Status",
          FCT.ready AS "Ready",
          FCT.error AS "Error",
          FCT.date_start AS "DateStart",
          FCT.check_date AS "CheckDate",
          CI.short_client_titles AS "ShortClientTitle",
          CI.client_titles AS "ClientTitle",
          UI.user_full_name AS "UserTitle"
        FROM
          collect.fssp_checking_task FCT
          LEFT JOIN client_info CI USING(task)
          LEFT JOIN collect.user_info UI USING(user_id)
          LEFT JOIN (SELECT collect.is_administrator({UserId}::smallint) AS user_is_admin) AI ON true
        WHERE
          (AI.user_is_admin OR FCT.user_id = {UserId}::smallint) AND
          NOT user_check;
      </Text>
    </SqlQuery>

    <SqlQuery Name="FsspTaskUpdateSqlQuery">
      <Text>
        UPDATE
          collect.fssp_checking_task
        SET
          user_check = true
        WHERE
          Task = ANY({Task}::character varying[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="FileByGuidSqlQuery">
      <Text>
        SELECT
          file_id AS "FileId",
          name AS "Name",
          path AS "Path",
          date AS "Date"
        FROM
          public.file
        WHERE
          guid = {GUID};
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--===Список фильтров автозадач===-->
    <!--============================================================-->
    <SqlQuery Name="AutotaskFilterSelectSqlQuery">
      <Text>
        WITH autotask_filter_responsible_user AS (
          SELECT
            autotask_filter_id,
            user_full_name AS title
          FROM
            collect.autotask_filter_responsible_user
            LEFT JOIN collect.user_info USING(user_id)

          UNION ALL

          SELECT
            autotask_filter_id,
            'Ответственный специалист по делу'
          FROM
            collect.autotask_filter
          WHERE
            responsible_for_loan

          UNION ALL

          SELECT
            autotask_filter_id,
            'Ведущий специалист'
          FROM
            collect.autotask_filter
          WHERE
            lead_specialist_responsible_for_loan
        ), autotask_responsible_user_info AS (
          SELECT
            autotask_filter_id,
            collect.get_title_from_array(
              array_agg(title),
              'исполнител'::varchar, 2::smallint, ARRAY['ь','я','ей']::varchar[]) AS responsible_user_titles
          FROM
            autotask_filter_responsible_user
          GROUP BY
            autotask_filter_id
        )
        SELECT
          AF.autotask_filter_id AS "AutotaskFilterId",
          AF.title AS "Title",
          TT.title AS "TaskType",
          AF.create_date AS "CreateDate",
          AF.deadline_type AS "DeadlineType",
          CASE WHEN AF.deadline_type THEN AF.deadline::date ELSE null::date END AS "DeadlineDate",
          CASE WHEN NOT AF.deadline_type THEN 'через ' || AF.deadline::integer || ' дней' END AS "DeadlineLaterText",
          ARUI.responsible_user_titles AS "ResponsibleUserTitles",
          AF.description AS "Description",
          AF.archive AS "Archive",
          AF.filter AS "Filter"
        FROM
          collect.autotask_filter AF
          LEFT JOIN autotask_responsible_user_info ARUI USING(autotask_filter_id)
          LEFT JOIN collect.task_type TT USING(task_type_id)
        ORDER BY
          AF.title ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AutotaskFilterByIdSelectSqlQuery">
      <Text>
        SELECT
          autotask_filter_id AS "AutotaskFilterId",
          title AS "Title",
          task_type_id AS "TaskTypeId",
          create_date AS "CreateDate",
          edit_date AS "EditDate",
          deadline_type AS "DeadlineType",
          CASE WHEN deadline_type THEN deadline::date END AS "DeadlineDate",
          CASE WHEN NOT deadline_type THEN deadline::integer END AS "DeadlineLater",
          description AS "Description",
          archive AS "Archive",
          filter AS "Filter",
          responsible_for_loan AS "ResponsibleForLoan",
          lead_specialist_responsible_for_loan AS "LeadSpecialistResponsibleForLoan"
        FROM
          collect.autotask_filter
        WHERE
          autotask_filter_id = {AutotaskFilterId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ResponsibleUserIdByAutotaskFilterIdSelectSqlQuery">
      <Text>
        SELECT
          user_id::character varying AS "ResponsibleUserId"
        FROM
          collect.autotask_filter_responsible_user
        WHERE
          autotask_filter_id = {AutotaskFilterId}

        UNION

        SELECT
          'responsible_for_loan'
        FROM
          collect.autotask_filter
        WHERE
          autotask_filter_id = {AutotaskFilterId} AND
          responsible_for_loan

        UNION

        SELECT
          'leading_specialist'
        FROM
          collect.autotask_filter
        WHERE
          autotask_filter_id = {AutotaskFilterId} AND
          lead_specialist_responsible_for_loan;
      </Text>
    </SqlQuery>

    <SqlQuery Name="AutotaskFilterInsertSqlQuery">
      <Text>
        SELECT collect.autotask_insert(
          {Title}::character varying,
          {TaskTypeId}::bigint,
          {DeadlineType}::boolean,
          {Deadline}::character varying,
          {Description}::character varying,
          {Filter}::json,
          {UserId}::smallint,
          {ResponsibleForLoan}::boolean,
          {LeadSpecialistResponsibleForLoan}::boolean,
          {ResponsibleUserId}::smallint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="AutotaskFilterUpdateSqlQuery">
      <Text>
        UPDATE
          collect.autotask_filter
        SET
          title = {Title},
          task_type_id = {TaskTypeId},
          edit_date = collect.convert_date_now()::date,
          deadline_type = {DeadlineType},
          deadline = {Deadline},
          description = {Description},
          filter = {Filter},
          responsible_for_loan = {ResponsibleForLoan},
          lead_specialist_responsible_for_loan = {LeadSpecialistResponsibleForLoan}
        WHERE
          autotask_filter_id = {AutotaskFilterId};

        DELETE FROM
          collect.autotask_filter_responsible_user
        WHERE
          autotask_filter_id = {AutotaskFilterId} AND
          user_id != ALL({ResponsibleUserId}::smallint[]);

        INSERT INTO collect.autotask_filter_responsible_user(
          user_id,
          autotask_filter_id)
        SELECT
          user_id,
          {AutotaskFilterId}
        FROM
          collect.user
        WHERE
          user_id = ANY({ResponsibleUserId}::smallint[]) AND
          user_id != ALL(
            SELECT
              user_id
            FROM
              collect.autotask_filter_responsible_user
            WHERE
              autotask_filter_id = {AutotaskFilterId});
      </Text>
    </SqlQuery>

    <SqlQuery Name="AutotaskFilterArchiveSqlQuery">
      <Text>
        UPDATE
          collect.autotask_filter
        SET
          archive = NOT archive
        WHERE
          autotask_filter_id = {AutotaskFilterId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="AutotaskFieldsSelectSqlQuery">
      <Text>
        SELECT
          column_name AS "ColumnName",
          title AS "Title",
          type AS "Type"
        FROM
          collect.autotask_field;
      </Text>
    </SqlQuery>
    <!--============================================================-->
    <!--======================Email - центр=========================-->
    <!--============================================================-->

    <SqlQuery Name="MailingEmailListSelectSqlQuery">
      <Text>
        WITH
         _mailing AS (
           SELECT
             mailing_id,
             send_date,
             download_date,
             mailing_template_id,
             mailing_template_text,
             create_date,
             special,
             mailing_email_id,
             inner_org_id,
             email_sender,
             subject,
             description,
             author_id = {UserId} OR collect.is_administrator({UserId}::smallint) AS user_editable
           FROM
             collect.mailing
             LEFT JOIN collect.mailing_email USING (mailing_id)
           WHERE
             added AND
             (send_date IS NULL OR
             send_date BETWEEN {DateStart}::date - interval '{TimeZoneDiff}h' AND {DateFinish}::date - interval '{TimeZoneDiff}h' + interval '24h - 1s')
         ), _loan_client_mailing_email AS (
           SELECT
             DISTINCT mailing_id,
             loan_client_id,
             client_title,
             credit_number,
             sent
           FROM
             _mailing
             LEFT JOIN collect.loan_client_mailing_email USING (mailing_email_id)
             LEFT JOIN collect.loan_client USING (loan_client_id)
             LEFT JOIN collect.loan USING (loan_id)
         ), _loan_client_arr AS (
           SELECT
             SUM(CASE WHEN COALESCE(sent, false) THEN 1 ELSE 0 END) AS sent_count_message,
             COUNT(*) AS count_message,
             array_agg(DISTINCT loan_client_id) AS loan_client_ids,
             array_agg(DISTINCT client_title) AS client_titles,
             array_agg(DISTINCT credit_number) AS credit_numbers,
             mailing_id
           FROM
             _loan_client_mailing_email
           GROUP BY mailing_id
         ), _files AS (
           SELECT
             M.mailing_email_id,
             array_agg(DISTINCT name) AS file_names
           FROM
             _mailing M
              JOIN (SELECT DISTINCT mailing_email_id FROM collect.loan_client_mailing_email) D USING (mailing_email_id)
              JOIN 
              (
                SELECT mailing_id, mailing_email_id, file_id, template_id
                FROM collect.mailing_email_file LEFT JOIN collect.mailing_email USING (mailing_email_id) 
              ) MEF ON M.mailing_email_id = MEF.mailing_email_id OR (M.mailing_id = MEF.mailing_id AND template_id ISNULL)
             LEFT JOIN public.file USING (file_id)
           GROUP BY M.mailing_email_id
         )
         SELECT DISTINCT ON (M.mailing_id)
          M.mailing_id AS "MailingId",
          M.send_date AS "SendDate",
          M.mailing_template_id AS "MailingTemplateId",
          MT.title AS "MailingTemplateTitle",
          M.mailing_template_text AS "MailingTemplateText",
          loan_client_ids AS "LoanClientIds",
          collect.get_title_from_array(client_titles, 'должник'::varchar) AS "ClientTitles",
          collect.get_title_from_array(credit_numbers, 'дел'::varchar) AS "CreditNumbers",
          CASE
            WHEN M.download_date IS NULL
            THEN 'Черновик'
            WHEN count_message = sent_count_message
            THEN 'Все' ELSE sent_count_message || ' из ' || count_message
          END AS "DelivereStatus",
          M.download_date IS NULL AS "IsDraft",
          special AS "Special",
          collect.get_title_from_array(_files.file_names, 'файл'::varchar) AS "FileNames",
          sent_count_message>0 AS "IsSent",
          NOT user_editable OR sent_count_message>0 AS "ReadOnly"
        FROM
          _mailing M
          LEFT JOIN collect.mailing_template MT USING(mailing_template_id)
          LEFT JOIN _loan_client_arr USING(mailing_id)
          LEFT JOIN _files USING(mailing_email_id)
        ORDER BY
          M.mailing_id,
          M.download_date IS NOT NULL,
          M.send_date,
          M.mailing_email_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanClientForMailingSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_administrator({UserId}::smallint) AS user_is_administrator,
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), loan_users AS (
          SELECT
            loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client
          WHERE
            user_id IS NOT NULL
          GROUP BY loan_id)

        SELECT
          loan_client_id AS "LoanClientId",
          client_id AS "ClientId",
          loan_id AS "LoanId",
          'Номер КД: ' || COALESCE(L.credit_number, '') AS "LoanTitle"
        FROM
          collect.loan_client LC
          LEFT JOIN collect.loan L USING (loan_id)
          LEFT JOIN loan_users LU USING (loan_id)
          LEFT JOIN current_user_info CUI ON true
        WHERE
          NOT L.deleted AND
          NOT L.archive AND
          (CUI.user_is_administrator OR
          (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
          {UserId} = ANY(LU.user_ids));
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanClientEmailByIdSqlQuery">
      <Text>
        WITH _loan_client_mailing_email AS (
          SELECT
            loan_client_mailing_email_id,
            mailing_email_id,
            loan_client_id,
            client_title,
            email_client,
            sent
          FROM
            collect.loan_client_mailing_email
            LEFT JOIN collect.mailing_email ME USING (mailing_email_id)
          WHERE
            COALESCE(mailing_email_id = {MailingEmailId}, mailing_id = {MailingId})
            AND COALESCE(loan_client_mailing_email_id = {LoanClientMailingEmailId}, true)
        ), _message AS (
          SELECT
            message,
            loan_client_mailing_email_id
          FROM
            collect.get_message_with_replaced_variables((SELECT array_agg(loan_client_mailing_email_id)::bigint[] FROM _loan_client_mailing_email)::bigint[])
        )
        SELECT
          CASE WHEN {Copy} THEN NULL ELSE LCME.loan_client_mailing_email_id END AS "LoanClientMailingEmailId",
          LC.loan_client_id AS "LoanClientId",
          LC.client_id AS "ClientId",
          L.loan_id AS "LoanId",
          CASE WHEN {Copy} THEN NULL ELSE ME.mailing_email_id END AS "MailingEmailId",
          L.credit_number AS "LoanTitle",
          collect.get_client_title(CP.first_name, CP.second_name, CP.third_name) AS "ClientTitle",
          LCME.email_client AS "ClientEmail",
          CASE
            WHEN {Copy} OR (LCME.sent ISNULL OR M.send_date ISNULL)
            THEN 'В ожидании'
            WHEN LCME.sent
            THEN 'Отправлено'
            WHEN NOT LCME.sent
            THEN 'Ошибка отправки'
          END AS "Status",
          _message.message AS "MessageText"
        FROM
          _loan_client_mailing_email LCME
          LEFT JOIN _message USING (loan_client_mailing_email_id)
          LEFT JOIN collect.mailing_email ME USING (mailing_email_id)
          LEFT JOIN collect.mailing M USING (mailing_id)
          LEFT JOIN collect.loan_client LC USING (loan_client_id)
          LEFT JOIN collect.client_person CP USING(client_id)
          LEFT JOIN collect.loan L USING(loan_id);
      </Text>
    </SqlQuery>

    <SqlQuery Name="LoanClientMailingEmailDeleteSqlQuery">
      <Text>
        SELECT collect.mailing_email_delete ({LoanClientMailingEmailIds}::bigint[], {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="MailingEmailDeleteSqlQuery">
      <Text>
        SELECT
          collect.mailing_email_file_delete(MEF.mailing_email_file_id, {UserId}::smallint)
        FROM
          collect.mailing_email_file MEF
          LEFT JOIN collect.mailing_email USING (mailing_email_id)
        WHERE
          mailing_id = {MailingId};

        SELECT
          collect.loan_client_mailing_email_delete(loan_client_mailing_email_id, {UserId}::smallint, true)
        FROM
          collect.loan_client_mailing_email
          LEFT JOIN collect.mailing_email USING (mailing_email_id)
        WHERE
          mailing_id = {MailingId};
        
        DELETE FROM collect.mailing_email
        WHERE
          mailing_id = {MailingId};
        
        DELETE FROM collect.mailing
        WHERE
          mailing_id = {MailingId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="MailingEmailByIdSelectSqlQuery">
      <Text>
        WITH _sent_mailing AS (
          SELECT
            bool_or(COALESCE(sent, false)) AS some_sent,
            count(*) AS loan_client_count,
            mailing_id
          FROM
            collect.loan_client_mailing_email
          LEFT JOIN collect.mailing_email USING (mailing_email_id)
          WHERE
            mailing_id = {MailingId} OR
            loan_client_mailing_email_id = {LoanClientMailingEmailId}
          GROUP BY mailing_id
        )
        SELECT
          send_date AS "SendDate",
          download_date AS "DownloadDate",
          mailing_template_id AS "MailingTemplateId",
          mailing_template_text AS "MailingTemplateText",
          create_date AS "CreateDate",
          mailing_email_id AS "MailingEmailId",
          inner_org_id AS "InnerOrgId",
          email_sender AS "EmailSender",
          subject AS "Subject",
          description AS "Description",
          special AND NOT {Copy} AS "Special",
          NOT (author_id = {UserId} OR collect.is_administrator({UserId}::smallint)) AND NOT {Copy} AS "Copyright",
          loan_client_count > 1 AS "IsMassMailing",
          some_sent AND NOT {Copy} AS "Sent"
        FROM
          _sent_mailing
          LEFT JOIN collect.mailing_email ME USING (mailing_id)
          LEFT JOIN collect.mailing USING (mailing_id);
      </Text>
    </SqlQuery>

    <SqlQuery Name="MailingEmailByLoanIdSelectSqlQuery">
      <Text>
        SELECT
          DISTINCT mailing_email_id AS "MailingEmailId"
        FROM
          collect.loan_client_mailing_email
          LEFT JOIN collect.loan_client USING (loan_client_id)
        WHERE
          loan_id = {LoanId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="MailingEmailFileByMailingEmailIdSelectSqlQuery">
      <Text>
        SELECT DISTINCT
          MEF.mailing_email_file_id AS "MailingEmailFileId",
          PF.guid AS "Guid",
          PF.name AS "FileName",
          T.template_id AS "TemplateId",
          T.title AS "TemplateTitle",
          LCME.loan_client_id AS "LoanClientId"
        FROM
          collect.mailing_email_file MEF
          LEFT JOIN collect.mailing_email ME USING (mailing_email_id)
          LEFT JOIN public.file PF USING (file_id)
          LEFT JOIN collect.template T USING (template_id)
          LEFT JOIN collect.loan_client_mailing_email LCME ON T.template_id NOTNULL AND MEF.mailing_email_id = LCME.mailing_email_id
        WHERE
          COALESCE(mailing_id = {MailingId}, ME.mailing_email_id = {MailingEmailId});
      </Text>
    </SqlQuery>

    <SqlQuery Name="MailingEmailFileByLoanIdSelectSqlQuery">
      <Text>
        WITH mailing_by_loan_id AS (
          SELECT DISTINCT 
            mailing_id
          FROM
            collect.loan_client_mailing_email
            LEFT JOIN collect.loan_client USING (loan_client_id)
            LEFT JOIN collect.mailing_email USING (mailing_email_id)
          WHERE
            loan_id = {LoanId}
        )
        SELECT
          MEF.mailing_email_file_id AS "MailingEmailFileId",
          ME.mailing_email_id AS "MailingEmailId",
          PF.guid AS "Guid",
          PF.name AS "FileName",
          T.template_id AS "TemplateId",
          T.title AS "TemplateTitle",
          LCME.loan_client_id AS "LoanClientId",
          MF.mailing_id AS "MailingId"
        FROM
          collect.mailing_email_file MEF
          LEFT JOIN collect.mailing_email ME USING (mailing_email_id)
          JOIN mailing_by_loan_id MF USING (mailing_id)
          LEFT JOIN public.file PF USING (file_id)
          LEFT JOIN collect.template T USING (template_id)
          LEFT JOIN collect.loan_client_mailing_email LCME ON T.template_id NOTNULL AND ME.mailing_email_id = LCME.mailing_email_id;
      </Text>
    </SqlQuery>

    <SqlQuery Name="MailingEmailSaveSqlQuery">
      <Text>
        SELECT collect.mailing_email_save({Model}::json, {UserId}::smallint);
      </Text>
    </SqlQuery>

    <SqlQuery Name="EmailSettingsSelectSqlQuery">
      <Text>
        WITH email_settings AS (
          SELECT
            UI.list_email,
            UES.smtp_server_address,
            UES.smtp_server_port,
            UES.email_sender,
            UES.email_password,
            UES.email_sender_name,
            UES.email_signature,
            UES.email_sender LIKE '%@%%.%' AS email_is_correct,
            true  AS smtp_server_address_is_correct,
            COALESCE(UES.email_sender,'') = '' AS email_is_empty,
            COALESCE(UES.smtp_server_address,'') = '' AS smtp_server_address_is_empty,
            UES.smtp_server_port ISNULL AS smtp_server_port_is_empty
          FROM
            collect.user_info UI
            LEFT JOIN collect.user_email_settings UES USING (user_id)
          WHERE
            user_id = {UserId}
        )
        SELECT
          collect.is_administrator({UserId}::smallint) AS "IsAdministrator",
          list_email AS "ListEmail",
          smtp_server_address AS "SmtpServerAddress",
          smtp_server_port AS "SmtpServerPort",
          email_sender AS "EmailSender",
          email_password AS "EmailPassword",
          email_sender_name AS "EmailSenderName",
          email_signature AS "EmailSignature",
          email_is_correct AND smtp_server_address_is_correct AND NOT email_is_empty AND NOT smtp_server_address_is_empty AND NOT smtp_server_port_is_empty AS "SettingsIsCorrect",
          email_is_correct AS "EmailIsCorrect",
          smtp_server_address_is_correct AS "SmtpServerAddressIsCorrect",
          email_is_empty AS "EmailIsEmpty",
          smtp_server_address_is_empty AS "SmtpServerAddressIsEmpty",
          smtp_server_port_is_empty AS "SmtpServerPortIsEmpty"
        FROM
          email_settings;
      </Text>
    </SqlQuery>

    <SqlQuery Name="MailingDraftToSentUpdateSqlQuery">
      <Text>
        UPDATE
          collect.mailing
        SET
          download_date = now()::timestamp,
          added = True
        WHERE
          mailing_id = COALESCE({MailingId}::bigint,
            (
              SELECT
                DISTINCT mailing_id
              FROM
                collect.loan_client_mailing_email LCME
                LEFT JOIN collect.mailing_email USING (mailing_email_id)
              WHERE
                mailing_email_id = {MailingEmailId}::bigint OR
                loan_client_mailing_email_id = {LoanClientMailingEmailId}::bigint
              LIMIT 1
            ));
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--==============ШАБЛОНЫ РАССЫЛКИ СООБЩЕНИЙ====================-->
    <!--============================================================-->

    <SqlQuery Name="MailingTemplateSelectSqlQuery">
      <Text>
        SELECT
          mailing_template_id AS "MailingTemplateId",
          mailing_template.name AS "Name",
          mailing_template.title AS "Title",
          text AS "Text",
          mailing_template.name IS NOT NULL AS "System",
          mailing_template.name IS NOT NULL AND mailing_template.name IS DISTINCT FROM NULL AS "SystemForSelect",
          archive AS "Archive",
          mailing_template.type AS "MessageType"
        FROM
          collect.mailing_template
          CROSS JOIN collect.settings
          LEFT JOIN collect.user_email_settings ON user_id = {UserId}
        WHERE
          (module_email_enabled AND module_email_available AND type = 'email'::collect.mailing_type AND {EmailVisible})
        ORDER BY mailing_template.title;
      </Text>
    </SqlQuery>

    <SqlQuery Name="MailingTemplateByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title",
          text AS "Text",
          name IS NOT NULL AS "System",
          CASE WHEN name IS NOT NULL THEN variables ELSE '[Получатель], [Отправитель]' END AS "Variables"
        FROM
          collect.mailing_template
        WHERE
          mailing_template_id = {MailingTemplateId}

        UNION

        SELECT
          null,
          null,
          false,
          '[Получатель], [Отправитель]'
        WHERE
          {MailingTemplateId} ISNULL;
      </Text>
    </SqlQuery>

    <SqlQuery Name="MailingTemplateInsertSqlQuery">
      <Text>
        INSERT INTO collect.mailing_template(
          title,
          text,
          variables,
          type)
        VALUES(
          {Title},
          {Text},
          {Variables},
          'email'::collect.mailing_type)
        RETURNING mailing_template_id AS "MailingTemplateId";
      </Text>
    </SqlQuery>

    <SqlQuery Name="MailingTemplateUpdateSqlQuery">
      <Text>
        UPDATE
          collect.mailing_template
        SET
          title = {Title},
          text = {Text}
        WHERE
          mailing_template_id = {MailingTemplateId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="MailingTemplateArchiveSqlQuery">
      <Text>
        UPDATE
          collect.mailing_template
        SET
          archive = {Archive}
        WHERE
          mailing_template_id = {MailingTemplateId} AND
          name IS NULL;
      </Text>
    </SqlQuery>

    <SqlQuery Name="MailingTemplateDeleteSqlQuery">
      <Text>
        SELECT collect.mailing_template_try_delete({MailingTemplateId});
      </Text>
    </SqlQuery>

    <SqlQuery Name="ModuleDebexCheckingTypeSelectSqlQuery">
      <Text>
        WITH module_debex_permission AS (
		  SELECT
		    module_debex_jurisdiction_available AND module_debex_jurisdiction_enabled AND debex_jurisdiction_check AS module_debex_jurisdiction_permission,
		    module_debex_fssp_available AND module_debex_fssp_enabled AND debex_fssp_check AS module_debex_fssp_permission,
		    module_debex_bankrupt_available AND module_debex_bankrupt_enabled AND debex_bankrupt_check AS module_debex_bankrupt_permission
		  FROM
            collect.user_info
		    LEFT JOIN collect.settings ON true
          WHERE user_id = {UserId}
		  LIMIT 1
		)
		SELECT
		  title AS "Title",
		  name AS "Name"
		FROM 
		  collect.debex_checking_type
		  LEFT JOIN module_debex_permission ON true
		WHERE
		  name = 'jurisdiction' AND
		  module_debex_jurisdiction_permission
		
		UNION ALL
		
		SELECT
		  title,
		  name
		FROM
		  collect.debex_checking_type
		  LEFT JOIN module_debex_permission ON true
		WHERE
		  name = 'fssp-deals' AND
		  module_debex_fssp_permission
		
		UNION ALL
		
		SELECT
		  title,
		  name
		FROM
		  collect.debex_checking_type
		  LEFT JOIN module_debex_permission ON true
		WHERE
		  name = 'bankrupt-instant' AND
		  module_debex_bankrupt_permission;
      </Text>
    </SqlQuery>

    <SqlQuery Name="DebexResultBankruptSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids,
            (SELECT list_client FROM collect.user_info WHERE user_id = {UserId}) AS list_client
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), loan_users AS (
          SELECT
            loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client
          WHERE
            user_id IS NOT NULL
          GROUP BY loan_id
        ), allowed_client AS (
          SELECT
		    DISTINCT client_id
		  FROM
		    collect.client
		    LEFT JOIN collect.loan_client USING(client_id)
		    LEFT JOIN loan_users LU USING(loan_id)
		    LEFT JOIN current_user_info CUI ON true
		  WHERE
		    (NOT (list_client = 'none') AND
		    (list_client = 'full' OR
		    (list_client = 'partial' AND
		    (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
		    {UserId} = ANY(LU.user_ids))))
        ), bankrupt AS (
          SELECT
            DRB.debex_result_bankrupt_id,
            DRB.bankrupt_type,
            DRB.client_title,
            DRB.check_date,
            DRB.application_date,
            DRB.case_number,
            DRB.efrsb_number,
            DRB.efrsb_link,
            DRB.out_court_bankrupt_end_date,
            DRB.next_session_date,
            DRB.recognition_date,
            DRB.sale_property_date,
            DRB.work_state_date,
            DRB.client_id
          FROM
            collect.debex_result_bankrupt DRB
            JOIN allowed_client AC USING(client_id)
          ORDER BY
            DRB.check_date
        ), bankrupt_count AS (
          SELECT
            count(*) AS total_rows,
            COALESCE(CEIL(count(*)::numeric/GREATEST(COALESCE({RowsPerPage}, count(*))::numeric, 1)), 1) AS total_pages
          FROM bankrupt
        ), final AS (
          SELECT
            row_number() over() AS "RowNumber",
            (SELECT bankrupt_count.total_rows FROM bankrupt_count) AS "TotalRows",
            (SELECT bankrupt_count.total_pages FROM bankrupt_count) AS "TotalPages",
            *
          FROM
            bankrupt
          LIMIT COALESCE({RowsPerPage}, (SELECT bankrupt_count.total_rows FROM bankrupt_count))
          OFFSET (GREATEST((LEAST((SELECT bankrupt_count.total_pages FROM bankrupt_count), 
            COALESCE({CurrentPage}, 1)) - 1)::integer, 0) * COALESCE({RowsPerPage}, (SELECT bankrupt_count.total_rows FROM bankrupt_count)))
        )
        SELECT
          F."RowNumber",
          F."TotalRows",
          F."TotalPages",
          F.debex_result_bankrupt_id AS "DebexResultBankruptId",
          F.bankrupt_type AS "BankruptType",
          F.client_title AS "ClientTitle",
          F.check_date AS "CheckDate",
          F.application_date AS "ApplicationDate",
          F.case_number AS "CaseNumber",
          F.efrsb_number AS "EFRSBNumber",
          F.efrsb_link AS "EFRSBLink",
          F.out_court_bankrupt_end_date AS "OutCourtBankruptEndDate",
          F.next_session_date AS "NextSessionDate",
          F.recognition_date AS "RecognitionDate",
          F.sale_property_date AS "SalePropertyDate",
          F.work_state_date AS "WorkStateDate",
          F.client_id AS "ClientId"
        FROM
          final F
        ORDER BY 
          F."RowNumber";
      </Text>
    </SqlQuery>

    <SqlQuery Name="DebexResultJurisdictionSelectSqlQuery">
      <Text>
        WITH current_user_info AS (
          SELECT
            collect.is_leading_specialist({UserId}::smallint) AS user_is_leading_specialist,
            array_agg(child_user_id) AS child_user_ids,
            (SELECT list_client FROM collect.user_info WHERE user_id = {UserId}) AS list_client
          FROM
            collect.user_user
          WHERE
            parent_user_id = {UserId}::smallint
        ), loan_users AS (
          SELECT
            loan_id,
            array_agg(DISTINCT user_id) AS user_ids
          FROM
            collect.loan_client
          WHERE
            user_id IS NOT NULL
          GROUP BY loan_id
        ), allowed_client AS (
          SELECT
		    DISTINCT client_id
		  FROM
		    collect.client
		    LEFT JOIN collect.loan_client USING(client_id)
		    LEFT JOIN loan_users LU USING(loan_id)
		    LEFT JOIN current_user_info CUI ON true
		  WHERE
		    (NOT (list_client = 'none') AND
		    (list_client = 'full' OR
		    (list_client = 'partial' AND
		    (CUI.user_is_leading_specialist AND LU.user_ids <![CDATA[&&]]> CUI.child_user_ids) OR
		    {UserId} = ANY(LU.user_ids))))
        ), debex_result_jurisdiction AS (
          SELECT
            debex_result_jurisdiction_id,
            check_date,
            application_date,
            client_title,
            client_address,
            court_title,
            court_address,
            osp_title,
            osp_address,
            NULL::character varying AS error,
            client_id
          FROM
            collect.debex_result_jurisdiction
          
          UNION ALL
          
          SELECT
            NULL::bigint,
            date,
            NULL::timestamp without time zone,
            client_title,
            client_address,
            NULL::character varying,
            NULL::character varying,
            NULL::character varying,
            NULL::character varying,
            CASE
              WHEN description IS NOT NULL
              THEN description
              ELSE status
            END,
            client_id
          FROM
            collect.debex_checking_error
          WHERE
            debex_checking_type_id = (SELECT debex_checking_type_id FROM collect.debex_checking_type WHERE title = 'jurisdiction')
        ), jurisdiction AS (
          SELECT
            DRJ.debex_result_jurisdiction_id,
            DRJ.check_date,
            DRJ.application_date,
            DRJ.client_title,
            DRJ.client_address,
            DRJ.court_title,
            DRJ.court_address,
            DRJ.osp_title,
            DRJ.osp_address,
            DRJ.error,
            DRJ.client_id
          FROM
            debex_result_jurisdiction DRJ
            JOIN allowed_client AC USING(client_id)
          ORDER BY
            DRJ.check_date
        ), jurisdiction_count AS (
          SELECT
            count(*) AS total_rows,
            COALESCE(CEIL(count(*)::numeric/GREATEST(COALESCE({RowsPerPage}, count(*))::numeric, 1)), 1) AS total_pages
          FROM jurisdiction
        ), final AS (
          SELECT
            row_number() over() AS "RowNumber",
            (SELECT jurisdiction_count.total_rows FROM jurisdiction_count) AS "TotalRows",
            (SELECT jurisdiction_count.total_pages FROM jurisdiction_count) AS "TotalPages",
            *
          FROM
            jurisdiction
          LIMIT COALESCE({RowsPerPage}, (SELECT jurisdiction_count.total_rows FROM jurisdiction_count))
          OFFSET (GREATEST((LEAST((SELECT jurisdiction_count.total_pages FROM jurisdiction_count), 
            COALESCE({CurrentPage}, 1)) - 1)::integer, 0) * COALESCE({RowsPerPage}, (SELECT jurisdiction_count.total_rows FROM jurisdiction_count)))
        )
        SELECT
          F."RowNumber",
          F."TotalRows",
          F."TotalPages",
          F.debex_result_jurisdiction_id AS "DebexResultJurisdictionId",
          F.check_date AS "CheckDate",
          F.application_date AS "ApplicationDate",
          F.client_title AS "ClientTitle",
          F.client_address AS "ClientAddress",
          F.court_title AS "CourtTitle",
          F.court_address AS "CourtAddress",
          F.osp_title AS "OspTitle",
          F.osp_address AS "OspAddress",
          F.error AS "Error",
          F.client_id AS "ClientId"
        FROM
          final F
        ORDER BY 
          F."RowNumber";
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--================Выгрузка оплат по госпошлине================-->
    <!--============================================================-->
    <SqlQuery Name="ApplicationTaxPaymentExportSaveSqlQuery">
      <Text>
        INSERT INTO collect.application_tax_payment_export(file_id, number, date, user_id)
        VALUES(
          {FileId}, 
          (SELECT module_application_tax_payment_export_next_num FROM collect.settings LIMIT 1),
          NOW(),
          {UserId});
          
        UPDATE collect.settings
        SET 
          module_application_tax_payment_export_next_num = module_application_tax_payment_export_next_num + 1;
          
        UPDATE collect.loan_client_collection
        SET
          application_tax_payment_export_id = CURRVAL('collect.application_tax_payment_export_id_seq')
        WHERE
          loan_client_collection_id = ANY({LoanClientCollectionIds}::bigint[]);
      </Text>
    </SqlQuery>

    <SqlQuery Name="ApplicationTaxPaymentExportUpdateSqlQuery">
      <Text>
        UPDATE collect.application_tax_payment_export
        SET
          date = NOW()
        WHERE
          application_tax_payment_export_id = {ApplicationTaxPaymentExportId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ApplicationTaxPaymentExportSelectSqlQuery">
      <Text>
        SELECT
          ATPE.application_tax_payment_export_id AS "ApplicationTaxPaymentExportId",
          ATPE."number" AS "Number",
          ATPE.date AS "Date",
          ATPE.file_id AS "FileId",
          REPLACE(F.path, '\\', '\') AS "FilePath",
          F.guid AS "GUID",
          T.loan_client_collection_ids AS "LoanClientCollectionIds"
        FROM
          collect.application_tax_payment_export ATPE
          LEFT JOIN (
            SELECT
              application_tax_payment_export_id,
              array_agg(loan_client_collection_id) AS loan_client_collection_ids
            FROM
              collect.loan_client_collection
            WHERE
              application_tax_payment_export_id IS NOT NULL
            GROUP BY
              application_tax_payment_export_id
          ) T USING(application_tax_payment_export_id)
          JOIN public.file F USING (file_id)
        ORDER BY "number";
      </Text>
    </SqlQuery>

    <SqlQuery Name="ApplicationTaxPaymentExportDeleteSqlQuery">
      <Text>
        DELETE FROM collect.application_tax_payment_export
        WHERE application_tax_payment_export_id = {ApplicationTaxPaymentExportId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="ApplicationTaxPaymentExportFileUpdateSqlQuery">
      <Text>
        UPDATE collect.application_tax_payment_export
        SET file_id =(SELECT file_id FROM public.file WHERE guid = {GUID})
        WHERE application_tax_payment_export_id = {ApplicationTaxPaymentExportId};
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--=========SMS-центр==========================================-->
    <!--============================================================-->
    <SqlQuery Name="SMSSettingsSelectSqlQuery">
      <Text>
        SELECT
          user_name AS "UserName",
          password AS "Password",
          sms_server_site AS "SMSServerSite"
        FROM collect.sms_settings
        WHERE name = 'SMSCenter';
      </Text>
    </SqlQuery>


    <!--============================================================-->
    <!--=================РАССЫЛКИ СООБЩЕНИЙ=========================-->
    <!--============================================================-->

    <SqlQuery Name="MessageMailingByIdSqlQuery">
      <Text>
        SELECT
          MM.date_sending AS "DateSending",
          MM.message_template_id AS "MessageTemplateId",
          MM.message_template_text AS "MessageTemplateText",
          MM.date_sending_to_server IS NULL AS "Draft"
        FROM collect.message_mailing MM
        WHERE MM.message_mailing_id = {MessageMailingId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="MessageMailingAddedSqlQuery">
      <Text>
        SELECT MM.added AS "Added"
        FROM collect.message_mailing MM
        WHERE MM.message_mailing_id = {MessageMailingId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="MessageMailingInsertEmptySqlQuery">
      <Text>
        INSERT INTO collect.message_mailing(message_template_id, message_template_text, date_sending, date_sending_to_server, author_id, message_type_id)
        VALUES({MessageTemplateId}, {MessageTemplateText}, {DateSending}, CASE WHEN {Draft}::boolean THEN NULL::timestamp without time zone ELSE now() END, {UserId}, 1) 
        RETURNING message_mailing_id AS "MessageMailingId";
      </Text>
    </SqlQuery>

    <SqlQuery Name="MessageMailingUpdateSqlQuery">
      <Text>
        UPDATE collect.message_mailing
        SET
          message_template_id = {MessageTemplateId},
          message_template_text = {MessageTemplateText},
          date_sending = {DateSending},
          date_sending_to_server = CASE WHEN {Draft}::boolean THEN NULL::timestamp without time zone ELSE now() END,
          added = True
        WHERE message_mailing_id = {MessageMailingId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="MessageMailingDeleteSqlQuery">
      <Text>
        SELECT collect.message_mailing_try_delete({MessageMailingId});
      </Text>
    </SqlQuery>

    <SqlQuery Name="MessageMailingClientContactSelectSqlQuery">
      <Text>
        WITH loan_count_t AS (
          SELECT
            client_id, 
            COUNT(*) count 
          FROM collect.loan_client LC
          WHERE status_id != 13 AND status_id != 19
          GROUP BY client_id
        ), loan_payment_summ_t AS (
          SELECT
            client_id, 
            SUM(sum) summ
          FROM
            collect.loan_client LC
            JOIN collect.loan_client_payment USING(loan_client_id)
          WHERE status_id != 13 AND status_id != 19
          GROUP BY client_id
        )
        SELECT DISTINCT ON ("ClientTitle", CPh.phone_number)
          CPh.client_id::int AS "ClientId",
          first_name || COALESCE(' ' || second_name, '') || COALESCE(' ' || third_name, '') AS "ClientTitle",
          CP.gender AS "Sex",
          C.archive AS "Archive",
          CPh.phone_number AS "Phone",
          CP.email AS "Email",
          PT.title AS "Description",
          CP.birth_date AS "DateOfBirth",
          CASE
            WHEN extract(month FROM CP.birth_date) = extract(month FROM CURRENT_DATE) AND extract(day FROM CP.birth_date) = extract(day FROM CURRENT_DATE) THEN 'Today'
            WHEN collect.next_birthday(CP.birth_date) - CURRENT_DATE <![CDATA[<=]]> 5 THEN '5days'
            ELSE 'Rest'
          END AS "DateOfBirthType",
          COALESCE(loan_count_t.count, 0) AS "LoanCount",
          CASE WHEN COALESCE(loan_count_t.count, 0) > 3 THEN 'More' ELSE 'Less' END AS "LoanCountType",
          COALESCE(loan_payment_summ_t.summ, 0) AS "LoanPaymentSumm",
          CASE WHEN COALESCE(loan_payment_summ_t.summ, 0) >= 25000 THEN 'More' ELSE 'Less' END AS "LoanPaymentSummType"
        FROM
          collect.client_phone CPh
          JOIN collect.phone_type PT USING(phone_type_id)
          JOIN collect.client C USING(client_id)
          JOIN collect.client_person AS CP USING(client_id)
          LEFT JOIN loan_count_t USING(client_id)
          LEFT JOIN loan_payment_summ_t USING(client_id)
       ORDER BY "ClientTitle"
      </Text>
    </SqlQuery>

    <SqlQuery Name="MessageMailingClientContactByClientIdSelectSqlQuery">
      <Text>
        SELECT phone_number AS "Phone", 
               birth_date AS "DateOfBirth"
        FROM collect.client_phone
        LEFT JOIN collect.client_person USING (client_id)
        WHERE client_id = {ClientId}
        ORDER BY is_main DESC, phone_number ASC;
      </Text>
    </SqlQuery>

    <SqlQuery Name="MessageMailingByClientSelectSqlQuery">
      <Text>
        SELECT 
          MM.message_mailing_id AS "MessageMailingId",
          MM.date_sending AS "DateSending",
          SMM.client_title AS "ClientTitle",
          SMM.phone AS "Contact",
          MT.title AS "MessageTemplateTitle",
          SMM.message_text AS "MessageText",
          collect.sms_status_get_title(SMM.sms_status_id, 2) AS "StatusTitle",
          T.name AS "TypeName",
          T.title AS "TypeTitle"
        FROM
          collect.message_mailing MM
          LEFT JOIN collect.message_type T USING (message_type_id)
          LEFT JOIN collect.message_template MT USING(message_template_id)
          LEFT JOIN collect.sms_mailing_message SMM USING(message_mailing_id)
        WHERE
          MM.added AND
          ({ClientId} IS NOT NULL AND (SMM.client_id = {ClientId}) OR
          {LoanClientId} IS NOT NULL AND (SMM.loan_client_id = {LoanClientId}))
        ORDER BY "DateSending" DESC, "MessageMailingId" DESC;
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--====================РАССЫЛКИ СМС============================-->
    <!--============================================================-->

    <SqlQuery Name="SMSMailingSelectSqlQuery">
      <Text>
         SELECT
          MM.message_mailing_id AS "MessageMailingId",
          MM.date_sending AS "DateSending",
          MM.message_template_id AS "MessageTemplateId",
          MAX(MT.title) AS "MessageTemplateTitle",
          MAX(client_ids) AS "ClientIds",
          CASE WHEN MAX(SMM2.count) <![CDATA[<=]]> 3 THEN array_to_string(max(client_titles), ', ') ELSE 
                    MAX(SMM2.count) || ': ' || array_to_string(ARRAY[MAX(client_titles[1]), MAX(client_titles[2])], ', ') || ' ' || 
                        'и ещё' || ' ' || MAX(SMM2.count) - 2 END AS "ClientTitles",
          SUM(COALESCE(SMM.cost, 0)) AS "Cost",
          CASE WHEN MM.date_sending_to_server IS NULL THEN 'Черновик' WHEN every(SMM.sms_status_id = 1) THEN 'Все' 
               ELSE SUM(CASE WHEN SMM.sms_status_id = 1 THEN 1 ELSE 0 END) || ' ' || 'из' || ' ' || COUNT(*) END AS "Delivered",
          MM.date_sending_to_server IS NULL AS "Draft",
          special AS "Special"
        FROM
          collect.message_mailing MM
          LEFT JOIN collect.message_template MT USING(message_template_id)
          LEFT JOIN collect.sms_mailing_message SMM USING(message_mailing_id)
          LEFT JOIN LATERAL(
            SELECT
              COUNT(*) as count,
              array_agg(client_id) as client_ids,
              array_agg(client_title ORDER BY client_title) as client_titles
            FROM
              (SELECT DISTINCT client_id, client_title
              FROM collect.sms_mailing_message SMM2
              WHERE SMM2.message_mailing_id = MM.message_mailing_id) t) AS SMM2 ON true
        WHERE
          MM.added AND MM.message_type_id = (SELECT message_type_id FROM collect.message_type WHERE name = 'sms') AND
          (date_sending IS NULL OR date_sending BETWEEN {DateStart}::date - interval '{TimeZoneDiff}h' AND {DateFinish}::date - interval '{TimeZoneDiff}h' + interval '24h - 1s')
        GROUP BY MM.message_mailing_id
        ORDER BY MM.date_sending_to_server IS NOT NULL, MM.date_sending, MM.message_mailing_id
      </Text>
    </SqlQuery>

    <SqlQuery Name="SMSMailingMessageSqlQuery">
      <Text>
        SELECT
          SMM.sms_mailing_message_id AS "SMSMailingMessageId",
          SMM.client_id AS "ClientId",
          SMM.client_title AS "ClientTitle",
          SMM.phone AS "Phone",
          SMM.cost AS "Cost",
          collect.sms_status_get_title(SMM.sms_status_id, {PublicUserId}) AS "SMSStatusTitle"
        FROM collect.sms_mailing_message SMM
        WHERE SMM.message_mailing_id = {MessageMailingId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="SMSSettingsCheckSelectSqlQuery">
      <Text>
        SELECT EXISTS (SELECT * FROM collect.sms_settings WHERE name = 'SMSCenter') AS "Ok";
      </Text>
    </SqlQuery>

    <SqlQuery Name="SMSMailingInsertSqlQuery">
      <Text>
        INSERT INTO collect.message_mailing(message_template_id, message_template_text, author_id, special, message_type_id)
        VALUES({MessageTemplateId}, {MessageTemplateText}, {UserId}, True, (SELECT message_type_id FROM collect.message_type WHERE name = 'sms'))
        RETURNING message_mailing_id AS "MessageMailingId";
        
        INSERT INTO collect.sms_mailing_message(message_mailing_id, client_id, client_title, phone, sms_status_id, loan_client_id)
        VALUES(CURRVAL('collect.message_mailing_id_seq'), {ClientId}, {ClientTitle}, {Phone}, -3 , {LoanClientId});
      </Text>
    </SqlQuery>

    <SqlQuery Name="SMSMailingCopySqlQuery">
      <Text>
        INSERT INTO collect.message_mailing(message_template_id, message_template_text, author_id, date_sending, added, message_type_id)
        SELECT message_template_id, message_template_text, {UserId}, date_sending, False, message_type_id
        FROM collect.message_mailing
        WHERE message_mailing_id = {MessageMailingId}
        RETURNING message_mailing_id AS "MessageMailingId";
        
        INSERT INTO collect.sms_mailing_message(message_mailing_id, client_id, client_title, phone, sms_status_id)
        SELECT CURRVAL('collect.message_mailing_id_seq'), client_id, client_title, phone, -3
        FROM collect.sms_mailing_message
        WHERE message_mailing_id = {MessageMailingId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="SMSMailingMessageInsertSqlQuery">
      <Text>
        INSERT INTO collect.sms_mailing_message(message_mailing_id, client_id, client_title, phone, sms_status_id)
        VALUES({MessageMailingId}, {ClientId}, {ClientTitle}, {Phone}, -3);
      </Text>
    </SqlQuery>

    <SqlQuery Name="SMSMailingMessageDeleteSqlQuery">
      <Text>
        DELETE FROM collect.sms_mailing_message
        WHERE sms_mailing_message_id = {SMSMailingMessageId};
      </Text>
    </SqlQuery>

    <!--============================================================-->
    <!--==============ШАБЛОНЫ РАССЫЛКИ СООБЩЕНИЙ====================-->
    <!--============================================================-->

    <SqlQuery Name="MessageTemplateSelectSqlQuery">
      <Text>
        SELECT
          message_template_id AS "MessageTemplateId",
          message_template.name AS "Name",
          message_template.title AS "Title",
          text AS "Text",
          message_template.name IS NOT NULL AS "System",
          message_template.name IS NOT NULL AND message_template.name IS DISTINCT FROM NULL AS "SystemForSelect",
          archive AS "Archive",
          message_type.title AS "MessageTypeTitle",
          message_type.name AS "MessageType"
        FROM collect.message_template
        LEFT JOIN collect.message_type USING(message_type_id)
        CROSS JOIN collect.settings
        WHERE
          NOT hide_sms_module AND message_type.name = 'sms' AND {SMSVisible}
        ORDER BY message_template.title;
      </Text>
    </SqlQuery>

    <SqlQuery Name="MessageTemplateByIdSelectSqlQuery">
      <Text>
        SELECT
          title AS "Title",
          text AS "Text",
          name IS NOT NULL AS "System",
          CASE WHEN name IS NOT NULL THEN variables ELSE '[Должник]' END AS "Variables"
        FROM collect.message_template
        WHERE message_template_id = {MessageTemplateId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="MessageTemplateInsertSqlQuery">
      <Text>
        INSERT INTO collect.message_template (title, text, message_type_id)
        VALUES ({Title}, {Text}, (SELECT message_type_id FROM collect.message_type WHERE name = {MessageType}))
        RETURNING message_template_id AS "MessageTemplateId";
      </Text>
    </SqlQuery>

    <SqlQuery Name="MessageTemplateUpdateSqlQuery">
      <Text>
        UPDATE collect.message_template
        SET
          title = {Title},
          text = {Text}
        WHERE message_template_id = {MessageTemplateId};
      </Text>
    </SqlQuery>

    <SqlQuery Name="MessageTemplateArchiveSqlQuery">
      <Text>
        UPDATE collect.message_template
        SET archive = {Archive}
        WHERE
          message_template_id = {MessageTemplateId} AND
          name IS NULL;
      </Text>
    </SqlQuery>

    <SqlQuery Name="MessageTemplateDeleteSqlQuery">
      <Text>
        SELECT collect.message_template_try_delete({MessageTemplateId});
      </Text>
    </SqlQuery>
  </SqlQueries>

  <Permissions>
    <Permission Name="BaseSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="UserLoginSelectSqlQuery" />
        <SqlQuery Name="PermissionSelectSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="UserSettingsSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="TimeZoneInfoSelectSqlQuery" />
        <SqlQuery Name="UserTimeZoneInfoSelectSqlQuery" />
        <SqlQuery Name="UserSettingsUpdateSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="SettingsSqlQueryPermission">
      <SqlQuery Name="TimeZoneInfoSelectSqlQuery" />
      <SqlQuery Name="LoadModeSelectSqlQuery" />
      <SqlQuery Name="NotificationTypeSelectSqlQuery" />
      <SqlQuery Name="NotificationTargetSelectSqlQuery" />
      <SqlQuery Name="SettingsSelectSqlQuery" />
      <SqlQuery Name="BkiSettingsSelectSqlQuery" />
      <SqlQuery Name="DebtTypeSelectSqlQuery" />
      <SqlQuery Name="NbkiFormatVersionSelectSqlQuery" />
      <SqlQuery Name="EquifaxFormatVersionSelectSqlQuery" />
      <SqlQuery Name="OkbFormatVersionSelectSqlQuery" />
      <SqlQuery Name="SettingsUpdateSqlQuery" />
      <SqlQuery Name="SMSSettingsSelectSqlQuery" />
      <Command Name="HappyBirthdaySMSMailingSchedulerConditionRefreshCommand" />
    </Permission>

    <Permission Name="PochtaRuSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="PochtaRuTypeSelectSqlQuery" />
        <SqlQuery Name="PochtaRuOrderSelectSqlQuery" />
        <SqlQuery Name="PochtaRuOrderSelectByIdSqlQuery" />
        <SqlQuery Name="PochtaRuOrderAddressSelectByIdSqlQuery" />
        <SqlQuery Name="PochtaRuOrderErrorsSelectSqlQuery" />
        <SqlQuery Name="OrderRateSelectByIdSqlQuery" />
        <SqlQuery Name="PochtaRuOrderInsertSqlQuery" />
        <SqlQuery Name="PochtaRuOrderUpdateSqlQuery" />
        <SqlQuery Name="PochtaRuOrderAddressUpdateSqlQuery" />
        <SqlQuery Name="PochtaRuBatchSelectSqlQuery" />
        <SqlQuery Name="PochtaRuBatchSelectByIdSqlQuery" />
        <SqlQuery Name="BatchUpdateSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="PochtaRuCommandPermission" Type="CommandPermission">
      <Commands>
        <Command Name="PochtaRuDataNormalizeAddressCommand" />
        <Command Name="PochtaRuDataCalculateRateCommand" />
        <Command Name="PochtaRuOrderCreateCommand" />
        <Command Name="PochtaRuOrderEditCommand" />
        <Command Name="PochtaRuOrderSearchByIdCommand" />
        <Command Name="PochtaRuOrderSearchByBarcodeCommand" />
        <Command Name="PochtaRuBatchCheckOrdersCommand" />
        <Command Name="PochtaRuBatchCheckAllCommand" />
        <Command Name="PochtaRuOrderDeleteCommand" />
        <Command Name="PochtaRuBatchCreateCommand" />
        <Command Name="PochtaRuBatchUpdateSendingDateCommand" />
        <Command Name="PochtaRuOrderMoveToBatchCommand" />
        <Command Name="PochtaRuOrderMoveBackToBacklogCommand" />
        <Command Name="PochtaRuBatchArchiveCommand" />
        <Command Name="PochtaRuBatchArchiveRevertCommand" />
        <Command Name="PochtaRuBatchDownloadDocumentsCommand" />
        <Command Name="PochtaRuOrderBacklogDownloadDocumentsCommand" />
        <Command Name="PochtaRuBatchDocumentsCheckInCommand" />
      </Commands>
    </Permission>

    <Permission Name="AboutSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="AboutSelectSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="StartFormSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="NotificationCountSqlQuery" />
        <SqlQuery Name="SettingsSelectSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="StartFormLoanSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="UserSimpleSelectSqlQuery" />
        <SqlQuery Name="ClaimantSimpleSelectSqlQuery" />
        <SqlQuery Name="InnerOrgSimpleSelectSqlQuery" />
        <SqlQuery Name="CessionSimpleSelectSqlQuery" />
        <SqlQuery Name="CourtSimpleSelectSqlQuery" />
        <SqlQuery Name="OspSelectSqlQuery" />
        <SqlQuery Name="CourtDocumentSelectSqlQuery" />
        <SqlQuery Name="RoleSelectSqlQuery" />
        <SqlQuery Name="StatusSelectSqlQuery" />
        <SqlQuery Name="Status2SelectSqlQuery" />

        <SqlQuery Name="LoanClientSelectSqlQuery" />

        <SqlQuery Name="LoanClientStatusUpdateSqlQuery" />
        <SqlQuery Name="LoanClientStatus2UpdateSqlQuery" />
        <SqlQuery Name="LoanClientStatus3UpdateSqlQuery" />
        <SqlQuery Name="LoanArchiveSqlQuery" />
        <SqlQuery Name="LoanDeleteSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="StartFormLoanExportSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="LoanClientForExportSelectSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="StartFormLoanUserUpdateSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="LoanClientUserUpdateSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="StartFormDocumentExportSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="LoanPostFromExportInsertSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="NotificationSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="NotificationSelectSqlQuery" />
        <SqlQuery Name="NotificationTypeSelectSqlQuery" />
        <SqlQuery Name="NotificationDeleteSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="DocumentExportSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="SettingsSelectSqlQuery" />
        <SqlQuery Name="LoanForExportSelectSqlQuery" />
        <SqlQuery Name="ClientSocialForExportSqlQuery" />
        <SqlQuery Name="ClientPhoneForExportSqlQuery" />
        <SqlQuery Name="ClientAddressForExportSqlQuery" />
        <SqlQuery Name="ClientPropertyMovableForExportSqlQuery" />
        <SqlQuery Name="ClientPropertyRealForExportSqlQuery" />
        <SqlQuery Name="ClientPropertyCompanyForExportSqlQuery" />
        <SqlQuery Name="ClientAccountForExportSqlQuery" />
        <SqlQuery Name="LoanClientRepaymentForExportSqlQuery" />
        <SqlQuery Name="LoanPaymentForExportSqlQuery" />
        <SqlQuery Name="LoanClientPaymentForExportSqlQuery" />
        <SqlQuery Name="NotificationDeleteSqlQuery" />
        <SqlQuery Name="TemplateForContextMenuSelectSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="PostSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="InnerOrgSimpleSelectSqlQuery" />
        <SqlQuery Name="LoanClientSimpleSelectSqlQuery" />
        <SqlQuery Name="ClientWithAddressSelectSqlQuery" />
        <SqlQuery Name="TemplateSelectSqlQuery" />

        <SqlQuery Name="PostSelectSqlQuery" />
        <SqlQuery Name="PostGuidSelectSqlQuery" />
        <SqlQuery Name="PostByIdSelectSqlQuery" />
        <SqlQuery Name="PostFileByPostIdSelectSqlQuery" />

        <SqlQuery Name="PostDeleteSqlQuery" />
        <SqlQuery Name="PostSaveSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="UserSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="GroupSelectSqlQuery" />

        <SqlQuery Name="UserSelectSqlQuery" />
        <SqlQuery Name="UserByIdSelectSqlQuery" />
        <SqlQuery Name="UserUserByIdSelectSqlQuery" />
        <SqlQuery Name="UserPhoneByUserIdSelectSqlQuery" />

        <SqlQuery Name="UserPasswordUpdateSqlQuery" />
        <SqlQuery Name="UserSaveSqlQuery" />
        <SqlQuery Name="UserArchiveSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="LoanSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="UserSimpleSelectSqlQuery" />
        <SqlQuery Name="UserPhoneSelectSqlQuery" />
        <SqlQuery Name="ClaimantSimpleSelectSqlQuery" />
        <SqlQuery Name="InnerOrgSimpleSelectSqlQuery" />
        <SqlQuery Name="CessionSimpleSelectSqlQuery" />
        <SqlQuery Name="CourtSimpleSelectSqlQuery" />
        <SqlQuery Name="OspSelectSqlQuery" />
        <SqlQuery Name="TaskTypeSelectSqlQuery" />
        <SqlQuery Name="ClientSimpleSelectSqlQuery" />
        <SqlQuery Name="ContactPersonTypeSelectSqlQuery" />
        <SqlQuery Name="LoanClientSimpleSelectSqlQuery" />
        <SqlQuery Name="InteractionTypeSelectSqlQuery" />
        <SqlQuery Name="CourtDocumentSelectSqlQuery" />
        <SqlQuery Name="CourtResultSelectSqlQuery" />
        <SqlQuery Name="RoleSelectSqlQuery" />
        <SqlQuery Name="CreditTypeSelectSqlQuery" />
        <SqlQuery Name="CreditLineTypeSelectSqlQuery" />
        <SqlQuery Name="CreditPurposeSelectSqlQuery" />
        <SqlQuery Name="CreditGetTypeSelectSqlQuery" />
        <SqlQuery Name="TemplateSelectSqlQuery" />
        <SqlQuery Name="TemplateForContextMenuSelectSqlQuery" />
        <SqlQuery Name="StatusSelectSqlQuery" />
        <SqlQuery Name="DebtTypeSelectSqlQuery" />

        <SqlQuery Name="LoanByIdSelectSqlQuery" />
        <SqlQuery Name="LoanByClientIdSelectSqlQuery" />
        <SqlQuery Name="ClientForLoanSelectSqlQuery" />
        <SqlQuery Name="ClientAddressForLoanSelectSqlQuery" />
        <SqlQuery Name="ClientPhoneForLoanSelectSqlQuery" />
        <SqlQuery Name="CessionHistoryByLoanIdSelectSqlQuery" />
        <SqlQuery Name="BkiErrorCountByLoanIdSelectSqlQuery" />
        <SqlQuery Name="BkiErrorByLoanIdSelectSqlQuery" />
        <SqlQuery Name="NotificationByLoanIdSelectSqlQuery" />
        <SqlQuery Name="InteractionByLoanIdSelectSqlQuery" />
        <SqlQuery Name="InteractionLimitByLoanIdSelectSqlQuery" />
        <SqlQuery Name="AudioFileByLoanIdSelectSqlQuery" />
        <SqlQuery Name="FileByLoanIdSelectSqlQuery" />
        <SqlQuery Name="FileFileByLoanIdSelectSqlQuery" />
        <SqlQuery Name="PaymentByLoanIdSelectSqlQuery" />
        <SqlQuery Name="PropertySearchByLoanIdSelectSqlQuery" />
        <SqlQuery Name="BankruptByClientIdSelectSqlQuery" />
        <SqlQuery Name="BankruptTypeSelectSqlQuery" />
        <SqlQuery Name="JurisdictionByClientIdSelectSqlQuery" />
        <SqlQuery Name="RepaymentByLoanIdSelectSqlQuery" />
        <SqlQuery Name="HistoryByLoanIdSelectSqlQuery" />
        <SqlQuery Name="SuccessionByLoanIdSelectSqlQuery" />
        <SqlQuery Name="CollectionByLoanIdSelectSqlQuery" />
        <SqlQuery Name="ApplicationTaxCalcSqlQuery" />
        <SqlQuery Name="ExecutiveByLoanIdSelectSqlQuery" />
        <SqlQuery Name="LoanClientByLoanIdSelectSqlQuery" />
        <SqlQuery Name="CommentByLoanIdSelectSqlQuery" />
        <SqlQuery Name="CommentFileByLoanIdSelectSqlQuery" />
        <SqlQuery Name="PostByLoanIdSelectSqlQuery" />
        <SqlQuery Name="PostFileByLoanIdSelectSqlQuery" />

        <SqlQuery Name="LoanEditDateSelectSqlQuery" />
        <SqlQuery Name="LoanCheckBeforeSaveSelectSqlQuery" />
        <SqlQuery Name="LoanSaveSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="TaskSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="UserSimpleSelectSqlQuery" />
        <SqlQuery Name="TaskTypeSelectSqlQuery" />
        <SqlQuery Name="ClientSimpleSelectSqlQuery" />
        <SqlQuery Name="LoanClientSimpleSelectSqlQuery" />
        <SqlQuery Name="TaskStatusSelectSqlQuery" />
        <SqlQuery Name="TaskLoanByTaskIdSelectSqlQuery" />
        <SqlQuery Name="LoanAllowedForUserSelectSqlQuery" />
        <SqlQuery Name="ClientAllowedForUserSelectSqlQuery" />

        <SqlQuery Name="TaskSelectSqlQuery" />
        <SqlQuery Name="TaskByIdSelectSqlQuery" />
        <SqlQuery Name="ResponsibleUserIdByTaskIdSelectSqlQuery" />

        <SqlQuery Name="TaskCommentByTaskIdSelectSqlQuery" />
        <SqlQuery Name="TaskSaveSqlQuery" />
        <SqlQuery Name="TaskStatusUpdateSqlQuery" />
        <SqlQuery Name="TaskDeleteSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ClaimantSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ClaimantSelectSqlQuery" />
        <SqlQuery Name="ClaimantByIdSelectSqlQuery" />
        <SqlQuery Name="ClaimantTypeSelectSqlQuery" />

        <SqlQuery Name="ClaimantInsertSqlQuery" />
        <SqlQuery Name="ClaimantUpdateSqlQuery" />
        <SqlQuery Name="ClaimantMergeSqlQuery" />
        <SqlQuery Name="ClaimantArchiveSqlQuery" />
        <SqlQuery Name="ClaimantDeleteSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="CessionSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ClaimantSimpleSelectSqlQuery" />
        <SqlQuery Name="InnerOrgSimpleSelectSqlQuery" />
        <SqlQuery Name="CessionTypeSelectSqlQuery" />
        <SqlQuery Name="AddressRegionSelectSqlQuery" />

        <SqlQuery Name="CessionSelectSqlQuery" />
        <SqlQuery Name="CessionByIdSelectSqlQuery" />
        <SqlQuery Name="LoanByCessionIdSelectSqlQuery" />

        <SqlQuery Name="LoanCessionUpdateSqlQuery" />
        <SqlQuery Name="CessionInsertSqlQuery" />
        <SqlQuery Name="CessionUpdateSqlQuery" />
        <SqlQuery Name="CessionArchiveSqlQuery" />
        <SqlQuery Name="CessionDeleteSqlQuery" />
        <SqlQuery Name="CessionMergeSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="InnerOrgSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="InnerOrgSelectSqlQuery" />
        <SqlQuery Name="InnerOrgByIdSelectSqlQuery" />

        <SqlQuery Name="InnerOrgInsertSqlQuery" />
        <SqlQuery Name="InnerOrgUpdateSqlQuery" />
        <SqlQuery Name="InnerOrgMergeSqlQuery" />
        <SqlQuery Name="InnerOrgArchiveSqlQuery" />
        <SqlQuery Name="InnerOrgDeleteSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="AddressRegionSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="AddressRegionSelectSqlQuery" />
        <SqlQuery Name="AddressRegionAlternativeSelectSqlQuery" />
        <SqlQuery Name="AddressRegionAlternativeByAddressRegionIdSelectSqlQuery" />
        <SqlQuery Name="AddressRegionAlternativeByIdSelectSqlQuery" />

        <SqlQuery Name="AddressRegionAlternativeInsertSqlQuery" />
        <SqlQuery Name="AddressRegionAlternativeUpdateSqlQuery" />
        <SqlQuery Name="AddressRegionAlternativeDeleteSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="AddressDistrictSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="AddressDistrictSelectSqlQuery" />
        <SqlQuery Name="AddressDistrictByIdSelectSqlQuery" />

        <SqlQuery Name="AddressDistrictInsertSqlQuery" />
        <SqlQuery Name="AddressDistrictUpdateSqlQuery" />
        <SqlQuery Name="AddressDistrictArchiveSqlQuery" />
        <SqlQuery Name="AddressDistrictDeleteSqlQuery" />
        <SqlQuery Name="AddressDistrictMergeSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="AddressCitySqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="AddressCitySelectSqlQuery" />
        <SqlQuery Name="AddressCityByIdSelectSqlQuery" />

        <SqlQuery Name="AddressCityInsertSqlQuery" />
        <SqlQuery Name="AddressCityUpdateSqlQuery" />
        <SqlQuery Name="AddressCityArchiveSqlQuery" />
        <SqlQuery Name="AddressCityDeleteSqlQuery" />
        <SqlQuery Name="AddressCityMergeSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="AddressStreetSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="AddressStreetSelectSqlQuery" />
        <SqlQuery Name="AddressStreetByIdSelectSqlQuery" />

        <SqlQuery Name="AddressStreetInsertSqlQuery" />
        <SqlQuery Name="AddressStreetUpdateSqlQuery" />
        <SqlQuery Name="AddressStreetArchiveSqlQuery" />
        <SqlQuery Name="AddressStreetDeleteSqlQuery" />
        <SqlQuery Name="AddressStreetMergeSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ClientSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="AddressRegionSelectSqlQuery" />
        <SqlQuery Name="AddressDistrictSelectSqlQuery" />
        <SqlQuery Name="AddressCityTypeSelectSqlQuery" />
        <SqlQuery Name="AddressCitySelectSqlQuery" />
        <SqlQuery Name="AddressStreetTypeSelectSqlQuery" />
        <SqlQuery Name="AddressStreetSelectSqlQuery" />
        <SqlQuery Name="TaskTypeSelectSqlQuery" />
        <SqlQuery Name="ClientSimpleSelectSqlQuery" />
        <SqlQuery Name="PhoneTypeSelectSqlQuery" />
        <SqlQuery Name="ContactPersonTypeSelectSqlQuery" />
        <SqlQuery Name="SellResultSelectSqlQuery" />
        <SqlQuery Name="AddressTypeSelectSqlQuery" />
        <SqlQuery Name="SocialWebsiteSelectSqlQuery" />
        <SqlQuery Name="LoanClientSimpleSelectSqlQuery" />


        <SqlQuery Name="ClientSelectSqlQuery" />
        <SqlQuery Name="ClientByIdSelectSqlQuery" />
        <SqlQuery Name="LoanClientStatsSelectSqlQuery" />
        <SqlQuery Name="LoanClientByClientIdSelectSqlQuery" />
        <SqlQuery Name="CommentByClientIdSelectSqlQuery" />
        <SqlQuery Name="ClientFileByClientIdSelectSqlQuery" />
        <SqlQuery Name="ClientPhotoSelectSqlQuery" />
        <SqlQuery Name="HistoryByClientIdSelectSqlQuery" />
        <SqlQuery Name="ClientPhoneByClientIdSelectSqlQuery" />
        <SqlQuery Name="ClientAccountByClientIdSelectSqlQuery" />
        <SqlQuery Name="ClientPropertyByClientIdSelectSqlQuery" />
        <SqlQuery Name="ClientAddressByClientIdSelectSqlQuery" />
        <SqlQuery Name="ClientSocialByClientIdSelectSqlQuery" />
        <SqlQuery Name="PaymentByClientIdSelectSqlQuery" />
        <SqlQuery Name="CommentByIdSelectSqlQuery" />
        <SqlQuery Name="CommentFileByCommentIdSelectSqlQuery" />

        <SqlQuery Name="ClientJurisdictionSelectSqlQuery" />
        <SqlQuery Name="ClientJurisdictionForExportSqlQuery" />
        <SqlQuery Name="ClientBankruptSelectSqlQuery" />
        <SqlQuery Name="ClientBankruptCheckDateUpdateSqlQuery" />

        <SqlQuery Name="ClientArchiveSqlQuery" />
        <SqlQuery Name="ClientEditDateSelectSqlQuery" />
        <SqlQuery Name="ClientCheckBeforeSaveSelectSqlQuery" />
        <SqlQuery Name="ClientSaveSqlQuery" />
        <SqlQuery Name="ClientDeleteSqlQuery" />
        <SqlQuery Name="ClientDuplicateGuidSelectSqlQuery" />
        <SqlQuery Name="ClientCheckBeforeMergeSqlQuery" />
        <SqlQuery Name="ClientMergeSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="CourtSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="AddressRegionSelectSqlQuery" />

        <SqlQuery Name="CourtSelectSqlQuery" />
        <SqlQuery Name="CourtByIdSelectSqlQuery" />
        <SqlQuery Name="CourtByClientIdSelectSqlQuery" />
        <SqlQuery Name="CourtAddressByCourtIdSelectSqlQuery" />

        <SqlQuery Name="CourtSaveSqlQuery" />
        <SqlQuery Name="CourtMergeSqlQuery" />
        <SqlQuery Name="CourtArchiveSqlQuery" />
        <SqlQuery Name="CourtDeleteSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="OspSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="OspSelectSqlQuery" />
        <SqlQuery Name="OspByIdSelectSqlQuery" />
        <SqlQuery Name="OspByClientIdSelectSqlQuery" />
        <SqlQuery Name="OspByAddressSelectSqlQuery" />
        <SqlQuery Name="OspAddressByOspIdSelectSqlQuery" />

        <SqlQuery Name="OspSaveSqlQuery" />
        <SqlQuery Name="OspMergeSqlQuery" />
        <SqlQuery Name="OspArchiveSqlQuery" />
        <SqlQuery Name="OspDeleteSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="TaskTypeSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="TaskTypeSelectSqlQuery" />
        <SqlQuery Name="TaskTypeByIdSelectSqlQuery" />

        <SqlQuery Name="TaskTypeInsertSqlQuery" />
        <SqlQuery Name="TaskTypeUpdateSqlQuery" />
        <SqlQuery Name="TaskTypeArchiveSqlQuery" />
        <SqlQuery Name="TaskTypeDeleteSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ApplicationTypeViewSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ApplicationTypeSelectSqlQuery" />
        <SqlQuery Name="ApplicationTypeTaxSelectSqlQuery" />
        <SqlQuery Name="ApplicationTypeByIdSelectSqlQuery" />
        <SqlQuery Name="ApplicationTypeTaxByApplicationTypeIdSelectSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ApplicationTypeEditSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ApplicationTypeSaveSqlQuery" />
        <SqlQuery Name="ApplicationTypeArchiveSqlQuery" />
        <SqlQuery Name="ApplicationTypeDeleteSqlQuery" />
        <SqlQuery Name="ApplicationTypeMergeSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ReportPaymentSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ClientSimpleSelectSqlQuery" />
        <SqlQuery Name="LoanClientSimpleSelectSqlQuery" />

        <SqlQuery Name="ReportPaymentSelectSqlQuery" />
        <SqlQuery Name="PaymentByPaymentIdSelectSqlQuery" />

        <SqlQuery Name="PaymentInsertSqlQuery" />
        <SqlQuery Name="PaymentUpdateSqlQuery" />
        <SqlQuery Name="PaymentDeleteSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ReportInteractionSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ReportInteractionSelectSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ReportDebtSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ReportDebtForPeriodSqlQuery" />
        <SqlQuery Name="ClaimantSimpleSelectSqlQuery" />
        <SqlQuery Name="CessionSimpleSelectSqlQuery" />
        <SqlQuery Name="InnerOrgSimpleSelectSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ReportTaxPaymentSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ReportApplicationTaxPaymentSelectSqlQuery" />
        <SqlQuery Name="PaymentExportToTxtSelectSqlQuery" />
        <SqlQuery Name="ApplicationTaxPaymentExportSaveSqlQuery" />
        <SqlQuery Name="UserSelectSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ReportUsersSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ReportUsersSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="DownloadAudioFilePermission">
      <Command Name="AudioDownloadCommand" />

      <SqlQuery Name="ClientSimpleSelectSqlQuery" />
      <SqlQuery Name="LoanSimpleSelectSqlQuery" />
      <SqlQuery Name="LoanClientSimpleSelectSqlQuery" />

      <SqlQuery Name="TempAudioFileSelectSqlQuery" />
      <SqlQuery Name="TempAudioFileByIdSelectSqlQuery" />

      <SqlQuery Name="TempAudioFileUpdateSqlQuery" />
      <SqlQuery Name="TempAudioFileToSaveUpdateSqlQuery" />
      <SqlQuery Name="TempAudioFileSaveSqlQuery" />
      <SqlQuery Name="ClientPhoneFromTempAudioInsertSqlQuery" />
      <SqlQuery Name="TempAudioFileDeleteSqlQuery" />
    </Permission>

    <Permission Name="DocumentTemplateSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="TemplateCategorySelectSqlQuery" />
        <SqlQuery Name="TemplateVariableSelectSqlQuery" />
        <SqlQuery Name="TreeStateInsertSqlQuery" />
        <SqlQuery Name="TreeStateDeleteSqlQuery" />

        <SqlQuery Name="TemplateSelectSqlQuery" />
        <SqlQuery Name="TemplateByIdSelectSqlQuery" />

        <SqlQuery Name="TemplateInsertSqlQuery" />
        <SqlQuery Name="TemplateUpdateSqlQuery" />
        <SqlQuery Name="TemplateArchiveSqlQuery" />
        <SqlQuery Name="TemplateDeleteSqlQuery" />

        <SqlQuery Name="FieldsSelectSqlQuery" />
        <SqlQuery Name="TemlplateUpdateFieldsSelectSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="DocumentTemplateCategorySqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="TemplateCategorySelectSqlQuery" />
        <SqlQuery Name="TemplateCategoryByIdSelectSqlQuery" />

        <SqlQuery Name="TemplateCategoryInsertSqlQuery" />
        <SqlQuery Name="TemplateCategoryUpdateSqlQuery" />
        <SqlQuery Name="TemplateCategoryArchiveSqlQuery" />
        <SqlQuery Name="TemplateCategoryDeleteSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ImportColumnSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ExcelImportColumnListSelectSqlQuery" />
        <SqlQuery Name="TxtImportColumnSelectSqlQuery" />
        <SqlQuery Name="ExcelImportColumnSelectSqlQuery" />
        <SqlQuery Name="ExcelImportColumnByIdSelectSqlQuery" />
        <SqlQuery Name="ExcelImportColumnUpdateSqlQuery" />

        <SqlQuery Name="ExcelImportParseTypeSelectSqlQuery" />
        <SqlQuery Name="ExcelImportDelimeterSelectSqlQuery" />
        <SqlQuery Name="ExcelImportColumnParseUpdateSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ImportLoanSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="TreeStateInsertSqlQuery" />
        <SqlQuery Name="TreeStateDeleteSqlQuery" />

        <SqlQuery Name="AddressShortDictionarySelectSqlQuery" />
        <SqlQuery Name="AddressDictionarySelectSqlQuery" />
        <SqlQuery Name="TempLoanAddressSelectSqlQuery" />
        <SqlQuery Name="TempLoanAddressUpdateSqlQuery" />

        <SqlQuery Name="TempLoanSelectSqlQuery" />

        <SqlQuery Name="TempLoanClearSqlQuery" />
        <SqlQuery Name="TempLoanInsertSqlQuery" />
        <SqlQuery Name="TempLoanAutoParseUpdateSqlQuery" />
        <SqlQuery Name="TempLoanReferencesUpdateSqlQuery" />
        <SqlQuery Name="TempLoanSaveSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ImportPaymentSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ClientSimpleSelectSqlQuery" />
        <SqlQuery Name="LoanClientSimpleSelectSqlQuery" />
        <SqlQuery Name="TreeStateInsertSqlQuery" />
        <SqlQuery Name="TreeStateDeleteSqlQuery" />

        <SqlQuery Name="TempPaymentSelectSqlQuery" />

        <SqlQuery Name="TempPaymentClearSqlQuery" />
        <SqlQuery Name="TempPaymentInsertFromExcelSqlQuery" />
        <SqlQuery Name="TempPaymentInsertFromTxtSqlQuery" />
        <SqlQuery Name="TempPaymentParseUpdateSqlQuery" />
        <SqlQuery Name="TempPaymentAutoParseUpdateSqlQuery" />
        <SqlQuery Name="TempPaymentReferencesUpdateSqlQuery" />
        <SqlQuery Name="TempPaymentToSaveUpdateSqlQuery" />
        <SqlQuery Name="TempPaymentUpdateSqlQuery" />
        <SqlQuery Name="TempPaymentSaveSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ImportCourtSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="TreeStateInsertSqlQuery" />
        <SqlQuery Name="TreeStateDeleteSqlQuery" />

        <SqlQuery Name="AddressShortDictionarySelectSqlQuery" />
        <SqlQuery Name="AddressDictionarySelectSqlQuery" />
        <SqlQuery Name="TempCourtAddressSelectSqlQuery" />
        <SqlQuery Name="TempCourtAddressUpdateSqlQuery" />

        <SqlQuery Name="TempCourtSelectSqlQuery" />

        <SqlQuery Name="TempCourtClearSqlQuery" />
        <SqlQuery Name="TempCourtInsertSqlQuery" />
        <SqlQuery Name="TempCourtReferencesUpdateSqlQuery" />
        <SqlQuery Name="TempCourtSaveSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ImportOspSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="TreeStateInsertSqlQuery" />
        <SqlQuery Name="TreeStateDeleteSqlQuery" />

        <SqlQuery Name="AddressShortDictionarySelectSqlQuery" />
        <SqlQuery Name="AddressDictionarySelectSqlQuery" />
        <SqlQuery Name="TempOspAddressSelectSqlQuery" />
        <SqlQuery Name="TempOspAddressUpdateSqlQuery" />

        <SqlQuery Name="TempOspSelectSqlQuery" />

        <SqlQuery Name="TempOspClearSqlQuery" />
        <SqlQuery Name="TempOspInsertSqlQuery" />
        <SqlQuery Name="TempOspReferencesUpdateSqlQuery" />
        <SqlQuery Name="TempOspSaveSqlQuery" />
      </SqlQueries>
    </Permission>
<!-- Здесь -->
    <Permission Name="StatusSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ColorSelectSqlQuery" />
        <SqlQuery Name="CloseReasonSelectSqlQuery" />

        <SqlQuery Name="StatusSelectSqlQuery" />
        <SqlQuery Name="StatusByIdSelectSqlQuery" />
        <SqlQuery Name="Status2SelectSqlQuery" />
        <SqlQuery Name="Status2ByIdSelectSqlQuery" />
        <SqlQuery Name="Status3SelectSqlQuery" />
        <SqlQuery Name="Status3ByIdSelectSqlQuery" />

        <SqlQuery Name="StatusInsertSqlQuery" />
        <SqlQuery Name="StatusUpdateSqlQuery" />
        <SqlQuery Name="StatusArchiveSqlQuery" />
        <SqlQuery Name="StatusOrderNumberIncreaseSqlQuery" />
        <SqlQuery Name="StatusOrderNumberDecreaseSqlQuery" />
        <SqlQuery Name="StatusDeleteSqlQuery" />

        <SqlQuery Name="Status2InsertSqlQuery" />
        <SqlQuery Name="Status2UpdateSqlQuery" />
        <SqlQuery Name="Status2ArchiveSqlQuery" />
        <SqlQuery Name="Status2OrderNumberIncreaseSqlQuery" />
        <SqlQuery Name="Status2OrderNumberDecreaseSqlQuery" />
        <SqlQuery Name="Status2DeleteSqlQuery" />
        <SqlQuery Name="Status3InsertSqlQuery" />
        <SqlQuery Name="Status3UpdateSqlQuery" />
        <SqlQuery Name="Status3ArchiveSqlQuery" />
        <SqlQuery Name="Status3OrderNumberIncreaseSqlQuery" />
        <SqlQuery Name="Status3OrderNumberDecreaseSqlQuery" />
        <SqlQuery Name="Status3DeleteSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ColorSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ColorSelectSqlQuery" />
        <SqlQuery Name="ColorByIdSelectSqlQuery" />

        <SqlQuery Name="ColorInsertSqlQuery" />
        <SqlQuery Name="ColorUpdateSqlQuery" />
        <SqlQuery Name="ColorArchiveSqlQuery" />
        <SqlQuery Name="ColorDeleteSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ClientAddressSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ClientAddressSelectSqlQuery" />
        <SqlQuery Name="ClientAddressByClientIdSelectSqlQuery" />
        <SqlQuery Name="ClientAddressUpdateSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="BkiSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="SettingsSelectSqlQuery" />
        <SqlQuery Name="LoanClientForNbkiSelectSqlQuery" />
        <SqlQuery Name="LoanClientForEquifaxSelectSqlQuery" />
        <SqlQuery Name="LoanClientForOkbSelectSqlQuery" />
        <SqlQuery Name="LoanClientIsCancelSelectSqlQuery" />
        <SqlQuery Name="BkiExportSelectSqlQuery" />
        <SqlQuery Name="BkiExportDetailSelectSqlQuery" />
        <SqlQuery Name="BkiErrorUpdateSqlQuery" />
        <SqlQuery Name="BkiExportInsertSqlQuery" />
        <SqlQuery Name="BkiExportDetailUpdateSqlQuery" />
        <SqlQuery Name="BkiErrorsSelectSqlQuery" />
        <SqlQuery Name="BkiExportSetNotAcceptedFromFileSqlQuery" />
        <SqlQuery Name="BkiIsCancelUpdateSqlQuery" />

        <SqlQuery Name="BkiLoanClientSelectSqlQuery" />
        <SqlQuery Name="BkiContactSelectSqlQuery" />
        <SqlQuery Name="BkiGuaranteeSelectSqlQuery" />
        <SqlQuery Name="BkiAddressSelectSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="FsspPermission">
      <SqlQuery Name="FsspInfoSelectSqlQuery" />
      <SqlQuery Name="FsspInfoByLoanIdSelectSqlQuery" />
      <SqlQuery Name="FsspInfoForApplySelectSqlQuery" />
      <SqlQuery Name="FsspTaskSelectSqlQuery" />
      <SqlQuery Name="CourtSimpleSelectSqlQuery" />
      <SqlQuery Name="OspSelectSqlQuery" />

      <SqlQuery Name="FsspTaskUpdateSqlQuery" />

      <Command Name="FsspCheckingCommand" />
    </Permission>

    <Permission Name="AutotaskPermission">
      <SqlQuery Name="AutotaskFilterSelectSqlQuery" />
      <SqlQuery Name="AutotaskFilterByIdSelectSqlQuery" />
      <SqlQuery Name="ResponsibleUserIdByAutotaskFilterIdSelectSqlQuery" />
      <SqlQuery Name="AutotaskFieldsSelectSqlQuery" />

      <SqlQuery Name="AutotaskFilterInsertSqlQuery" />
      <SqlQuery Name="AutotaskFilterUpdateSqlQuery" />
      <SqlQuery Name="AutotaskFilterArchiveSqlQuery" />

      <Command Name="AutotaskCommand" />
    </Permission>

    <Permission Name="EmailMailingPermission">
      <Command Name="SendEmailMailingCommand" />
      <Command Name="SendEmailMailingNowCommand" />

      <SqlQuery Name="EmailSettingsSelectSqlQuery" />
      <SqlQuery Name="MailingEmailListSelectSqlQuery" />
      <SqlQuery Name="MailingDraftToSentUpdateSqlQuery" />
      <SqlQuery Name="LoanClientMailingEmailDeleteSqlQuery" />
      <SqlQuery Name="MailingEmailDeleteSqlQuery" />
      <SqlQuery Name="MailingEmailByIdSelectSqlQuery" />
      <SqlQuery Name="MailingEmailFileByMailingEmailIdSelectSqlQuery" />
      <SqlQuery Name="MailingEmailByLoanIdSelectSqlQuery" />
      <SqlQuery Name="MailingEmailFileByLoanIdSelectSqlQuery" />
      <SqlQuery Name="MailingEmailSaveSqlQuery" />
      <SqlQuery Name="LoanClientEmailByIdSqlQuery" />
      <SqlQuery Name="LoanClientForMailingSqlQuery" />
    </Permission>

    <Permission Name="MailingTemplateSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="MailingTemplateSelectSqlQuery" />
        <SqlQuery Name="MailingTemplateByIdSelectSqlQuery" />
        <SqlQuery Name="MailingTemplateInsertSqlQuery" />
        <SqlQuery Name="MailingTemplateUpdateSqlQuery" />
        <SqlQuery Name="MailingTemplateDeleteSqlQuery" />
        <SqlQuery Name="MailingTemplateArchiveSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ViewPochtaRuOrderSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="PochtaRuOrderSelectSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="EditPochtaRuOrderSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="PochtaRuOrderInsertSqlQuery" />
        <SqlQuery Name="PochtaRuOrderUpdateSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="BankruptTypeSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="BankruptTypeSelectSqlQuery" />
        <SqlQuery Name="BankruptTypeByIdSelectSqlQuery" />

        <SqlQuery Name="BankruptTypeInsertSqlQuery" />
        <SqlQuery Name="BankruptTypeUpdateSqlQuery" />
        <SqlQuery Name="BankruptTypeArchiveSqlQuery" />
        <SqlQuery Name="BankruptTypeDeleteSqlQuery" />
        <SqlQuery Name="BankruptTypeMergeSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="DebexPermission">
      <Command Name="DebexCheckingCommand" />
      <SqlQuery Name="ModuleDebexCheckingTypeSelectSqlQuery" />
      <SqlQuery Name="DebexResultBankruptSelectSqlQuery" />
      <SqlQuery Name="ClientBankruptUpdateByDebexResultBankruptSqlQuery" />
      <SqlQuery Name="DebexResultJurisdictionSelectSqlQuery" />
      <SqlQuery Name="ClientJurisdictionUpdateByDebexResultJurisdictionSqlQuery" />
    </Permission>

    <Permission Name="FileSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="FileByGuidSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ApplicationTaxPaymentExportViewSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ApplicationTaxPaymentExportSelectSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="ApplicationTaxPaymentExportEditSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="ApplicationTaxPaymentExportUpdateSqlQuery" />
        <SqlQuery Name="ApplicationTaxPaymentExportDeleteSqlQuery" />
        <SqlQuery Name="ApplicationTaxPaymentExportFileUpdateSqlQuery" />
      </SqlQueries>
    </Permission>  
    
    <Permission Name="MessageTemplateViewSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="MessageTemplateSelectSqlQuery" />
        <SqlQuery Name="MessageTemplateByIdSelectSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="MessageTemplateManageSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="MessageTemplateInsertSqlQuery" />
        <SqlQuery Name="MessageTemplateUpdateSqlQuery" />
        <SqlQuery Name="MessageTemplateArchiveSqlQuery" />
        <SqlQuery Name="MessageTemplateDeleteSqlQuery" />
      </SqlQueries>
    </Permission>
    
    <Permission Name="MessageSendCommandPermission" Type="CommandPermission">
      <Commands>
        <Command Name="SMSGetBalanceCommand" />
        <Command Name="SMSTryGetBalanceCommand" />
        <Command Name="SMSGetStatusCommand" />
        <Command Name="SMSGetStatusByTaskCommand" />
        <Command Name="SMSTemplateGetCostCommand" />
        <Command Name="SMSClientGetCostCommand" />
        <Command Name="SMSClientSendCommand" />
        <Command Name="SMSLoanClientGetCostCommand" />
        <Command Name="SMSLoanClientSendCommand" />
        <Command Name="SMSMailingGetCostCommand" />
        <Command Name="SMSMailingSendCommand" />
      </Commands>
    </Permission>

    <Permission Name="MessageMailingViewSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="SMSMailingSelectSqlQuery" />
        <SqlQuery Name="MessageMailingByIdSqlQuery" />
        <SqlQuery Name="MessageMailingAddedSqlQuery" />
        <SqlQuery Name="SMSMailingMessageSqlQuery" />
        <SqlQuery Name="SMSSettingsCheckSelectSqlQuery" />
        <SqlQuery Name="MessageMailingClientContactByClientIdSelectSqlQuery" />
        <SqlQuery Name="MessageMailingClientContactSelectSqlQuery" />
        <SqlQuery Name="MessageMailingByClientSelectSqlQuery" />
      </SqlQueries>
    </Permission>

    <Permission Name="MessageMailingManageSqlQueryPermission" Type="SqlQueryPermission">
      <SqlQueries>
        <SqlQuery Name="MessageMailingInsertEmptySqlQuery" />
        <SqlQuery Name="SMSMailingInsertSqlQuery" />
        <SqlQuery Name="MessageMailingUpdateSqlQuery" />
        <SqlQuery Name="MessageMailingDeleteSqlQuery" />
        <SqlQuery Name="SMSMailingCopySqlQuery" />
        <SqlQuery Name="SMSMailingMessageInsertSqlQuery" />
        <SqlQuery Name="SMSMailingMessageDeleteSqlQuery" />
      </SqlQueries>
    </Permission>
  </Permissions>

  <Roles>
    <Role Name="BaseRole">
      <Permissions>
        <Permission Name="BaseSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="PochtaRuRole">
      <Permissions>
        <Permission Name="PochtaRuSqlQueryPermission" />
        <Permission Name="PochtaRuCommandPermission" />
      </Permissions>
    </Role>

    <Role Name="UserSettingsRole">
      <Permissions>
        <Permission Name="UserSettingsSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="AboutRole">
      <Permissions>
        <Permission Name="AboutSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="AdministratorRole">
      <Permissions>
        <Permission Name="SettingsSqlQueryPermission" />
        <Permission Name="StatusSqlQueryPermission" />
        <Permission Name="ColorSqlQueryPermission" />
        <Permission Name="UserSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="StartFormBaseRole">
      <Permissions>
        <Permission Name="StartFormSqlQueryPermission" />
        <Permission Name="StartFormLoanSqlQueryPermission" />
        <Permission Name="StartFormDocumentExportSqlQueryPermission" />
        <Permission Name="StartFormLoanExportSqlQueryPermission" />
        <Permission Name="PostSqlQueryPermission" />
        <Permission Name="DocumentExportSqlQueryPermission" />
        <Permission Name="TaskSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="StartFormAdvancedRole">
      <Permissions>
        <Permission Name="StartFormLoanUserUpdateSqlQueryPermission" />
        <Permission Name="ImportColumnSqlQueryPermission" />
        <Permission Name="ImportLoanSqlQueryPermission" />
        <Permission Name="ImportPaymentSqlQueryPermission" />
        <Permission Name="ImportCourtSqlQueryPermission" />
        <Permission Name="ImportOspSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="NotificationRole">
      <Permissions>
        <Permission Name="NotificationSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="LoanRole">
      <Permissions>
        <Permission Name="LoanSqlQueryPermission" />
        <Permission Name="DocumentExportSqlQueryPermission" />
        <Permission Name="ApplicationTypeViewSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="ClaimantRole">
      <Permissions>
        <Permission Name="ClaimantSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="CessionRole">
      <Permissions>
        <Permission Name="CessionSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="InnerOrgRole">
      <Permissions>
        <Permission Name="InnerOrgSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="AddressRole">
      <Permissions>
        <Permission Name="AddressRegionSqlQueryPermission" />
        <Permission Name="AddressDistrictSqlQueryPermission" />
        <Permission Name="AddressCitySqlQueryPermission" />
        <Permission Name="AddressStreetSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="ClientRole">
      <Permissions>
        <Permission Name="ClientSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="CourtRole">
      <Permissions>
        <Permission Name="CourtSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="OspRole">
      <Permissions>
        <Permission Name="OspSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="TaskTypeRole">
      <Permissions>
        <Permission Name="TaskTypeSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="ApplicationTypeRole">
      <Permissions>
        <Permission Name="ApplicationTypeEditSqlQueryPermission" />
        <Permission Name="ApplicationTypeViewSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="ReportRole">
      <Permissions>
        <Permission Name="ReportPaymentSqlQueryPermission" />
        <Permission Name="ReportInteractionSqlQueryPermission" />
        <Permission Name="ReportDebtSqlQueryPermission" />
        <Permission Name="ReportTaxPaymentSqlQueryPermission" />
        <Permission Name="ReportUsersSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="DownloadAudioFileRole">
      <Permissions>
        <Permission Name="DownloadAudioFilePermission" />
      </Permissions>
    </Role>

    <Role Name="DocumentTemplateRole">
      <Permissions>
        <Permission Name="DocumentTemplateSqlQueryPermission" />
        <Permission Name="DocumentTemplateCategorySqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="ClientAddressRole">
      <Permissions>
        <Permission Name="ClientAddressSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="BkiRole">
      <Permissions>
        <Permission Name="BkiSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="FsspRole">
      <Permissions>
        <Permission Name="FsspPermission" />
      </Permissions>
    </Role>

    <Role Name="AutotaskRole">
      <Permissions>
        <Permission Name="AutotaskPermission" />
      </Permissions>
    </Role>
    <Role Name="MailingRole">
      <Permissions>
        <Permission Name="EmailMailingPermission" />
        <Permission Name="MailingTemplateSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="PochtaRuOrderRole">
      <Permissions>
        <Permission Name="ViewPochtaRuOrderSqlQueryPermission" />
        <Permission Name="EditPochtaRuOrderSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="BankruptTypeRole">
      <Permissions>
        <Permission Name="BankruptTypeSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="DebexRole">
      <Permissions>
        <Permission Name="DebexPermission" />
      </Permissions>
    </Role>

    <Role Name="FileRole">
      <Permissions>
        <Permission Name="FileSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="ApplicationTaxPaymentExportRole">
      <Permissions>
        <Permission Name="ApplicationTaxPaymentExportViewSqlQueryPermission" />
        <Permission Name="ApplicationTaxPaymentExportEditSqlQueryPermission" />
      </Permissions>
    </Role>
    
    <Role Name="MessageTemplateRole">
      <Permissions>
        <Permission Name="MessageTemplateViewSqlQueryPermission" />
        <Permission Name="MessageTemplateManageSqlQueryPermission" />
      </Permissions>
    </Role>

    <Role Name="MessageTemplateBaseRole">
      <Permissions>
        <Permission Name="MessageTemplateViewSqlQueryPermission" />
      </Permissions>
    </Role>
    
    <Role Name="MessageMailingRole">
      <Permissions>
        <Permission Name="MessageSendCommandPermission" />
        <Permission Name="MessageMailingViewSqlQueryPermission" />
        <Permission Name="MessageMailingManageSqlQueryPermission" />
      </Permissions>
    </Role>
  </Roles>

  <Groups>
    <Group Name="AdministratorGroup">
      <Roles>
        <Role Name="PochtaRuRole" />
        <Role Name="BaseRole" />
        <Role Name="UserSettingsRole" />
        <Role Name="AboutRole" />
        <Role Name="AdministratorRole" />
        <Role Name="StartFormBaseRole" />
        <Role Name="StartFormAdvancedRole" />
        <Role Name="NotificationRole" />
        <Role Name="LoanRole" />
        <Role Name="ClaimantRole" />
        <Role Name="CessionRole" />
        <Role Name="InnerOrgRole" />
        <Role Name="AddressRole" />
        <Role Name="ClientRole" />
        <Role Name="CourtRole" />
        <Role Name="OspRole" />
        <Role Name="TaskTypeRole" />
        <Role Name="ReportRole" />
        <Role Name="DownloadAudioFileRole" />
        <Role Name="DocumentTemplateRole" />
        <Role Name="ClientAddressRole" />
        <Role Name="BkiRole" />
        <Role Name="FsspRole" />
        <Role Name="AutotaskRole" />
        <Role Name="MailingRole" />
        <Role Name="BankruptTypeRole" />
        <Role Name="DebexRole" />
        <Role Name="FileRole" />
        <Role Name="ApplicationTypeRole" />
        <Role Name="ApplicationTaxPaymentExportRole" />
        <Role Name="MessageTemplateRole" />
        <Role Name="MessageMailingRole" />
      </Roles>
    </Group>

    <Group Name="LeadingSpecialistGroup">
      <Roles>
        <Role Name="PochtaRuRole" />
        <Role Name="BaseRole" />
        <Role Name="UserSettingsRole" />
        <Role Name="AboutRole" />
        <Role Name="StartFormBaseRole" />
        <Role Name="StartFormAdvancedRole" />
        <Role Name="NotificationRole" />
        <Role Name="LoanRole" />
        <Role Name="ClaimantRole" />
        <Role Name="CessionRole" />
        <Role Name="InnerOrgRole" />
        <Role Name="AddressRole" />
        <Role Name="ClientRole" />
        <Role Name="CourtRole" />
        <Role Name="OspRole" />
        <Role Name="TaskTypeRole" />
        <Role Name="ReportRole" />
        <Role Name="DownloadAudioFileRole" />
        <Role Name="DocumentTemplateRole" />
        <Role Name="ClientAddressRole" />
        <Role Name="FsspRole" />
        <Role Name="MailingRole" />
        <Role Name="BankruptTypeRole" />
        <Role Name="DebexRole" />
        <Role Name="FileRole" />
        <Role Name="ApplicationTaxPaymentExportRole" />
        <Role Name="MessageTemplateRole" />
        <Role Name="MessageMailingRole" />
      </Roles>
    </Group>

    <Group Name="SpecialistGroup">
      <Roles>
        <Role Name="PochtaRuRole" />
        <Role Name="BaseRole" />
        <Role Name="UserSettingsRole" />
        <Role Name="AboutRole" />
        <Role Name="StartFormBaseRole" />
        <Role Name="NotificationRole" />
        <Role Name="LoanRole" />
        <Role Name="ClaimantRole" />
        <Role Name="CessionRole" />
        <Role Name="InnerOrgRole" />
        <Role Name="AddressRole" />
        <Role Name="ClientRole" />
        <Role Name="CourtRole" />
        <Role Name="OspRole" />
        <Role Name="TaskTypeRole" />
        <Role Name="ReportRole" />
        <Role Name="DownloadAudioFileRole" />
        <Role Name="DocumentTemplateRole" />
        <Role Name="ClientAddressRole" />
        <Role Name="FsspRole" />
        <Role Name="MailingRole" />
        <Role Name="BankruptTypeRole" />
        <Role Name="DebexRole" />
        <Role Name="FileRole" />
        <Role Name="ApplicationTaxPaymentExportRole" />
        <Role Name="MessageTemplateBaseRole" />
        <Role Name="MessageMailingRole" />
      </Roles>
    </Group>

    <Group Name="GuestGroup">
      <Roles>
        <Role Name="BaseRole" />
      </Roles>
    </Group>
  </Groups>
</Workflow>
